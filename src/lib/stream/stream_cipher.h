/*
* Stream Cipher
* (C) 1999-2007 Jack Lloyd
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#ifndef BOTAN_STREAM_CIPHER_H__
#define BOTAN_STREAM_CIPHER_H__

#include <botan/sym_algo.h>
#include <string>

namespace Botan {

/**
* Base class for all stream ciphers
*/
class BOTAN_DLL StreamCipher : public SymmetricAlgorithm {
public:
  virtual ~StreamCipher() {}

  /**
  * Create an instance based on a name
  * If provider is empty then best available is chosen.
  * @param algo_spec algorithm name
  * @param provider provider implementation to use
  * @return a null pointer if the algo/provider combination cannot be found
  */
  static std::unique_ptr<StreamCipher>
  create(const std::string& algo_spec,
         const std::string& provider = "");

  /**
  * Create an instance based on a name
  * If provider is empty then best available is chosen.
  * @param algo_spec algorithm name
  * @param provider provider implementation to use
  * Throws a Lookup_Error if the algo/provider combination cannot be found
  */
  static std::unique_ptr<StreamCipher>
  create_or_throw(const std::string& algo_spec,
                  const std::string& provider = "");

  /**
  * @return list of available providers for this algorithm, empty if not available
  */
  static std::vector<std::string> providers(const std::string& algo_spec);

  /**
  * Encrypt or decrypt a message
  * @param in the plaintext
  * @param out the byte array to hold the output, i.e. the ciphertext
  * @param len the length of both in and out in bytes
  */
  virtual void cipher(const uint8_t in[], uint8_t out[], size_t len) = 0;

  /**
  * Encrypt or decrypt a message
  * The message is encrypted/decrypted in place.
  * @param buf the plaintext / ciphertext
  * @param len the length of buf in bytes
  */
  void cipher1(uint8_t buf[], size_t len)
  { cipher(buf, buf, len); }

  /**
  * Encrypt a message
  * The message is encrypted/decrypted in place.
  * @param inout the plaintext / ciphertext
  */
  template<typename Alloc>
  void encipher(std::vector<uint8_t, Alloc>& inout)
  { cipher(inout.data(), inout.data(), inout.size()); }

  /**
  * Encrypt a message
  * The message is encrypted in place.
  * @param inout the plaintext / ciphertext
  */
  template<typename Alloc>
  void encrypt(std::vector<uint8_t, Alloc>& inout)
  { cipher(inout.data(), inout.data(), inout.size()); }

  /**
  * Decrypt a message in place
  * The message is decrypted in place.
  * @param inout the plaintext / ciphertext
  */
  template<typename Alloc>
  void decrypt(std::vector<uint8_t, Alloc>& inout)
  { cipher(inout.data(), inout.data(), inout.size()); }

  /**
  * Resync the cipher using the IV
  * @param iv the initialization vector
  * @param iv_len the length of the IV in bytes
  */
  virtual void set_iv(const uint8_t iv[], size_t iv_len) = 0;

  /**
  * @param iv_len the length of the IV in bytes
  * @return if the length is valid for this algorithm
  */
  virtual bool valid_iv_length(size_t iv_len) const { return (iv_len == 0); }

  /**
  * @return a new object representing the same algorithm as *this
  */
  virtual StreamCipher* clone() const = 0;

  /**
  * Set the offset and the state used later to generate the keystream
  * @param offset the offset where we begin to generate the keystream
  */
  virtual void seek(uint64_t offset) = 0;

  /**
  * @return provider information about this implementation. Default is "base",
  * might also return "sse2", "avx2", "openssl", or some other arbitrary string.
  */
  virtual std::string provider() const { return "base"; }
};

}

#endif
