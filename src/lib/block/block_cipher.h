/*
* Block Cipher Base Class
* (C) 1999-2009 Jack Lloyd
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#ifndef BOTAN_BLOCK_CIPHER_H__
#define BOTAN_BLOCK_CIPHER_H__

#include <botan/sym_algo.h>
#include <string>

namespace Botan {

/**
* This class represents a block cipher object.
*/
class BOTAN_DLL BlockCipher : public SymmetricAlgorithm {
public:

  /**
  * Create an instance based on a name
  * If provider is empty then best available is chosen.
  * @param algo_spec algorithm name
  * @param provider provider implementation to choose
  * @return a null pointer if the algo/provider combination cannot be found
  */
  static std::unique_ptr<BlockCipher>
  create(const std::string& algo_spec,
         const std::string& provider = "");

  /**
  * Create an instance based on a name, or throw if the
  * algo/provider combination cannot be found. If provider is
  * empty then best available is chosen.
  */
  static std::unique_ptr<BlockCipher>
  create_or_throw(const std::string& algo_spec,
                  const std::string& provider = "");

  /**
  * @return list of available providers for this algorithm, empty if not available
  * @param algo_spec algorithm name
  */
  static std::vector<std::string> providers(const std::string& algo_spec);

  /**
  * @return block size of this algorithm
  */
  virtual size_t block_size() const = 0;

  /**
  * @return native parallelism of this cipher in blocks
  */
  virtual size_t parallelism() const { return 1; }

  /**
  * @return prefererred parallelism of this cipher in bytes
  */
  size_t parallel_bytes() const {
    return parallelism() * block_size() * BOTAN_BLOCK_CIPHER_PAR_MULT;
  }

  /**
  * @return provider information about this implementation. Default is "base",
  * might also return "sse2", "avx2", "openssl", or some other arbitrary string.
  */
  virtual std::string provider() const { return "base"; }

  /**
  * Encrypt a block.
  * @param in The plaintext block to be encrypted as a byte array.
  * Must be of length block_size().
  * @param out The byte array designated to hold the encrypted block.
  * Must be of length block_size().
  */
  void encrypt(const uint8_t in[], uint8_t out[]) const
  { encrypt_n(in, out, 1); }

  /**
  * Decrypt a block.
  * @param in The ciphertext block to be decypted as a byte array.
  * Must be of length block_size().
  * @param out The byte array designated to hold the decrypted block.
  * Must be of length block_size().
  */
  void decrypt(const uint8_t in[], uint8_t out[]) const
  { decrypt_n(in, out, 1); }

  /**
  * Encrypt a block.
  * @param block the plaintext block to be encrypted
  * Must be of length block_size(). Will hold the result when the function
  * has finished.
  */
  void encrypt(uint8_t block[]) const { encrypt_n(block, block, 1); }

  /**
  * Decrypt a block.
  * @param block the ciphertext block to be decrypted
  * Must be of length block_size(). Will hold the result when the function
  * has finished.
  */
  void decrypt(uint8_t block[]) const { decrypt_n(block, block, 1); }

  /**
  * Encrypt one or more blocks
  * @param block the input/output buffer (multiple of block_size())
  */
  template<typename Alloc>
  void encrypt(std::vector<uint8_t, Alloc>& block) const {
    return encrypt_n(block.data(), block.data(), block.size() / block_size());
  }

  /**
  * Decrypt one or more blocks
  * @param block the input/output buffer (multiple of block_size())
  */
  template<typename Alloc>
  void decrypt(std::vector<uint8_t, Alloc>& block) const {
    return decrypt_n(block.data(), block.data(), block.size() / block_size());
  }

  /**
  * Encrypt one or more blocks
  * @param in the input buffer (multiple of block_size())
  * @param out the output buffer (same size as in)
  */
  template<typename Alloc, typename Alloc2>
  void encrypt(const std::vector<uint8_t, Alloc>& in,
               std::vector<uint8_t, Alloc2>& out) const {
    return encrypt_n(in.data(), out.data(), in.size() / block_size());
  }

  /**
  * Decrypt one or more blocks
  * @param in the input buffer (multiple of block_size())
  * @param out the output buffer (same size as in)
  */
  template<typename Alloc, typename Alloc2>
  void decrypt(const std::vector<uint8_t, Alloc>& in,
               std::vector<uint8_t, Alloc2>& out) const {
    return decrypt_n(in.data(), out.data(), in.size() / block_size());
  }

  /**
  * Encrypt one or more blocks
  * @param in the input buffer (multiple of block_size())
  * @param out the output buffer (same size as in)
  * @param blocks the number of blocks to process
  */
  virtual void encrypt_n(const uint8_t in[], uint8_t out[],
                         size_t blocks) const = 0;

  /**
  * Decrypt one or more blocks
  * @param in the input buffer (multiple of block_size())
  * @param out the output buffer (same size as in)
  * @param blocks the number of blocks to process
  */
  virtual void decrypt_n(const uint8_t in[], uint8_t out[],
                         size_t blocks) const = 0;

  /**
  * @return new object representing the same algorithm as *this
  */
  virtual BlockCipher* clone() const = 0;

  virtual ~BlockCipher() {}
};

/**
* Represents a block cipher with a single fixed block size
*/
template<size_t BS, size_t KMIN, size_t KMAX = 0, size_t KMOD = 1>
class Block_Cipher_Fixed_Params : public BlockCipher {
public:
  enum { BLOCK_SIZE = BS };
  size_t block_size() const override { return BS; }

  Key_Length_Specification key_spec() const override {
    return Key_Length_Specification(KMIN, KMAX, KMOD);
  }
};

}

#endif
