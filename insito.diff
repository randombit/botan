#
# old_revision [395d2422f2f4965427f9d46013c63f9e49958e92]
#
# patch "checks/algos.cpp"
#  from [99cdd8b6e21dbd9160fe5235e95c5a65e2c69b6b]
#    to [939e8b28072c8d1abf27f7d6094a94ac47e0ee2f]
# 
# patch "checks/bench.cpp"
#  from [380f38c3230ff1cc3599246b0c9152d77994f7a6]
#    to [099da45709079bb4bc70a72d7567a36a72eace33]
# 
# patch "checks/bigint.cpp"
#  from [51aea731b8d78f775d76dfa8eefa899ab31db372]
#    to [0822a8fae52f68509b9ede9334ddeac655a29058]
# 
# patch "checks/block.cpp"
#  from [f8ca4b45ff803f4d35d5ebf92874749a44beb1a3]
#    to [01e73abdda8f789cb2724e41ccfda5dcc238aaa0]
# 
# patch "checks/check.cpp"
#  from [77665d2d9e2a8b662ea028908d8f1b9a577609ff]
#    to [675b207fe3f5d89a8ce746cb750a7f49e4d0e2d2]
# 
# patch "checks/common.h"
#  from [f38b5093c55d73fb0f0a13523b6fe523e868e06d]
#    to [bfd4b2a410c9c1fff79d49b19e332fbbe1b1c26c]
# 
# patch "checks/dolook.cpp"
#  from [e014e4765c61b3d33fe0efd7d77ba70f664dbe30]
#    to [04d1a5384a6dff56c210eb0a9f2bd9c5c5274d3e]
# 
# patch "checks/dolook2.cpp"
#  from [37bf56072f24c843ac66295bd79544e283de9737]
#    to [4acd0114fa86ad4762a425ec847b1a7da055bc3e]
# 
# patch "checks/misc.cpp"
#  from [5b4a686ae93a523bbc29314d2d586efd926a3fb2]
#    to [4f4c27808262253e501e8c8a54cae297af72f34c]
# 
# patch "checks/pk.cpp"
#  from [c541d866ce78834d3ac98bc6993dd79622288efe]
#    to [b06ed3fac53639185ef8c93fc8ed2f6252d15ec2]
# 
# patch "checks/pk_bench.cpp"
#  from [ef6c4d7fb50c3e1f9e48fde2d793b0aff37eb76e]
#    to [5a0d834374305d0fb3ea0c934f012d69097dda90]
# 
# patch "checks/pk_valid.dat"
#  from [d9ffd4c599088a120eb095cdb0a0a1222ffb47f8]
#    to [cf31bbd8598d7c0bd0eca450a80403d07fd9dacd]
# 
# patch "checks/validate.cpp"
#  from [c8f8cd4ed6867ae6fd8bbe7c8af0f5c04f847664]
#    to [c89a9eccea28a5e9e0a6623051344d1adb82d85e]
# 
# patch "checks/validate.dat"
#  from [a6793c15f2ca6d78b6f4e52b6b25746678773190]
#    to [1fdb5360f945b438b4b04beecda2df4a49aee40b]
# 
# patch "checks/x509.cpp"
#  from [afef80cdf42af5416cf83a64023d10451314c8f9]
#    to [d388b50234616164f3bf4db3647f377d736f3437]
# 
# patch "doc/license.txt"
#  from [902feeccfae30f0eb980e0f50b222cdd2c2df694]
#    to [fb89e0d65f5f53a62910a4ed7d0422d6a868a12e]
# 
# patch "include/adler32.h"
#  from [035da7f16ef799ccbfc2d01e2628ecad25c815f8]
#    to [540ca183d1300ff6e78074124f84ca7fce58a4ee]
# 
# patch "include/aes.h"
#  from [7d6c1cb25b5ff83e2eaf84904242047ea4b4bf4e]
#    to [31a5dc11f1e83567b5f6428be5eb14bd604f69b2]
# 
# patch "include/allocate.h"
#  from [532035d3cdec5a2c8fd3250f87a78fa7f3d77eb4]
#    to [4a68cbaaadf1ef256013c97958af195fd821e08b]
# 
# patch "include/asn1_int.h"
#  from [e019f2b543443ca344094d8f0156b5eea11f2533]
#    to [c6ba65e0f28e1dc78f77191169ce3e66d5259db7]
# 
# patch "include/asn1_obj.h"
#  from [dfbdbae68301d279de67562d713133df1258084c]
#    to [ed5025ca6776410d8bf2f4743d84bcc82abe700a]
# 
# patch "include/base.h"
#  from [022214feafcc2f0dcf38edc423be11e907088448]
#    to [70a9036f274330e92ebcec561e140abf3d0092a7]
# 
# patch "include/basefilt.h"
#  from [7e88a84f573ac07ff44bdbdcf6747e3534d75975]
#    to [ed92137b63c8fbc22fe34fcb85a0ba20de0cc0e0]
# 
# patch "include/ber_dec.h"
#  from [9a3931c832c8e5bb00fa2a493532759637bc0201]
#    to [da5a1952e517851536e63a368da18a496ffa612c]
# 
# patch "include/bigint.h"
#  from [f81e5621041cfc85cafbe2a72f9ce5fb7145ec58]
#    to [4471d0008ca4005efdc2204f4d1f27a707d86021]
# 
# patch "include/blinding.h"
#  from [5ae0964e91119dc16655961306333f7000008883]
#    to [b3435544d6711ff53fecc7173196d48a66101e67]
# 
# patch "include/cbc.h"
#  from [8f29180d6fb4af093a83374d9c6850eeff371530]
#    to [01f6b8c8388096b44cf735111d7c099c41e51b85]
# 
# patch "include/cbc_mac.h"
#  from [772dfc29deef8cfd49e34c95a24498cbde7defa1]
#    to [00d597f42102f2c1c0a4d3ee3ec1b54c86c0861f]
# 
# patch "include/certstor.h"
#  from [98d85d143337d3bceef3f19eab26d7a64ce958b0]
#    to [34ea724cb47deb22c4848e8a965acfbc51c26762]
# 
# patch "include/cmac.h"
#  from [d69d7e37c0dd9feb3106f5f714851579ce2dadfc]
#    to [615e711ad9ed57e2b536b9f4e1e054116e131c89]
# 
# patch "include/config.h"
#  from [38e23953e7b72c4faf77c743cd894fa7c3aea1cf]
#    to [f4880d3d1e2a381eab9437c96cf927081233a59c]
# 
# patch "include/crc24.h"
#  from [4e80c4956c3c9841c19728faf8b4ccec95a650eb]
#    to [a8ae6856393498e9f3bc6c37e0001567072f8f3a]
# 
# patch "include/crc32.h"
#  from [f6b49ba25578e41cbe4a7472d79c1ce21cc1a62f]
#    to [ed1f6a52d6e4b65309a8abcbe6ce3f39748bba9b]
# 
# patch "include/data_snk.h"
#  from [6e50479354754787a7ea8f1c87b4e5d19104d9ce]
#    to [67cff944ab7cd40c13ecc3d217aa521377c3ceef]
# 
# patch "include/data_src.h"
#  from [f12df31357e4bb3075136128d77881e23b9ee025]
#    to [e68fe6aa8b77a32277051aef56801ae1bb569c5b]
# 
# patch "include/def_powm.h"
#  from [db2161b9b4c38ff0d80cbf979ba89526632d76d7]
#    to [f3d275fd20fab639634538ad51d150fe0894cf2c]
# 
# patch "include/der_enc.h"
#  from [2c3f47a1c7d1f360948af20ca6927548dae30090]
#    to [9317062b086fee5abf7a1c3d70e1b52b989a3898]
# 
# patch "include/des.h"
#  from [6b9b0d2c5317640b063920f56dffaca554a9aeaa]
#    to [374aca41ea6478b6ed2eda89fcc650ba6be8dfe1]
# 
# patch "include/dh.h"
#  from [f3dc596fa2092a4d991746a40e631b45dcde830e]
#    to [12dc085eddd7edc38edd94126d2a2000866c2ebb]
# 
# patch "include/dl_algo.h"
#  from [c635a1d4ce27c0bf2d65dfcc29d27925bb18ebe7]
#    to [e243a66cc5c3239fb96dcea986ae2635b7b4ed7c]
# 
# patch "include/dl_group.h"
#  from [5c9bb309357d9ef7c1a2140496bbcdb535216919]
#    to [f8006c45dfe68129f9a939a57058f8c6e9706105]
# 
# patch "include/eax.h"
#  from [8aa3f7f2c01a0ce9f5782cf66461e0c1a72145c3]
#    to [745ac56cb63f8eb1dbe64cf25d66ea8a01b76772]
# 
# patch "include/ecb.h"
#  from [29ab7f13429e9642e9e3dc22569ab6bfb80d38f2]
#    to [b955fe26fb4fd1864c7703da943e0327c58ee1ae]
# 
# patch "include/eme.h"
#  from [b5432503dea9e40ffaf97de602b34ad522c72ecf]
#    to [36443990c78ccf80ec77d878f3d87f92dc4b7f06]
# 
# patch "include/emsa.h"
#  from [89505a710ac004a0451362593dd7fe4706cee834]
#    to [19a8d52cfdaf9aef12959c60ca0c7b5e9110a21e]
# 
# patch "include/eng_def.h"
#  from [c8353e6127f95e3aed4fd3bd1b40e583b0354801]
#    to [a6af42e0c19ce81d3ce0d195f90aad463e34966b]
# 
# patch "include/engine.h"
#  from [20654be095cb727e6e4c850306e286e47fe7699f]
#    to [59828f9968ce7bc2e36c86d0fe98183f8eef365d]
# 
# patch "include/enums.h"
#  from [06237002097d2faaca50f83ab28eb7ec1e8b5f9d]
#    to [945aeb2a149756db2b6b1ce665becda8ca8c7128]
# 
# patch "include/exceptn.h"
#  from [120505f40281475a5872fa41329b1e82f5adf194]
#    to [4113be2be4823d8c836632896635c5d97deebd7f]
# 
# patch "include/filter.h"
#  from [2050b7b09aa807090598434d8ac5ebb83fbf2503]
#    to [ce7a80041648cf405604930703136a67584316f4]
# 
# patch "include/filters.h"
#  from [bb51ce701097541948779da3f3bbe96651dcf24c]
#    to [d532a5323ceaca0314e6af1a883a918de9c781e8]
# 
# patch "include/hmac.h"
#  from [eb82b13624a2365487c9651fd45f9619abdc5f5c]
#    to [cb6137c68c3b33ef6916131f9e16caa91d07efcf]
# 
# patch "include/if_algo.h"
#  from [f801b3d836a41b2db02f82a6f7f3c1ca711d5128]
#    to [b07f837317b6be619ccb8c2795f75679a96416ba]
# 
# patch "include/keypair.h"
#  from [5e9ee863a0ee9dbe63cbcb39d5440a09c4f5c828]
#    to [19bbb3dc0ffcb6b4b503de2e5742ec08d2b5b9a7]
# 
# patch "include/libstate.h"
#  from [4dddb269a906154b79debb9588397ac08334ccf6]
#    to [af666823f922b8c336c602be7567ebb0da5ce07c]
# 
# patch "include/look_pk.h"
#  from [1f2ab76b42fca7ccef876265b1f0a8df5610f944]
#    to [92c106b614a48a401d6a5613b3f38f77106a48c4]
# 
# patch "include/lookup.h"
#  from [dd3c4a91f50bebfd4c710a828b007b8303b5536b]
#    to [6c345a7254733e1e2c026a0341007823ccaf32bc]
# 
# patch "include/mem_pool.h"
#  from [5c7868d373529114f14223b4cb7533ffa0b7133e]
#    to [dd3a30876c9faca1296d06d25bf0a582590d9c08]
# 
# patch "include/modebase.h"
#  from [b2233bf5cfbe0d16ec986291f086c5e07838b861]
#    to [c3deb9eabbf9ef04c291ac6b3c1460ba53dab983]
# 
# patch "include/modules.h"
#  from [d5c0714b1d1a263bee2ecb352834c9d243a893ef]
#    to [a0d5b85ee9524510723c55e73e9065e8078b8f54]
# 
# patch "include/mp_asm.h"
#  from [43d835beafc05c9d0e39596ba54e73a53795e5b4]
#    to [693c2056d9f473aa10f20bae5d101ef37263f714]
# 
# patch "include/mp_asmi.h"
#  from [fb52f8210fae3cab3f224a25d9728222b2ce27f4]
#    to [2ce78ddc78614b98cf3387def140d79cd91c6eb7]
# 
# patch "include/mp_core.h"
#  from [a31479cdef207a0cf98352de2a6813ddcdb909b2]
#    to [db72ee72f31d2274c5e18ca58a1bd15c59fcbdb1]
# 
# patch "include/mp_types.h"
#  from [064801a43de15a3fb4af0a26b9c4bd14fcd9b8f5]
#    to [fcba1ca3c7294755de6817e3669f9bf6788e7087]
# 
# patch "include/mutex.h"
#  from [566d2d816963e3e255e0cd7ef9e58f4619cad8f8]
#    to [8eef961983ec3d176af85c7eff413bccae0b16b2]
# 
# patch "include/oids.h"
#  from [ca7fe98e914a8def168afa1d9e29ef594245f031]
#    to [0b1192539d57a116d1ced8c6381f6f34da943c70]
# 
# patch "include/out_buf.h"
#  from [cfe4dc7beb6cb4816788ad929eef3be9f22ff420]
#    to [62e689b04f6a475d6e5e025e88a67c23ad873435]
# 
# patch "include/par_hash.h"
#  from [4add8710423444c47404c57c8b234fc7dc6fb22d]
#    to [773ada35d8115d1c20778de70da18e2d9ff338e1]
# 
# patch "include/pbe.h"
#  from [6f41f1c709485124f6dda4dc2ac05d9218577d47]
#    to [dbb1c47581e5a580afd5bf6dde504976cf76dbfe]
# 
# patch "include/pbe_pkcs.h"
#  from [dedf1488ad73ea2bd8bcfeb286f01e01f0dfb4c7]
#    to [efa66e6cf31f004566cfdc8bdb7cce200537fc88]
# 
# patch "include/pem.h"
#  from [8f1ebb1cad4f86b291912481e8fdb5277f9ef1e0]
#    to [d06972fca7b38bf93799badb074d183e17701a27]
# 
# patch "include/pipe.h"
#  from [d7528617243b81a9c2a0eb4b91f63c7b07db15aa]
#    to [575316d4d1a3ec9eefeacd528507488defa76060]
# 
# patch "include/pk_algs.h"
#  from [0cdb3f27d4178871d62f3ffd6eb4cf749b449c8b]
#    to [34700f51f1a5af6c629e6d7fde12725502ec3788]
# 
# patch "include/pk_core.h"
#  from [b6bc6c56bc5f235e84e7f797ae1b38677cc5cda5]
#    to [b7d76148b1bc6c1362f62c95f95478f01f695be4]
# 
# patch "include/pk_filts.h"
#  from [717d97bf42adf752cac13930ae6cbe484da5a60a]
#    to [d6bd7fac866e0ac5c4d25069b7f617f89eb0c62b]
# 
# patch "include/pk_keys.h"
#  from [c5aee8b20fb5f7fbea75385e030e575c596802d6]
#    to [59c61dafb10d355ec5bc4a4c02d53bee13081796]
# 
# patch "include/pk_ops.h"
#  from [4c7b121d9c89e60bf7a836875b49715c9633da1d]
#    to [6103c639d87aefb0c5f31c933310c9693ff51d73]
# 
# patch "include/pkcs10.h"
#  from [2963efb4b97a36cdcd1bb51941ab613f9058ceaa]
#    to [29563f84efc224cdd95bfa8deaa676b242bef982]
# 
# patch "include/pkcs5.h"
#  from [d383915babdee2ef270bba89440302a6abc522ec]
#    to [2333497cae8b1103974428a2419cb8bf9ec74dfc]
# 
# patch "include/pkcs8.h"
#  from [71d4caac3daf75e32dc5c1c44007c2a49ea12dcf]
#    to [29c49743b4cd70009025166972d7641521fb8bcc]
# 
# patch "include/pow_mod.h"
#  from [7ebb967845c2f1b069ca3d0b5c21c5349f2d55e7]
#    to [8c74c6027e255f01bfca0414d1157dcdf0913732]
# 
# patch "include/pubkey.h"
#  from [b281c65bae28486d8ef43e7815e55f1d21553b6f]
#    to [686d7bea981edb78689363459e0b35239216d750]
# 
# patch "include/randpool.h"
#  from [282ae46ef6ee4355e39982da535d2de946516f9a]
#    to [e1d010322c983011b00f02dd5e7fc6a64c0d5401]
# 
# patch "include/reducer.h"
#  from [531a57bee43fa9c80f2d6f83bb0552b79ca2b548]
#    to [9e158a5c35a7e7b3029cbf353d171e0e9e1387d8]
# 
# patch "include/rmd160.h"
#  from [1871f602862a83334df6aac4f63f16e52114d588]
#    to [3a77c6d536862ac064a1962cf6b0b2a9eaf55686]
# 
# patch "include/rng.h"
#  from [ba9ce2605044c82d04e629ca741eda683dc4d819]
#    to [8fd585ea7ddd2f2e0dd34cd27bdf6f972ab214a1]
# 
# patch "include/rsa.h"
#  from [bc6b4bf21a81862bc679e9c6c8c81f8523c50ca9]
#    to [83bce4086eeceaa3ca89148544ffa0c455469276]
# 
# patch "include/s2k.h"
#  from [109b40a203006c1b76f6a6c3d4caff17cdd0fac1]
#    to [4de65fff7413865a269f5d698566555fdfe43d7a]
# 
# patch "include/secmem.h"
#  from [6c5143161c26e2aa0c8585a7b0740cefc483cd59]
#    to [7fb526768a06969b62b75825e62680a40b8d810e]
# 
# patch "include/secqueue.h"
#  from [a2c102173a749d25cf550df38ee83e88043e32f0]
#    to [7e47a59d0fe4fce014b8d5bc69be5d5d79e95cc8]
# 
# patch "include/seed.h"
#  from [7125d58aaf0fa6d1d3f36c2acf219c25c7c9db0f]
#    to [f256c50054abef3aaabb8dff73627622ee76cb49]
# 
# patch "include/sha160.h"
#  from [4b02347f5d3093d6f9dffa6301eba8b9c1482b03]
#    to [a0e51e3c456b806195e5338dd1f7eedf9c9d2166]
# 
# patch "include/sha256.h"
#  from [cd9c6dd936f6352367057c5795848d46bbf248f1]
#    to [2e579da8c2b51a375a630ee3f0db17fb0d6e4dab]
# 
# patch "include/sha_64.h"
#  from [25b8f08f7ea8834469c21cfaa0dd543470af0d9a]
#    to [9225fc7b3cfbf5d16fd3f4159cf201e18bba4820]
# 
# patch "include/util.h"
#  from [bff70e5c51cb75f6fcfb1335e1c5ad38c55ca924]
#    to [9d06296663f0eeab01d1d21290174c9b6e821dd7]
# 
# patch "include/x509_ca.h"
#  from [1e8a2dd2335b23e952715f5dbf4b1b792138dbd7]
#    to [a29fde1a641fdff5977b494a8bf131637002786a]
# 
# patch "include/x509_crl.h"
#  from [d583fee89c7e7db9f822e212248fd451ad51f69d]
#    to [2da53de764abb198e1280c6e3efd79f106dd5f10]
# 
# patch "include/x509_ext.h"
#  from [6bde07d391500117c5bf7f17f72aecab7386e1f4]
#    to [5dd88c985672cf7942f67afe5261054034c5b7df]
# 
# patch "include/x509_key.h"
#  from [114ed2e6923140353e6678260cec13c71cb4a2fd]
#    to [1c5f39e4fd97381d72c7eb83cbf33bc7d5c8a7c5]
# 
# patch "include/x509_obj.h"
#  from [e49bcc7c9c7d559e0f746b0c2533fe635309ac54]
#    to [ddadcb6f1a0068d70711c31175846af6aee208f6]
# 
# patch "include/x509cert.h"
#  from [361b75d7368d02b0de174bc2ec5a9884b27954af]
#    to [653ebe9c62ed4097f172edb9e2427758f498a801]
# 
# patch "include/x509self.h"
#  from [9aac88cb666ace50f762e4371408402e4618b33f]
#    to [71df28c15491825cbdf720b1d594cfe3eeef102c]
# 
# patch "include/x509stat.h"
#  from [1d90a638aa2acaeccfa96676c1019623ebec20ae]
#    to [86f966a7474aa11e0baaa1b4a12a075bd7a2b45d]
# 
# patch "include/x509stor.h"
#  from [0c872441411cdd08c7665196990b748eb6eb2710]
#    to [3a158612c808a37614d822ff9079ccb4652a8e24]
# 
# patch "include/x919_mac.h"
#  from [42f8a906807c9dfffa52bf48e9f3e824bf77286b]
#    to [faa901b7c96a888a56e2f7c09e3527e54a2eb2aa]
# 
# patch "include/x931_rng.h"
#  from [2dedc53610c7b07e26bfa9b314c7e56b1db402f9]
#    to [253f05c06514cd64cd1dc21d5312622a5074ebdf]
# 
# patch "misc/config/arch/amd64"
#  from [0bf63f53099d9804fc351f00c0a60c53199c8b28]
#    to [e99af0aae34e6c83886d5386e79380471b977fe9]
# 
# patch "misc/config/arch/ia32"
#  from [2cea203db7576d32a3134dc45035afde3a9a800b]
#    to [5c1f1b7c540593929009f455a0b2b322cda9c448]
# 
# patch "misc/config/arch/sparc32"
#  from [39f7a595d67765bacc938ca37a31a961f83804f6]
#    to [2507cb5d028e15ad2e71f4fb95a16249c1945bab]
# 
# patch "misc/python/src/block.cpp"
#  from [b298add9b49710e8d6af9df4982a884203204161]
#    to [140867b7786eb4c7491d868c08b85e94d4aa44cf]
# 
# patch "misc/python/src/hash.cpp"
#  from [a68f2ccf4f9e8632f7633a4218b9f6055061855b]
#    to [3281b86000a35d8672051cf2277cd15ceb0a8683]
# 
# patch "misc/python/src/macs.cpp"
#  from [192ac72ac1f7d6ac12360c89f7a0c3df8606d23e]
#    to [bc1f6ca94de7cfb456ee29801ba591cf46b8bff0]
# 
# patch "misc/python/src/stream.cpp"
#  from [a4d0da989701f86885876b839054f158f538a7e9]
#    to [27c086313b5f8b0100dd5e4c0944858823e0f282]
# 
# patch "misc/python/src/x509.cpp"
#  from [01ee39cbd1a13523fbe87f7076915493d5ba59f7]
#    to [0f80045bb7e8c0d33c7ca311221a69e0777a4555]
# 
# patch "modules/alg_amd64/sha160.cpp"
#  from [929af7129275293ff09089a5c13ecfa8927eec0e]
#    to [cf1bc082fc82714258ef1cef7f45c06fafaba48c]
# 
# patch "modules/alg_ia32/sha160.cpp"
#  from [9b4ec6eca3c9909f97700f85d9d66b39d66d3373]
#    to [b03c29b21d93122c0d6282068b0e2e8dcede56dc]
# 
# patch "modules/alloc_mmap/mmap_mem.cpp"
#  from [19ff049ea80042cf62e1f02ede47004f3acf048a]
#    to [6c227f711e8dc90cc80e470a926946bf26e86e3a]
# 
# patch "modules/es_egd/es_egd.cpp"
#  from [39d2684aac4c7a382253daf8e50b1c00d797d437]
#    to [eba7755597844e248a425db09649cc2ac1bebadb]
# 
# patch "modules/es_ftw/es_ftw.cpp"
#  from [6b9dc7cec896eed27ff456d7a2e4df9947eae598]
#    to [ca1c9a63f3264fd17809a8a2e029b069e32c53ca]
# 
# patch "modules/es_unix/unix_cmd.cpp"
#  from [e749e0619b750a2faf429dcd44fc030f344fd280]
#    to [03940ed1eaa9e3e9954e434ba0b7fdc015a65f2d]
# 
# patch "modules/es_unix/unix_cmd.h"
#  from [11b6da666e000229de3db2dee4b54061be9259a9]
#    to [5d9a4f713677f216d615076a72f637f130f8c43c]
# 
# patch "modules/es_win32/es_win32.cpp"
#  from [e8926bb59147dcd331a5c940cac2123326d665e0]
#    to [6ce81dcc3f6e138231aeb97c6d3d9702d62dd922]
# 
# patch "modules/mux_pthr/mux_pthr.cpp"
#  from [1b71d8f314a2e4019a17e8ec0512e9bc33d74042]
#    to [35f7c1f07340ae23bc695e31eb26bc729682b197]
# 
# patch "modules/mux_pthr/mux_pthr.h"
#  from [3cba14c238dd6906b6f2ad7313f1acb020a8e2a1]
#    to [c8bee4a5d5a6ef5b2bd968476c7b6f019e0edca5]
# 
# patch "modules/mux_qt/mux_qt.cpp"
#  from [4348db9135214fb67f32c090b365bce6bc57fca7]
#    to [b893e4e5af9bca1f44bd017ff6294b773615635a]
# 
# patch "modules/mux_qt/mux_qt.h"
#  from [761e85cec7751826125aa7a8fe92585ffdfc24a6]
#    to [00a1c714fae50c7f72075a63c00db1cf105c7b50]
# 
# patch "modules/mux_win32/mux_win32.cpp"
#  from [19a4300b712529f55d9d07436c2a849f19694099]
#    to [3b214275abed4e8423354959053a60c2061b7def]
# 
# patch "modules/mux_win32/mux_win32.h"
#  from [d606c2bf9333915986ea27af96e37d3ae4dbcc0d]
#    to [c1b4c4a4f76a8a0661310ce3f4b3a72a08590884]
# 
# patch "src/asn1_int.cpp"
#  from [f2c2e23eaf6d2fa711a14e0b9d06933d90885501]
#    to [7a7e3926bce89863046a9a8cc7504b6f3ba021be]
# 
# patch "src/asn1_str.cpp"
#  from [1a3b46df6c07368ff753748688d171d3f7f16551]
#    to [14608621192719015bdebcf35123ef7ee9e5da67]
# 
# patch "src/base.cpp"
#  from [42d599ac6a7769d1ea6cae06c345e8ecb9e2bbcf]
#    to [2b0008aec79b685d30e34d1e1b05aab5c5d43f44]
# 
# patch "src/base64.cpp"
#  from [051a2bfee04baa078b6ac9f25e6f955be2a5ebdb]
#    to [56c846ca7c74423da0ae38c8d7cb050b15ecfe5a]
# 
# patch "src/basefilt.cpp"
#  from [0bf28cb04325d403ef59e7189e7972b489900a6f]
#    to [510f0f5db11730105039b15edb712ece8f8c167d]
# 
# patch "src/ber_dec.cpp"
#  from [d22b06ac717befb508e9dbe7d34bcf5681280287]
#    to [e9d77f9f03f36ab9d8e460a6607c0896c703663d]
# 
# patch "src/blinding.cpp"
#  from [53fd0d7c91414698f91d3a69220267f839eef5bd]
#    to [1d0f7a1d157ed60866f3a37f7b2404941594650b]
# 
# patch "src/cbc_mac.cpp"
#  from [b3c8242798b008bb0b0d81ea3b0d7d10e906b5b8]
#    to [da331f82d53c408d343d42cd323c91af6370fb89]
# 
# patch "src/charset.cpp"
#  from [9b04fadf0a683fbf0bcf033846b3848f1cb599d6]
#    to [41c442ec7db4e9abb1963fa0dee2cad473113816]
# 
# patch "src/cmac.cpp"
#  from [a04835d6edf3c504406b4eb69f8bdf6eb645e4db]
#    to [8b0f605f3815739dbcc94dc6fb43e23e05f2b871]
# 
# patch "src/config.cpp"
#  from [cb5e6f5108247da86e71cfbb2e553cfc755d4c9a]
#    to [9342ebe7c22d118b6d3d0e27891245a39d2e99fc]
# 
# patch "src/crl_ent.cpp"
#  from [5bea084ef556530cb38d3de655db2983ff08f5ca]
#    to [a68a0947e32c35de546ab60d922783bf64f501d1]
# 
# patch "src/data_snk.cpp"
#  from [fae39562bf0033d40f6bf9d9959228adab62a8b2]
#    to [b59a17aac01bdc4dc22fe1d2b009796b10552a6d]
# 
# patch "src/data_src.cpp"
#  from [0b0c1e5793da7b053571a78da4ee951013211190]
#    to [c4797b3dee36f435c652d5552eeb790f990a1539]
# 
# patch "src/datastor.cpp"
#  from [301a7be0303d65b1589216c1f2bcb072ac17e34b]
#    to [988c2c0075b907ef51eeef0e8f0e6d09b496d878]
# 
# patch "src/def_alg.cpp"
#  from [1d57382fe9d2db420dc1550a8c1afbd116bdfe6e]
#    to [7708b0c2b28d1120b3646952c4c6018ff8cd0100]
# 
# patch "src/def_char.cpp"
#  from [9d0a75ae7178a2423bb4e1a0f11473f8231b8cc4]
#    to [249adf0e4a263802168689ab03c731058a4dcd85]
# 
# patch "src/def_mode.cpp"
#  from [691cb0c3bff70d8d74df99cdde4c9e155687bc3e]
#    to [20075ee611f4e270ec4dd678134cf7998258c20b]
# 
# patch "src/def_ops.cpp"
#  from [5c9ed9b4ab2a62b38445ba340f5920b6dd8ba5e1]
#    to [92370dab81f21c305be2620f2b6c067813f39d0f]
# 
# patch "src/def_powm.cpp"
#  from [ca58e34d3b5679bc60ced7813df3a350ca3f577f]
#    to [5c88ab1b0a5b5947b67880826cbcf0182b21bdf9]
# 
# patch "src/defalloc.cpp"
#  from [940db8ef03ae170341d257f9f7e4320ee3938935]
#    to [013168053edc9c815d058eb4e5dfe95bcc2d1f02]
# 
# patch "src/der_enc.cpp"
#  from [431f71f58e378c7de52d0f540e5271fe705f5e65]
#    to [755cc7fe13aaecd1bc07c5c39db49713ef0e12ae]
# 
# patch "src/des.cpp"
#  from [b4b952183124098874fc21851366dfec58fdd8de]
#    to [8bce086afe9166bda6cda643a55e1f8eb5237141]
# 
# patch "src/des_tab.cpp"
#  from [46b05668500c5e0d8f22409c0aa9800f1bbbd3d7]
#    to [52ebd23f08f7a059e0df41ce21b3c88e1f1e2f76]
# 
# patch "src/dh.cpp"
#  from [d751f576b0d623a8842e974b7222a69609a31de2]
#    to [490710a5579a5ae6e3c7c80e4274b6893e6e82fe]
# 
# patch "src/dl_algo.cpp"
#  from [625deb904170bae96d19fadc0d6ac5f4cc677d9d]
#    to [1944d7f0fb134fd0c2038780be348a1b522aeba3]
# 
# patch "src/dl_group.cpp"
#  from [6a5022b0c81f660c85b912ad3e0a6ebd78c4ae85]
#    to [a0c470d7c1397c5ead79bb7131aab370db9d12e9]
# 
# patch "src/dsa_gen.cpp"
#  from [71213b478a52c337f6aad69d3942bdcb51193e3e]
#    to [36fb316cb63d9d040ed49fc48c571a60766546ed]
# 
# patch "src/eax.cpp"
#  from [f1e9e17e046aa6de0450fc4773faeb73d8f2b7e1]
#    to [eea50d9831b6fb348023d2b1ead8f2a01731d33a]
# 
# patch "src/eme1.cpp"
#  from [118aad6ac2eb56ece214d5e209e761a436ef4e3a]
#    to [e3839889917163b2673934812751456e15c10122]
# 
# patch "src/emsa1.cpp"
#  from [92d9d12b72d3fee612f979a9efe36f9da3af4996]
#    to [e6921eebd8d648a6edde313b2dbe8dec448f3b85]
# 
# patch "src/emsa2.cpp"
#  from [3031d2c440ea6f65983216ab222d4ff8da32099d]
#    to [76a78f2e29188862a6125d9e018e5b8b054a7341]
# 
# patch "src/emsa3.cpp"
#  from [31c1d39fbda1461462f686095b027fbc5662e1e8]
#    to [d829c8ee3ed6cf059680d9d846a027e6dcdf1b05]
# 
# patch "src/emsa4.cpp"
#  from [91e564eed0e820f8bc5e5dfd05c947f76eec4771]
#    to [49bad9efcd4affb70a4285c6c4e059aff688d87b]
# 
# patch "src/eng_base.cpp"
#  from [0593563d982aaac2c01024c1dd6e29b1494843d7]
#    to [3ee738f8de0d01fde7ceac457439b323d010a14f]
# 
# patch "src/engine.cpp"
#  from [bf3c1acdcb480eb07013cebc9f03417730b1e01f]
#    to [835ab3db17379899cd83c048ef5350a2b11793ad]
# 
# patch "src/filter.cpp"
#  from [bc1fe725d4b6869d279e64f7649988a8b6d8f51f]
#    to [1eafd8bf373abae81ff1b7645205c70750d3bce0]
# 
# patch "src/filters.cpp"
#  from [698d1b8987f6963d2ba5c03bc95bf79047a94fa2]
#    to [540b964979407ed9070655cd15c53148d41a52e6]
# 
# patch "src/fips140.cpp"
#  from [df549a1ac6d511cb6f5a9d9a801bfed4529569cb]
#    to [b544fbb24aced09e36fe0f7637b5b22e318f6a9e]
# 
# patch "src/get_algo.cpp"
#  from [656661d877017c4dbf1a80eb5e23a558fe463ff5]
#    to [e20a98a41a2ee0c3d87725e9fb8e99b96ed1298a]
# 
# patch "src/get_enc.cpp"
#  from [18eeecb14af5921471c02ec78ac491badc74108b]
#    to [2ca2fda0155a6cb127b556198dcde24ee911ef20]
# 
# patch "src/get_pbe.cpp"
#  from [6bb990b1f38d8ef62c0a6055dcfb8f8eb2142386]
#    to [555659c95937ff012c1d1dad17db4370c116890d]
# 
# patch "src/hash_id.cpp"
#  from [ff3e7496e25d811a0f001aa900aef51e1b96e9a1]
#    to [818350268f3f9a80a85822bdde7558eee15e565b]
# 
# patch "src/hmac.cpp"
#  from [c98153b4f8b5c4a3b2fafc05bb69a0c2aa43067f]
#    to [a3e2997bc78f68b5c92a1fbe5242cd9010e7ddce]
# 
# patch "src/if_algo.cpp"
#  from [d887e1ee1beae026a0cb02c893c882f3d464d4e9]
#    to [1b3c8c0a0ddaf5f24c28ded27ec2c34b39eec88d]
# 
# patch "src/init_def.cpp"
#  from [032c0a1f7bd132c86506da3f4756a1f39a49e6aa]
#    to [a6a95d8b8ffb07b8e065c55d73332860b54d85ca]
# 
# patch "src/jacobi.cpp"
#  from [699fd1d1712c1e22fbb3cc94cb919b709b49b7de]
#    to [10db9f92a1b27fe83908560d7ec3978456d8915b]
# 
# patch "src/kdf.cpp"
#  from [5a8a42038d9d402727e6ca1b11d0244954137a32]
#    to [2d719e6ee038079311947f5681eeb9b32127901e]
# 
# patch "src/keypair.cpp"
#  from [3b736d5aae521292b8e479ebe3b9b703d4265a99]
#    to [05e7cd17e7c014a1a98b0f3db69f3820b8176819]
# 
# patch "src/libstate.cpp"
#  from [233c9231a05eae79ae231f8136850b43c34914d3]
#    to [5808d3bac1d5f9974d933b4a7c46f7db17f1fb59]
# 
# patch "src/look_pk.cpp"
#  from [80288c7dbe76f809b37a6e2189b32d45a2eab344]
#    to [13a90c93d5ce74a7f50e9291fbb21ccedf11e145]
# 
# patch "src/make_prm.cpp"
#  from [d665482d002305b15dd878616f4c78fdb76cf76a]
#    to [f8173bbeed5315fc5b12e0fb891538e1af3051d9]
# 
# patch "src/mdx_hash.cpp"
#  from [7e90baec5a8465c7405841bc2d1075fde1165797]
#    to [631dfce3ecb73075326869abd960ae1f0b0a3a3e]
# 
# patch "src/mem_pool.cpp"
#  from [399aa8cd9dac6bce28a803b11a262d5e6d1b3fcb]
#    to [c2dc35b5090c6b768beb28e2926e174e5045dbd2]
# 
# patch "src/mgf1.cpp"
#  from [833bdd2150cc0db702b39bc4d799426504dda7d5]
#    to [a140509006083243a96ab87ffa6d8030a221bf80]
# 
# patch "src/modebase.cpp"
#  from [1c98d29fa318a766f53c87ded0f18c6b80fbcbb1]
#    to [b575a37a58098e7be2c38db89cf0d56680ee535d]
# 
# patch "src/modules.cpp"
#  from [310f410a77f14f2b559a24a0a00821880205b6c8]
#    to [452f861c9ad2622ad188781c1df79ce012692750]
# 
# patch "src/mp_asm.cpp"
#  from [84dd140ff3a56889afd6b026b0ee40e40120cd83]
#    to [2100e46f84bba81c9b9e873476bb5152630c9143]
# 
# patch "src/mp_comba.cpp"
#  from [b6e3cf9668bfeebad0695e1062409cc358ce39d6]
#    to [574771dbfaceaa4f5fc3974838cd7a2346c6d152]
# 
# patch "src/mp_misc.cpp"
#  from [1602f6ca6969f4c503be6f203b5442b2ae0c1c0a]
#    to [29ffd85a5fb1b50be8f3935a142f1f121f80ddc7]
# 
# patch "src/mp_mul.cpp"
#  from [dafb1262e69f06c17fe781aea9c7ed04ef789829]
#    to [16e2ea8b58df94ff3036038668a50bf3c1e86fdb]
# 
# patch "src/mp_mulop.cpp"
#  from [cfaafb643d3d5960509ca07f8370a044c291730d]
#    to [b1e4523a8dfac1d513acf5650d6a6066c09b8df9]
# 
# patch "src/mp_numth.cpp"
#  from [1f30af2cd34fe5b7692e984bc9f32e8fecb8fc40]
#    to [1f77a6614f0bb588b238ed06dcf36a406ce6272d]
# 
# patch "src/mp_shift.cpp"
#  from [91e212e741dcd78df0619afad5539f779f4684c3]
#    to [2a1e25e81d0dbfb9020964834bdcc9207a01a758]
# 
# patch "src/mp_sqr.cpp"
#  from [de1f9715b8b1420092525f08c1f37428734fce19]
#    to [ca128254cff4e7b6ef467cbad8979d51d94dc0ed]
# 
# patch "src/mutex.cpp"
#  from [3e01e31f664f2e669206c92788212288a29ed1e9]
#    to [4d7fb694836ade2963f4d6e9c79709d7a0a84e5d]
# 
# patch "src/oids.cpp"
#  from [469aad470e7ec8f275bee3ad392a675828b40aeb]
#    to [bf5f569d7fe80b0494bbef4d49f4c2d1959bb4de]
# 
# patch "src/out_buf.cpp"
#  from [c5071a9eb97054a9bb82f5f9ebe48ac01c380a3c]
#    to [23c44c7e44f5d2d17f03fea569c494a0f51851dc]
# 
# patch "src/par_hash.cpp"
#  from [5a4195295bd429573b4f93dbf0dc62c4eb7f810d]
#    to [b9972eb378866f0f325d5dc1469b11c9b3260aaa]
# 
# patch "src/pbes1.cpp"
#  from [3285313a3d998f049c48d73817a98b548d2c4990]
#    to [9be895fad03767a75857f56c3de14dd44f78e544]
# 
# patch "src/pbes2.cpp"
#  from [b30dfcb03d8bd7642027a2ae878c95087ac8a572]
#    to [a29bb46832a9de2d7fa03d636c04fe5f70ec164d]
# 
# patch "src/pem.cpp"
#  from [502e34643de00820f3dbd8da75c65dd6b62ad056]
#    to [dc481f6560c2c37a51d85e7ff5e73dc25a7e95cd]
# 
# patch "src/pipe.cpp"
#  from [945e1ff54a457469193ea353a6a51ae7888a167e]
#    to [d5b488649d847568434b18a9edb1e1e78e8ad01f]
# 
# patch "src/pipe_io.cpp"
#  from [0ac139738c9b5f02e1efc95f746b170922297e7a]
#    to [0be76612df3854bf235daca77962b8dd9ca670bf]
# 
# patch "src/pk_algs.cpp"
#  from [ffddb4b9ede9d795bbf8aebe0b01b0871fb8dc97]
#    to [b1c82f967c7553c7ba7cadebb76e2564f9098e6a]
# 
# patch "src/pk_core.cpp"
#  from [e451087382e2c3ab0d8f3624f07891afe1fb22aa]
#    to [b0e02b33b90acc039c36b0cec0bb73404686db55]
# 
# patch "src/pk_filts.cpp"
#  from [4007d826375c8f84ddf27f83b857c16f619a288c]
#    to [212c704b8116ff92d230ca282df9027663724df8]
# 
# patch "src/pk_keys.cpp"
#  from [5b7fa873a16d72e3a111cb658a8d33a47bebb05b]
#    to [b2bb937f506ec78b57e3df0350c48b5bebc906c8]
# 
# patch "src/pkcs10.cpp"
#  from [9c89f3e653afd0c819a468514a81de9fd2c23079]
#    to [a0f74f7fda726c421b371dacdf26b98ff54c0946]
# 
# patch "src/pkcs5.cpp"
#  from [74572fee997b93c59ca6e747e0d7f14b1ca47a46]
#    to [31e3530688cf7e9036de47581536962c7c545749]
# 
# patch "src/pkcs8.cpp"
#  from [733a303d5cbf22ad09fcb583943de7120358add9]
#    to [c62cd9e5cf984b6c4c0a8f520948978c0ffc1e25]
# 
# patch "src/policy.cpp"
#  from [979a989d26dd9cbc7a01e489136831c7c8ea5bc2]
#    to [5abd1fbeff636a90a3de4182f65829847e70504d]
# 
# patch "src/pow_mod.cpp"
#  from [eb6a2654eecdc0e847a132641d5e007ceb96824d]
#    to [74b2d97070499acc08ec50dc02f4bc6a01be6ccc]
# 
# patch "src/powm_fw.cpp"
#  from [381e10f37c1800677e2845cbe31c466b38f88e10]
#    to [9e83834c96b1662d8cfef54c60e9c58c69cbe10c]
# 
# patch "src/powm_mnt.cpp"
#  from [7887c90cb82ffe8f47213fc80d5c7594f00bb92f]
#    to [4888a36fab34a209d3d1a60f7388e0f75d830a6c]
# 
# patch "src/prf_x942.cpp"
#  from [94d6c065c580325db247150d2bce204a1b3e51ee]
#    to [6fac9a2eb6b63c758e8b4a3036e23d99467c4c25]
# 
# patch "src/primes.cpp"
#  from [bffba287204ae947085252210387c20a363c93ed]
#    to [6eb50692ea9efe356fac5f0411acdb44690a3ffd]
# 
# patch "src/pubkey.cpp"
#  from [413323d6652270bf268b614a10443c86987fddb9]
#    to [302b762007d223d44807221e2da4a9f1e106ec17]
# 
# patch "src/randpool.cpp"
#  from [dcfe978754894d39838888a39221519c5ca9b260]
#    to [f02567c5b14dd4ce84eb13b9bceb3ebe1fba8049]
# 
# patch "src/reducer.cpp"
#  from [cbb17f184cc998fba5ca47c08ae25423826c7bf3]
#    to [2191963da851e181fc83bf56feda6b6c004267c9]
# 
# patch "src/rmd160.cpp"
#  from [0cb48c93b63cf3ed0d359101f457b8a07b8726be]
#    to [70377f0c3d36873d2a33567f2e2f6859917b59f3]
# 
# patch "src/rng.cpp"
#  from [60471c38882ca41d868d3893765d6ea6553db036]
#    to [83846d1392e9985382ea197c3d51d9fd98e696e7]
# 
# patch "src/rsa.cpp"
#  from [3712299fa9bc70a4b7c1631abf5667efc631eda3]
#    to [04938f731520d4a435a61b22febbd0e496f29790]
# 
# patch "src/secqueue.cpp"
#  from [57e872c273efcf1e5a0b9dc7990eb7d72af2e2d7]
#    to [4364913c742056d05a3e03fa5a9979a66c46e16c]
# 
# patch "src/sha160.cpp"
#  from [7f151f0f0f0f3c5358f422625c85d9fbfbc2520f]
#    to [931e6a49db428fa67edd0d3dfc08fbb3f034eabf]
# 
# patch "src/sha256.cpp"
#  from [c301182d8aaf2804b5c52543987d0bd713acd7e2]
#    to [5f54c3bcb9847ca76f67a312fd3e476752d7b93b]
# 
# patch "src/sha_64.cpp"
#  from [d8bcc62e9199aa8ff55f012ed4106a40b1fd2724]
#    to [c45ced644b3934f10aef4131a266ede67728fe58]
# 
# patch "src/symkey.cpp"
#  from [c1151d35d6ca0800cadd554543ed1f194f51da0e]
#    to [ad9f2caeefa58b010fe3bed413e38a14c8a1fe14]
# 
# patch "src/x509_ca.cpp"
#  from [c490baee785765f71c2de35c8e0596b8b284a07e]
#    to [f7c4292d8c083780af5a5a1c11324ff78a9a3eb1]
# 
# patch "src/x509_crl.cpp"
#  from [8d56ad20f352039dcccff53846813e8cd2600538]
#    to [f7c3486e576ed4d90957c957ab2842f97d9326e9]
# 
# patch "src/x509_ext.cpp"
#  from [11ffbaf80379a237ed47a9ba13091db6e84ce95b]
#    to [4d67f65e478e87fd65d329a0383bf1bd0725f664]
# 
# patch "src/x509_key.cpp"
#  from [7fb550c81b8c4ecf9767626751ded96208305f98]
#    to [edf1009887e6d8616898ada7bd2fa08616569b5c]
# 
# patch "src/x509_obj.cpp"
#  from [f23e2574a233912956eeee348f088438350df3ca]
#    to [32ecae243f8be2d2128d726e8c29e6b4a2be4176]
# 
# patch "src/x509cert.cpp"
#  from [d5de5f096e8a47ab498b0b0d90042775c3a1c0fa]
#    to [cbf4e1b889419e85f1c68a0ceb5d1d4a30d0936c]
# 
# patch "src/x509self.cpp"
#  from [5f92488b35e43625413b0215aac9d1f46a1d7a99]
#    to [e645cced01e648d6f704e0279b5151b9d6b60f83]
# 
# patch "src/x509stat.cpp"
#  from [ad0ea0d4cc9ef4a1aa9ae278b80ffce29d47f237]
#    to [66ccb6732ccf5f9c51f0aa5f1a9306103ab0c63d]
# 
# patch "src/x509stor.cpp"
#  from [6e4f9030fde21f4d670d1f669ac31868b789365b]
#    to [5737d6fdfcc815d7dc3190c825266bd6a870d61a]
# 
# patch "src/x919_mac.cpp"
#  from [6949a6083678969fa14525a7269d65e1c8f33396]
#    to [d9fe70519f7913290c749d03c0e862dcc055683d]
# 
# patch "src/x931_rng.cpp"
#  from [e75b008bdb53486d98d7aea0dacaa607e55ea0f0]
#    to [761bdc72356775a75efe9bd2eb3192bfd1bacb61]
#
============================================================
--- checks/algos.cpp	99cdd8b6e21dbd9160fe5235e95c5a65e2c69b6b
+++ checks/algos.cpp	939e8b28072c8d1abf27f7d6094a94ac47e0ee2f
@@ -12,13 +12,16 @@ std::vector<algorithm> get_algos()
    algos.push_back(algorithm("Block Cipher", "AES-128", "AES-128/ECB", 16));
    algos.push_back(algorithm("Block Cipher", "AES-192", "AES-192/ECB", 24));
    algos.push_back(algorithm("Block Cipher", "AES-256", "AES-256/ECB", 32));
+	/*
    algos.push_back(algorithm("Block Cipher", "Blowfish", "Blowfish/ECB", 32));
    algos.push_back(algorithm("Block Cipher", "CAST-128", "CAST-128/ECB", 16));
    algos.push_back(algorithm("Block Cipher", "CAST-256", "CAST-256/ECB", 32));
+	*/   
    algos.push_back(algorithm("Block Cipher", "DES", "DES/ECB", 8));
    algos.push_back(algorithm("Block Cipher", "DESX", "DESX/ECB", 24));
    algos.push_back(algorithm("Block Cipher", "TripleDES",
                              "TripleDES/ECB", 24));
+	/*                            
    algos.push_back(algorithm("Block Cipher", "GOST", "GOST/ECB", 32));
    algos.push_back(algorithm("Block Cipher", "IDEA", "IDEA/ECB", 16));
    algos.push_back(algorithm("Block Cipher", "KASUMI", "KASUMI/ECB", 16));
@@ -41,7 +44,7 @@ std::vector<algorithm> get_algos()
    algos.push_back(algorithm("Block Cipher", "TEA", "TEA/ECB", 16));
    algos.push_back(algorithm("Block Cipher", "Twofish", "Twofish/ECB", 32));
    algos.push_back(algorithm("Block Cipher", "XTEA", "XTEA/ECB", 16));
-
+	*/
    algos.push_back(algorithm("Cipher Mode", "AES-128/CBC/PKCS7", 16, 16));
    algos.push_back(algorithm("Cipher Mode", "AES-128/CBC/CTS", 16, 16));
    algos.push_back(algorithm("Cipher Mode", "AES-128/CFB(128)", 16, 16));
@@ -53,7 +56,7 @@ std::vector<algorithm> get_algos()
    algos.push_back(algorithm("Cipher Mode", "AES-128/CTR",
                              "AES-128/CTR-BE", 16, 16));
    algos.push_back(algorithm("Cipher Mode", "AES-128/EAX", 16, 16));
-
+	/*
    algos.push_back(algorithm("Stream Cipher", "ARC4", 16));
    algos.push_back(algorithm("Stream Cipher", "Turing", 32));
    algos.push_back(algorithm("Stream Cipher", "WiderWake4+1",
@@ -69,16 +72,20 @@ std::vector<algorithm> get_algos()
    algos.push_back(algorithm("Hash", "MD4"));
    algos.push_back(algorithm("Hash", "MD5"));
    algos.push_back(algorithm("Hash", "RIPEMD-128"));
+   */
    algos.push_back(algorithm("Hash", "RIPEMD-160"));
    algos.push_back(algorithm("Hash", "SHA-160"));
+   algos.push_back(algorithm("Hash", "SHA-224"));
    algos.push_back(algorithm("Hash", "SHA-256"));
    algos.push_back(algorithm("Hash", "SHA-384"));
    algos.push_back(algorithm("Hash", "SHA-512"));
+   /*
    algos.push_back(algorithm("Hash", "Tiger"));
    algos.push_back(algorithm("Hash", "Whirlpool"));
-
+	*/
    algos.push_back(algorithm("MAC", "CMAC(AES-128)", 16));
    algos.push_back(algorithm("MAC", "HMAC(SHA-1)", 16));
+
    algos.push_back(algorithm("MAC", "X9.19-MAC", 16));
 
    algos.push_back(algorithm("RNG", "Randpool"));
============================================================
--- checks/bench.cpp	380f38c3230ff1cc3599246b0c9152d77994f7a6
+++ checks/bench.cpp	099da45709079bb4bc70a72d7567a36a72eace33
@@ -7,6 +7,7 @@
 
 #include <botan/rng.h>
 #include <botan/filters.h>
+#include <botan/filter.h>
 using namespace Botan_types;
 using Botan::u64bit;
 
@@ -18,14 +19,20 @@ struct BitBucket : public Botan::Filter
    void write(const byte[], u32bit) {}
    };
 
-Botan::Filter* lookup(const std::string&,
+//Botan::Filter* lookup(const std::string&,
+//                      const std::vector<std::string>&,
+//                      const std::string& = "All");
+Botan::Filter::SharedFilterPtr lookup(const std::string&,
                       const std::vector<std::string>&,
                       const std::string& = "All");
 
-double bench_filter(std::string name, Botan::Filter* filter,
+
+//double bench_filter(std::string name, Botan::Filter* filter,
+ //                   bool html, double seconds)
+double bench_filter(std::string name, Botan::Filter::SharedFilterPtr filter,
                     bool html, double seconds)
    {
-   Botan::Pipe pipe(filter, new BitBucket);
+   Botan::Pipe pipe(filter, Botan::create_auto_ptr<BitBucket>());
    pipe.start_msg();
 
    static const u32bit BUFFERSIZE = 32*1024;
@@ -37,15 +44,14 @@ double bench_filter(std::string name, Bo
    u64bit start = get_clock(), clocks_used = 0;
    u64bit go_up_to = (u64bit)(seconds * get_ticks());
 
-   while(clocks_used < go_up_to)
-      {
+   while(clocks_used < go_up_to) {
       iterations++;
       pipe.write(buf, BUFFERSIZE);
       clocks_used = get_clock() - start;
       }
 
    double bytes_per_sec = ((double)iterations * BUFFERSIZE) /
-                          ((double)clocks_used / get_ticks());
+   						  ((double)clocks_used / get_ticks());
    double mbytes_per_sec = bytes_per_sec / (1024.0 * 1024.0);
 
    std::cout.setf(std::ios::fixed, std::ios::floatfield);
@@ -78,7 +84,8 @@ double bench(const std::string& name, co
    params.push_back(std::string(int(2*keylen), 'A'));
    params.push_back(std::string(int(2* ivlen), 'A'));
 
-   Botan::Filter* filter = lookup(filtername, params);
+ //  Botan::Filter* filter = (lookup(filtername, params)).get();
+Botan::Filter::SharedFilterPtr filter = lookup(filtername, params);
 
    if(filter)
       return bench_filter(name, filter, html, seconds);
============================================================
--- checks/bigint.cpp	51aea731b8d78f775d76dfa8eefa899ab31db372
+++ checks/bigint.cpp	0822a8fae52f68509b9ede9334ddeac655a29058
@@ -4,11 +4,12 @@
 #include <iostream>
 #include <cstdlib>
 
-#include <botan/bigint.h>
+#include <botan/math/bigint.h>
 #include <botan/exceptn.h>
-#include <botan/numthry.h>
+#include <botan/math/bigintfuncs.h>
 #include <botan/rng.h>
 using namespace Botan;
+using namespace Botan::math;
 
 #include "common.h"
 
@@ -28,6 +29,7 @@ u32bit do_bigint_tests(const std::string
 
 u32bit do_bigint_tests(const std::string& filename)
    {
+//   return 0;
    std::ifstream test_data(filename.c_str());
 
    if(!test_data)
============================================================
--- checks/block.cpp	f8ca4b45ff803f4d35d5ebf92874749a44beb1a3
+++ checks/block.cpp	01e73abdda8f789cb2724e41ccfda5dcc238aaa0
@@ -25,21 +25,21 @@ class ECB_Encryption_ErrorCheck : public
          {
          const std::string HASH = "SHA-1";
 
-         cipher = get_block_cipher(cipher_name);
-         input_hash = get_hash(HASH);
-         decrypt_hash = get_hash(HASH);
+         cipher = BlockCipher::AutoBlockCipherPtr(get_block_cipher(cipher_name).release());
+         input_hash = HashFunction::AutoHashFunctionPtr(get_hash(HASH).release());
+         decrypt_hash = HashFunction::AutoHashFunctionPtr(get_hash(HASH).release());
          buffer.create(BLOCKSIZE);
          cipher->set_key(key);
          position = 0;
          }
       ~ECB_Encryption_ErrorCheck()
-         { delete cipher; delete input_hash; delete decrypt_hash; }
+         { }
    private:
       const u32bit BLOCKSIZE;
-      BlockCipher* cipher;
+      BlockCipher::AutoBlockCipherPtr cipher;
       SecureVector<byte> buffer;
       u32bit position;
-      HashFunction* input_hash, *decrypt_hash;
+      HashFunction::AutoHashFunctionPtr input_hash, decrypt_hash;
    };
 
 void ECB_Encryption_ErrorCheck::write(const byte input[], u32bit length)
@@ -84,11 +84,11 @@ void ECB_Encryption_ErrorCheck::end_msg(
       throw Exception("ECB: input was not in full blocks");
    }
 
-Filter* lookup_block(const std::string& algname, const std::string& key)
+Filter::AutoFilterPtr lookup_block(const std::string& algname, const std::string& key)
    {
-   Filter* cipher = 0;
+   Filter::AutoFilterPtr cipher;
    try {
-      cipher = new ECB_Encryption_ErrorCheck(algname, "NoPadding", key);
+      cipher = create_auto_ptr<ECB_Encryption_ErrorCheck>(algname, "NoPadding", key);
       }
    catch(Algorithm_Not_Found) {}
 
============================================================
--- checks/check.cpp	77665d2d9e2a8b662ea028908d8f1b9a577609ff
+++ checks/check.cpp	675b207fe3f5d89a8ce746cb750a7f49e4d0e2d2
@@ -12,7 +12,7 @@
 #include <limits>
 
 #include <botan/botan.h>
-#include <botan/mp_types.h>
+#include <botan/math/mp_types.h>
 
 using namespace Botan_types;
 
============================================================
--- checks/common.h	f38b5093c55d73fb0f0a13523b6fe523e868e06d
+++ checks/common.h	bfd4b2a410c9c1fff79d49b19e332fbbe1b1c26c
@@ -22,6 +22,7 @@ void strip_newlines(std::string& line);
 
 void strip_comments(std::string& line);
 void strip_newlines(std::string& line);
+void strip_newlines_windows(std::string& line);
 void strip(std::string& line);
 std::vector<std::string> parse(const std::string& line);
 
============================================================
--- checks/dolook.cpp	e014e4765c61b3d33fe0efd7d77ba70f664dbe30
+++ checks/dolook.cpp	04d1a5384a6dff56c210eb0a9f2bd9c5c5274d3e
@@ -3,7 +3,9 @@
 
 #include <botan/lookup.h>
 #include <botan/filters.h>
-
+#include <botan/engine.h>
+#include <botan/filter.h>
+#include <assert.h>
 #ifdef BOTAN_EXT_COMPRESSOR_BZIP2
 #include <botan/bzip2.h>
 #endif
@@ -18,81 +20,88 @@ using namespace Botan;
 
 using namespace Botan;
 
-Filter* lookup_block(const std::string&, const std::string&);
-Filter* lookup_cipher(const std::string&, const std::string&,
+Filter::AutoFilterPtr lookup_block(const std::string&, const std::string&);
+Filter::SharedFilterPtr lookup_cipher(const std::string&, const std::string&,
                     const std::string&, bool);
-Filter* lookup_hash(const std::string&);
-Filter* lookup_mac(const std::string&, const std::string&);
-Filter* lookup_rng(const std::string&);
-Filter* lookup_encoder(const std::string&);
-Filter* lookup_s2k(const std::string&, const std::vector<std::string>&);
-Filter* lookup_kdf(const std::string&, const std::string&,
+Filter::SharedFilterPtr lookup_hash(const std::string&);
+Filter::SharedFilterPtr lookup_mac(const std::string&, const std::string&);
+Filter::SharedFilterPtr lookup_rng(const std::string&);
+Filter::SharedFilterPtr lookup_encoder(const std::string&);
+//Filter::SharedFilterPtr lookup_s2k(const std::string&, const std::vector<std::string>&);
+Filter::SharedFilterPtr lookup_kdf(const std::string&, const std::string&,
                    const std::string&);
 
-Filter* lookup(const std::string& algname,
+//Filter::SharedFilterPtr lookup(const std::string& algname,
+//               const std::vector<std::string>& params,
+//               const std::string& section)
+               Filter::SharedFilterPtr lookup(const std::string& algname,
                const std::vector<std::string>& params,
                const std::string& section)
+
    {
+   assert(params.size() >= 2);
    std::string key = params[0];
    std::string iv = params[1];
-   Filter* filter = 0;
+   Filter::SharedFilterPtr filter;
 
    // The order of the lookup has to change based on how the names are
    // formatted and parsed.
    filter = lookup_kdf(algname, key, iv);
-   if(filter) return filter;
+   if(filter.get()) return filter;
 
    if(section == "Cipher Modes (Decryption)")
       filter = lookup_cipher(algname, key, iv, false);
    else
       filter = lookup_cipher(algname, key, iv, true);
-   if(filter) return filter;
+   if(filter.get()) return filter;
 
-   filter = lookup_block(algname, key);
-   if(filter) return filter;
+   Filter::AutoFilterPtr autoFilterPtr(lookup_block(algname, key));
+   filter = Filter::SharedFilterPtr(autoFilterPtr);
+   if(filter.get()) return filter;
 
    filter = lookup_rng(algname);
-   if(filter) return filter;
+   if(filter.get()) return filter;
 
    filter = lookup_encoder(algname);
-   if(filter) return filter;
+   if(filter.get()) return filter;
 
    filter = lookup_hash(algname);
-   if(filter) return filter;
+   if(filter.get()) return filter;
 
    filter = lookup_mac(algname, key);
-   if(filter) return filter;
+   if(filter.get()) return filter;
 
+/*
    filter = lookup_s2k(algname, params);
-   if(filter) return filter;
-
-   return 0;
+   if(filter.get()) return filter;
+*/
+   return filter;
    }
 
-Filter* lookup_hash(const std::string& algname)
+Filter::SharedFilterPtr lookup_hash(const std::string& algname)
    {
-   Filter* hash = 0;
+   Filter::SharedFilterPtr hash;
 
    try {
-      hash = new Hash_Filter(algname);
+      hash = create_shared_ptr<Hash_Filter>(algname);
       }
    catch(Algorithm_Not_Found) {}
 
    return hash;
    }
 
-Filter* lookup_mac(const std::string& algname, const std::string& key)
+Filter::SharedFilterPtr lookup_mac(const std::string& algname, const std::string& key)
    {
-   Filter* mac = 0;
+   Filter::SharedFilterPtr mac;
    try {
-      mac = new MAC_Filter(algname, key);
+      mac = create_shared_ptr<MAC_Filter>(algname, key);
       }
    catch(Algorithm_Not_Found) {}
 
    return mac;
    }
 
-Filter* lookup_cipher(const std::string& algname, const std::string& key,
+Filter::SharedFilterPtr lookup_cipher(const std::string& algname, const std::string& key,
                     const std::string& iv, bool encrypt)
    {
    try {
@@ -103,36 +112,36 @@ Filter* lookup_cipher(const std::string&
       }
    catch(Algorithm_Not_Found) {}
    catch(Invalid_Algorithm_Name) {}
-   return 0;
+   return Filter::SharedFilterPtr();
    }
 
-Filter* lookup_encoder(const std::string& algname)
+Filter::SharedFilterPtr lookup_encoder(const std::string& algname)
    {
    if(algname == "Base64_Encode")
-      return new Base64_Encoder;
+      return create_shared_ptr<Base64_Encoder>();
    if(algname == "Base64_Decode")
-      return new Base64_Decoder;
+      return create_shared_ptr<Base64_Decoder>();
 
 #ifdef BOTAN_EXT_COMPRESSOR_BZIP2
    if(algname == "Bzip_Compression")
-      return new Bzip_Compression(9);
+      return create_shared_ptr<Bzip_Compression>(9);
    if(algname == "Bzip_Decompression")
-      return new Bzip_Decompression;
+      return create_shared_ptr<Bzip_Decompression>();
 #endif
 
 #ifdef BOTAN_EXT_COMPRESSOR_GZIP
    if(algname == "Gzip_Compression")
-      return new Gzip_Compression(9);
+      return create_shared_ptr<Gzip_Compression>(9);
    if(algname == "Gzip_Decompression")
-      return new Gzip_Decompression;
+      return create_shared_ptr<Gzip_Decompression>();
 #endif
 
 #ifdef BOTAN_EXT_COMPRESSOR_ZLIB
    if(algname == "Zlib_Compression")
-      return new Zlib_Compression(9);
+      return create_shared_ptr<Zlib_Compression>(9);
    if(algname == "Zlib_Decompression")
-      return new Zlib_Decompression;
+      return create_shared_ptr<Zlib_Decompression>();
 #endif
 
-   return 0;
+   return Filter::SharedFilterPtr();
    }
============================================================
--- checks/dolook2.cpp	37bf56072f24c843ac66295bd79544e283de9737
+++ checks/dolook2.cpp	4acd0114fa86ad4762a425ec847b1a7da055bc3e
@@ -27,34 +27,33 @@ class S2K_Filter : public Filter
          SymmetricKey x = s2k->derive_key(outlen, passphrase);
          send(x.bits_of());
          }
-      S2K_Filter(S2K* algo, const SymmetricKey& s, u32bit o, u32bit i)
+      S2K_Filter(std::tr1::shared_ptr<S2K> algo, const SymmetricKey& s, u32bit o, u32bit i)
          {
          s2k = algo;
          outlen = o;
          iterations = i;
          salt = s.bits_of();
          }
-      ~S2K_Filter() { delete s2k; }
+      ~S2K_Filter() { }
    private:
       std::string passphrase;
-      S2K* s2k;
+      std::tr1::shared_ptr<S2K> s2k;
       SecureVector<byte> salt;
       u32bit outlen, iterations;
    };
-
 /* Not too useful generally; just dumps random bits for benchmarking */
 class RNG_Filter : public Filter
    {
    public:
       void write(const byte[], u32bit);
-      RNG_Filter(RandomNumberGenerator* r) : rng(r), buffer(1024)
+      RNG_Filter(std::tr1::shared_ptr<RandomNumberGenerator> r) : rng(r), buffer(1024)
          {
          Global_RNG::randomize(buffer, buffer.size());
          rng->add_entropy(buffer, buffer.size());
          }
-      ~RNG_Filter() { delete rng; }
+      ~RNG_Filter() { }
    private:
-      RandomNumberGenerator* rng;
+	  std::tr1::shared_ptr<RandomNumberGenerator> rng;
       SecureVector<byte> buffer;
    };
 
@@ -70,36 +69,35 @@ class KDF_Filter : public Filter
                                           salt, salt.size());
          send(x.bits_of(), x.length());
          }
-      KDF_Filter(KDF* algo, const SymmetricKey& s, u32bit o)
+      KDF_Filter(std::tr1::shared_ptr<KDF> algo, const SymmetricKey& s, u32bit o)
          {
          kdf = algo;
          outlen = o;
          salt = s.bits_of();
          }
-      ~KDF_Filter() { delete kdf; }
+      ~KDF_Filter() { }
    private:
       SecureVector<byte> secret;
       SecureVector<byte> salt;
-      KDF* kdf;
+      std::tr1::shared_ptr<KDF> kdf;
       u32bit outlen;
    };
 
-Filter* lookup_s2k(const std::string& algname,
+Filter::SharedFilterPtr lookup_s2k(const std::string& algname,
                    const std::vector<std::string>& params)
    {
-   S2K* s2k = 0;
+	std::tr1::shared_ptr<S2K> s2k;
 
    try {
-      s2k = get_s2k(algname);
+      s2k = std::tr1::shared_ptr<S2K>(get_s2k(algname).release());
       }
    catch(...) { }
 
    if(s2k)
-      return new S2K_Filter(s2k, params[0], to_u32bit(params[1]),
-                            to_u32bit(params[2]));
-   return 0;
+      return create_shared_ptr<S2K_Filter>(s2k, params[0], to_u32bit(params[1]),
+    		                               to_u32bit(params[2]));
+   return Filter::SharedFilterPtr();
    }
-
 void RNG_Filter::write(const byte[], u32bit length)
    {
    while(length)
@@ -110,25 +108,25 @@ void RNG_Filter::write(const byte[], u32
       }
    }
 
-Filter* lookup_rng(const std::string& algname)
+Filter::SharedFilterPtr lookup_rng(const std::string& algname)
    {
    if(algname == "X9.31-RNG")
-      return new RNG_Filter(new ANSI_X931_RNG);
+      return create_shared_ptr<RNG_Filter>(std::tr1::shared_ptr<ANSI_X931_RNG>(new ANSI_X931_RNG));
    if(algname == "Randpool")
-      return new RNG_Filter(new Randpool);
-   return 0;
+      return create_shared_ptr<RNG_Filter>(std::tr1::shared_ptr<Randpool>(new Randpool));
+   return Filter::SharedFilterPtr();
    }
 
-Filter* lookup_kdf(const std::string& algname, const std::string& salt,
+Filter::SharedFilterPtr lookup_kdf(const std::string& algname, const std::string& salt,
                    const std::string& params)
    {
-   KDF* kdf = 0;
+   std::tr1::shared_ptr<KDF> kdf;
    try {
-      kdf = get_kdf(algname);
+      kdf = std::tr1::shared_ptr<KDF>(get_kdf(algname).release());
       }
-   catch(...) { return 0; }
+   catch(...) { return Filter::SharedFilterPtr(); }
 
    if(kdf)
-      return new KDF_Filter(kdf, salt, to_u32bit(params));
-   return 0;
+      return create_shared_ptr<KDF_Filter>(kdf, salt, to_u32bit(params));
+   return Filter::SharedFilterPtr();
    }
============================================================
--- checks/misc.cpp	5b4a686ae93a523bbc29314d2d586efd926a3fb2
+++ checks/misc.cpp	4f4c27808262253e501e8c8a54cae297af72f34c
@@ -1,11 +1,16 @@
 #include <iostream>
 #include <vector>
 #include <string>
+#include <botan/signed_obj.h>
 
 #include <botan/pipe.h>
 #include <botan/hex.h>
+#include <fstream>
 using namespace Botan;
 
+
+
+
 void strip_comments(std::string& line)
    {
    if(line.find('#') != std::string::npos)
@@ -18,11 +23,27 @@ void strip_newlines(std::string& line)
       line = line.erase(line.find('\n'), 1);
    }
 
+void strip_newlines_windows(std::string& line)
+   {
+   while(line.find('\r') != std::string::npos)
+   	{
+//      line[line.find('\r')]='\n';
+      line = line.erase(line.find('\r'), 1);
+   	}
+   }
+
+
 /* Strip comments, whitespace, etc */
 void strip(std::string& line)
    {
    strip_comments(line);
 
+   while(line.find('\r') != std::string::npos)
+      line = line.erase(line.find('\r'), 1);
+
+//   while(line.find('\n') != std::string::npos)
+//     line = line.erase(line.find('\n'), 1);
+
    while(line.find(' ') != std::string::npos)
       line = line.erase(line.find(' '), 1);
 
@@ -30,12 +51,13 @@ void strip(std::string& line)
       line = line.erase(line.find('\t'), 1);
    }
 
+
 SecureVector<byte> decode_hex(const std::string& in)
    {
    SecureVector<byte> result;
 
    try {
-      Botan::Pipe pipe(new Botan::Hex_Decoder);
+      Botan::Pipe pipe(Botan::create_shared_ptr<Botan::Hex_Decoder>());
       pipe.process_msg(in);
       result = pipe.read_all();
    }
@@ -48,7 +70,7 @@ std::string hex_encode(const byte in[], 
 
 std::string hex_encode(const byte in[], u32bit len)
    {
-   Botan::Pipe pipe(new Botan::Hex_Encoder);
+   Botan::Pipe pipe(Botan::create_shared_ptr<Botan::Hex_Encoder>());
    pipe.process_msg(in, len);
    return pipe.read_all_as_string();
    }
@@ -68,6 +90,7 @@ std::vector<std::string> parse(const std
       substr.push_back(line.substr(start));
    while(substr.size() <= 4) // at least 5 substr, some possibly empty
       substr.push_back("");
+
    return substr;
    }
 
============================================================
--- checks/pk.cpp	c541d866ce78834d3ac98bc6993dd79622288efe
+++ checks/pk.cpp	b06ed3fac53639185ef8c93fc8ed2f6252d15ec2
@@ -3,27 +3,40 @@
 #include <string>
 #include <vector>
 #include <cstdlib>
-#include <memory>
+#include<botan/tr1_mem_includer.h>
+//#include <tr1/memory>
 
 #include <botan/botan.h>
 #include <botan/libstate.h>
 #include <botan/rsa.h>
-#include <botan/dsa.h>
+//#include <botan/dsa.h>
 #include <botan/dh.h>
 
-#include <botan/nr.h>
-#include <botan/rw.h>
-#include <botan/elgamal.h>
-#include <botan/dlies.h>
+/*
+#if !defined(BOTAN_NO_NR)
+  #include <botan/nr.h>
+#endif
 
+#if !defined(BOTAN_NO_RW)
+  #include <botan/rw.h>
+#endif
+
+#if !defined(BOTAN_NO_ELG)
+  #include <botan/elgamal.h>
+#endif
+
+#if !defined(BOTAN_NO_DLIES)
+  #include <botan/dlies.h>
+#endif
+*/
 #include <botan/filters.h>
 #include <botan/look_pk.h>
-#include <botan/numthry.h>
+#include <botan/math/bigintfuncs.h>
 
 #include <botan/x931_rng.h>
 #include <botan/rng.h>
 using namespace Botan;
-
+using namespace Botan::math;
 #include "common.h"
 
 static BigInt to_bigint(const std::string& h)
@@ -64,10 +77,10 @@ extern void do_x509_tests();
 
 void do_pk_keygen_tests();
 extern void do_x509_tests();
-
+/*
 u32bit validate_dsa_sig(const std::string&, const std::vector<std::string>&);
 u32bit validate_dsa_ver(const std::string&, const std::vector<std::string>&);
-
+*/
 u32bit validate_rsa_enc(const std::string&, const std::vector<std::string>&);
 u32bit validate_rsa_enc_pkcs8(const std::string&,
                               const std::vector<std::string>&);
@@ -75,13 +88,16 @@ u32bit validate_rsa_ver_x509(const std::
 u32bit validate_rsa_ver(const std::string&, const std::vector<std::string>&);
 u32bit validate_rsa_ver_x509(const std::string&,
                              const std::vector<std::string>&);
+/*
 u32bit validate_rw_ver(const std::string&, const std::vector<std::string>&);
 u32bit validate_rw_sig(const std::string&, const std::vector<std::string>&);
 u32bit validate_nr_sig(const std::string&, const std::vector<std::string>&);
 u32bit validate_elg_enc(const std::string&, const std::vector<std::string>&);
+*/
 u32bit validate_dh(const std::string&, const std::vector<std::string>&);
+/*
 u32bit validate_dlies(const std::string&, const std::vector<std::string>&);
-
+*/
 u32bit do_pk_validation_tests(const std::string& filename)
    {
    std::ifstream test_data(filename.c_str());
@@ -101,6 +117,7 @@ u32bit do_pk_validation_tests(const std:
       std::string line;
       std::getline(test_data, line);
 
+      strip_newlines_windows(line);
       strip_comments(line);
       if(line.size() == 0) continue;
 
@@ -110,6 +127,7 @@ u32bit do_pk_validation_tests(const std:
          line.replace(line.size()-1, 1, "");
          std::string nextline;
          std::getline(test_data, nextline);
+         strip_newlines_windows(nextline);
          strip_comments(nextline);
          if(nextline.size() == 0) continue;
          line.push_back('\n');
@@ -120,6 +138,7 @@ u32bit do_pk_validation_tests(const std:
          {
          std::string old_algo = print_algorithm;
          algorithm = line.substr(1, line.size() - 2);
+
          print_algorithm = algorithm;
          if(print_algorithm.find("_PKCS8") != std::string::npos)
             print_algorithm.replace(print_algorithm.find("_PKCS8"), 6, "");
@@ -150,34 +169,35 @@ u32bit do_pk_validation_tests(const std:
 
       u32bit new_errors = 0;
 
-      if(algorithm.find("DSA/") != std::string::npos)
-         new_errors = validate_dsa_sig(algorithm, substr);
-      else if(algorithm.find("DSA_VA/") != std::string::npos)
-         new_errors = validate_dsa_ver(algorithm, substr);
+//      if(algorithm.find("DSA/") != std::string::npos)
+//         new_errors = validate_dsa_sig(algorithm, substr);
+//      else if(algorithm.find("DSA_VA/") != std::string::npos)
+//         new_errors = validate_dsa_ver(algorithm, substr);
 
-      else if(algorithm.find("RSAES_PKCS8/") != std::string::npos)
+//      else
+      if(algorithm.find("RSAES_PKCS8/") != std::string::npos)
          new_errors = validate_rsa_enc_pkcs8(algorithm, substr);
       else if(algorithm.find("RSAVA_X509/") != std::string::npos)
          new_errors = validate_rsa_ver_x509(algorithm, substr);
 
       else if(algorithm.find("RSAES/") != std::string::npos)
          new_errors = validate_rsa_enc(algorithm, substr);
-      else if(algorithm.find("RSASSA/") != std::string::npos)
-         new_errors = validate_rsa_sig(algorithm, substr);
-      else if(algorithm.find("RSAVA/") != std::string::npos)
-         new_errors = validate_rsa_ver(algorithm, substr);
-      else if(algorithm.find("RWVA/") != std::string::npos)
-         new_errors = validate_rw_ver(algorithm, substr);
-      else if(algorithm.find("RW/") != std::string::npos)
-         new_errors = validate_rw_sig(algorithm, substr);
-      else if(algorithm.find("NR/") != std::string::npos)
-         new_errors = validate_nr_sig(algorithm, substr);
-      else if(algorithm.find("ElGamal/") != std::string::npos)
-         new_errors = validate_elg_enc(algorithm, substr);
+//      else if(algorithm.find("RSASSA/") != std::string::npos)
+//         new_errors = validate_rsa_sig(algorithm, substr);
+//      else if(algorithm.find("RSAVA/") != std::string::npos)
+//         new_errors = validate_rsa_ver(algorithm, substr);
+//      else if(algorithm.find("RWVA/") != std::string::npos)
+//         new_errors = validate_rw_ver(algorithm, substr);
+//      else if(algorithm.find("RW/") != std::string::npos)
+//         new_errors = validate_rw_sig(algorithm, substr);
+//      else if(algorithm.find("NR/") != std::string::npos)
+//         new_errors = validate_nr_sig(algorithm, substr);
+//      else if(algorithm.find("ElGamal/") != std::string::npos)
+//         new_errors = validate_elg_enc(algorithm, substr);
       else if(algorithm.find("DH/") != std::string::npos)
          new_errors = validate_dh(algorithm, substr);
-      else if(algorithm.find("DLIES/") != std::string::npos)
-         new_errors = validate_dlies(algorithm, substr);
+//      else if(algorithm.find("DLIES/") != std::string::npos)
+//         new_errors = validate_dlies(algorithm, substr);
       else
          std::cout << "WARNING: Unknown PK algorithm "
                    << algorithm << std::endl;
@@ -205,7 +225,7 @@ void dump_data(const SecureVector<byte>&
 void dump_data(const SecureVector<byte>& out,
                const SecureVector<byte>& expected)
    {
-   Pipe pipe(new Hex_Encoder);
+   Pipe pipe(create_shared_ptr<Hex_Decoder>());
 
    pipe.process_msg(out);
    pipe.process_msg(expected);
@@ -213,7 +233,7 @@ void dump_data(const SecureVector<byte>&
    std::cout << "Exp: " << pipe.read_all_as_string(1) << std::endl;
    }
 
-void validate_decryption(PK_Decryptor* d, const std::string& algo,
+void validate_decryption(std::auto_ptr<PK_Decryptor> d, const std::string& algo,
                          const SecureVector<byte> ctext,
                          const SecureVector<byte> ptext,
                          bool& failure)
@@ -225,14 +245,14 @@ void validate_decryption(PK_Decryptor* d
       dump_data(decrypted, ptext);
       failure = true;
       }
-   delete d;
    }
 
-void validate_encryption(PK_Encryptor* e, PK_Decryptor* d,
+void validate_encryption(std::auto_ptr<PK_Encryptor> e, std::auto_ptr<PK_Decryptor> d,
                          const std::string& algo, const std::string& input,
                          const std::string& random, const std::string& exp,
                          bool& failure)
    {
+   //std::cout << "input: " << input << std::endl;
    SecureVector<byte> message = decode_hex(input);
 
    global_state().set_prng(new Fixed_Output_RNG(decode_hex(random)));
@@ -252,10 +272,9 @@ void validate_encryption(PK_Encryptor* e
       Global_RNG::seed(true, 384);
 
    validate_decryption(d, algo, out, message, failure);
-   delete e;
    }
 
-void validate_signature(PK_Verifier* v, PK_Signer* s, const std::string& algo,
+void validate_signature(std::auto_ptr<PK_Verifier> v, std::auto_ptr<PK_Signer> s, const std::string& algo,
                         const std::string& input, const std::string& random,
                         const std::string& exp, bool& failure)
    {
@@ -291,19 +310,19 @@ void validate_signature(PK_Verifier* v, 
    global_state().set_prng(new ANSI_X931_RNG);
    for(u32bit j = 0; j != 2; j++)
       Global_RNG::seed(true, 384);
-
-   delete v;
-   delete s;
    }
 
-void validate_kas(PK_Key_Agreement* kas, const std::string& algo,
-                  const SecureVector<byte>& pubkey, const std::string& output,
+//void validate_kas(std::auto_ptr<PK_Key_Agreement> kas, const std::string& algo,
+//                  const SecureVector<byte>& pubkey, const std::string& output,
+//                  u32bit keylen, bool& failure)
+void validate_kas(std::auto_ptr<PK_Key_Agreement> kas, const std::string& algo,
+                  const Public_Key& pubkey, const std::string& output,
                   u32bit keylen, bool& failure)
    {
    SecureVector<byte> expected = decode_hex(output);
 
    SecureVector<byte> got = kas->derive_key(keylen,
-                                            pubkey, pubkey.size()).bits_of();
+                                            pubkey).bits_of();
 
    if(got != expected)
       {
@@ -311,25 +330,26 @@ void validate_kas(PK_Key_Agreement* kas,
       dump_data(got, expected);
       failure = true;
       }
-
-   delete kas;
    }
 
 u32bit validate_rsa_enc_pkcs8(const std::string& algo,
                               const std::vector<std::string>& str)
    {
    if(str.size() != 4 && str.size() != 5)
-      throw Exception("Invalid input from pk_valid.dat");
+   {
+	   std::cout << "size: " << str.size()<< "\n";
+	   throw Exception("Invalid input from pk_valid.dat: "+str[0]);
+   }
 
    std::string pass;
    if(str.size() == 5) pass = str[4];
    strip_newlines(pass); /* it will have a newline thanks to the messy
                                 decoding method we use */
 
-   DataSource_Memory keysource((const byte*)str[0].c_str(), str[0].length());
-   Private_Key* privkey = PKCS8::load_key(keysource, pass);
+   std::tr1::shared_ptr<DataSource> keysource(new DataSource_Memory((const byte*)str[0].c_str(), str[0].length()));
+   std::auto_ptr<Private_Key> privkey = PKCS8::load_key(keysource, pass);
 
-   RSA_PrivateKey* rsapriv = dynamic_cast<RSA_PrivateKey*>(privkey);
+   RSA_PrivateKey* rsapriv = dynamic_cast<RSA_PrivateKey*>(privkey.get());
    if(!rsapriv)
       throw Invalid_Argument("Bad key load for RSA key");
 
@@ -337,12 +357,11 @@ u32bit validate_rsa_enc_pkcs8(const std:
 
    std::string eme = algo.substr(12, std::string::npos);
 
-   PK_Encryptor* e = get_pk_encryptor(*rsapub, eme);
-   PK_Decryptor* d = get_pk_decryptor(*rsapriv, eme);
+   std::auto_ptr<PK_Encryptor> e = get_pk_encryptor(*rsapub, eme);
+   std::auto_ptr<PK_Decryptor> d = get_pk_decryptor(*rsapriv, eme);
 
    bool failure = false;
    validate_encryption(e, d, algo, str[1], str[2], str[3], failure);
-   delete privkey;
    return (failure ? 1 : 0);
    }
 
@@ -350,7 +369,10 @@ u32bit validate_rsa_enc(const std::strin
                         const std::vector<std::string>& str)
    {
    if(str.size() != 6)
-      throw Exception("Invalid input from pk_valid.dat");
+   {
+	   std::cout << "size: " << str.size()<< "\n";
+	   throw Exception("Invalid input from pk_valid.dat: "+str[1]);
+   }
 
    RSA_PrivateKey privkey(to_bigint(str[1]), to_bigint(str[2]),
                           to_bigint(str[0]));
@@ -358,17 +380,21 @@ u32bit validate_rsa_enc(const std::strin
 
    std::string eme = algo.substr(6, std::string::npos);
 
-   PK_Encryptor* e = get_pk_encryptor(pubkey, eme);
-   PK_Decryptor* d = get_pk_decryptor(privkey, eme);
+   std::auto_ptr<PK_Encryptor> e = get_pk_encryptor(pubkey, eme);
+   std::auto_ptr<PK_Decryptor> d = get_pk_decryptor(privkey, eme);
 
    bool failure = false;
    validate_encryption(e, d, algo, str[3], str[4], str[5], failure);
    return (failure ? 1 : 0);
    }
 
+/*
 u32bit validate_elg_enc(const std::string& algo,
                         const std::vector<std::string>& str)
    {
+#if defined(BOTAN_NO_ELG)
+   return 0;
+#else
    if(str.size() != 6 && str.size() != 7)
       throw Exception("Invalid input from pk_valid.dat");
 
@@ -391,8 +417,9 @@ u32bit validate_elg_enc(const std::strin
                           decode_hex(str[4]), failure);
 
    return (failure ? 1 : 0);
+#endif
    }
-
+*/
 u32bit validate_rsa_sig(const std::string& algo,
                         const std::vector<std::string>& str)
    {
@@ -405,8 +432,8 @@ u32bit validate_rsa_sig(const std::strin
 
    std::string emsa = algo.substr(7, std::string::npos);
 
-   PK_Verifier* v = get_pk_verifier(pubkey, emsa);
-   PK_Signer* s = get_pk_signer(privkey, emsa);
+   std::auto_ptr<PK_Verifier> v = get_pk_verifier(pubkey, emsa);
+   std::auto_ptr<PK_Signer> s = get_pk_signer(privkey, emsa);
 
    bool failure = false;
    validate_signature(v, s, algo, str[3], str[4], str[5], failure);
@@ -423,15 +450,13 @@ u32bit validate_rsa_ver(const std::strin
 
    std::string emsa = algo.substr(6, std::string::npos);
 
-   PK_Verifier* v = get_pk_verifier(key, emsa);
+   std::auto_ptr<PK_Verifier> v = get_pk_verifier(key, emsa);
 
    SecureVector<byte> msg = decode_hex(str[2]);
    SecureVector<byte> sig = decode_hex(str[3]);
 
    bool passed = v->verify_message(msg, msg.size(), sig, sig.size());
 
-   delete v;
-
    return (passed ? 0 : 1);
    }
 
@@ -441,33 +466,34 @@ u32bit validate_rsa_ver_x509(const std::
    if(str.size() != 5) /* is actually 3, parse() adds extra empty ones */
       throw Exception("Invalid input from pk_valid.dat");
 
-   DataSource_Memory keysource((const byte*)str[0].c_str(), str[0].length());
+   std::tr1::shared_ptr<DataSource> keysource(new DataSource_Memory((const byte*)str[0].c_str(), str[0].length()));
 
-   Public_Key* key = X509::load_key(keysource);
+   std::auto_ptr<Public_Key> key = X509::load_key(keysource);
 
-   RSA_PublicKey* rsakey = dynamic_cast<RSA_PublicKey*>(key);
+   RSA_PublicKey* rsakey = dynamic_cast<RSA_PublicKey*>(key.get());
 
    if(!rsakey)
       throw Invalid_Argument("Bad key load for RSA public key");
 
    std::string emsa = algo.substr(11, std::string::npos);
 
-   PK_Verifier* v = get_pk_verifier(*rsakey, emsa);
+   std::auto_ptr<PK_Verifier> v = get_pk_verifier(*rsakey, emsa);
 
    SecureVector<byte> msg = decode_hex(str[1]);
    SecureVector<byte> sig = decode_hex(str[2]);
 
    bool passed = v->verify_message(msg, msg.size(), sig, sig.size());
 
-   delete v;
-   delete key;
-
    return (passed ? 0 : 1);
    }
 
+/*
 u32bit validate_rw_ver(const std::string& algo,
                        const std::vector<std::string>& str)
    {
+#if defined(BOTAN_NO_RW)
+   return 0;
+#else
    if(str.size() != 5)
       throw Exception("Invalid input from pk_valid.dat");
 
@@ -485,11 +511,15 @@ u32bit validate_rw_ver(const std::string
    delete v;
 
    return (passed ? 0 : 1);
+#endif
    }
 
 u32bit validate_rw_sig(const std::string& algo,
                        const std::vector<std::string>& str)
    {
+#if defined(BOTAN_NO_RW)
+   return 0;
+#else
    if(str.size() != 6)
       throw Exception("Invalid input from pk_valid.dat");
 
@@ -505,6 +535,7 @@ u32bit validate_rw_sig(const std::string
    bool failure = false;
    validate_signature(v, s, algo, str[3], str[4], str[5], failure);
    return (failure ? 1 : 0);
+#endif
    }
 
 u32bit validate_dsa_sig(const std::string& algo,
@@ -515,8 +546,7 @@ u32bit validate_dsa_sig(const std::strin
 
    std::string pass;
    if(str.size() == 5) pass = str[4];
-   strip_newlines(pass); /* it will have a newline thanks to the messy
-                                decoding method we use */
+   strip_newlines(pass); // it will have a newline thanks to the messy decoding method we use
 
    DataSource_Memory keysource((const byte*)str[0].c_str(), str[0].length());
    Private_Key* privkey = PKCS8::load_key(keysource, pass);
@@ -542,7 +572,7 @@ u32bit validate_dsa_ver(const std::strin
 u32bit validate_dsa_ver(const std::string& algo,
                         const std::vector<std::string>& str)
    {
-   if(str.size() != 5) /* is actually 3, parse() adds extra empty ones */
+   if(str.size() != 5) // is actually 3, parse() adds extra empty ones
       throw Exception("Invalid input from pk_valid.dat");
 
    DataSource_Memory keysource((const byte*)str[0].c_str(), str[0].length());
@@ -567,10 +597,15 @@ u32bit validate_dsa_ver(const std::strin
 
    return (passed ? 0 : 1);
    }
+*/
 
+/*
 u32bit validate_nr_sig(const std::string& algo,
                        const std::vector<std::string>& str)
    {
+#if defined(BOTAN_NO_NR)
+   return 0;
+#else
    if(str.size() != 8)
       throw Exception("Invalid input from pk_valid.dat");
 
@@ -586,8 +621,9 @@ u32bit validate_nr_sig(const std::string
    bool failure = false;
    validate_signature(v, s, algo, str[5], str[6], str[7], failure);
    return (failure ? 1 : 0);
+#endif
    }
-
+*/
 u32bit validate_dh(const std::string& algo,
                    const std::vector<std::string>& str)
    {
@@ -605,17 +641,22 @@ u32bit validate_dh(const std::string& al
    if(str.size() == 6)
       keylen = to_u32bit(str[5]);
 
-   PK_Key_Agreement* kas = get_pk_kas(mykey, kdf);
+   std::auto_ptr<PK_Key_Agreement> kas = get_pk_kas(mykey, kdf);
 
    bool failure = false;
-   validate_kas(kas, algo, otherkey.public_value(),
+//   validate_kas(kas, algo, otherkey.public_value(),
+//                str[4], keylen, failure);
+validate_kas(kas, algo, otherkey,
                 str[4], keylen, failure);
    return (failure ? 1 : 0);
    }
-
+/*
 u32bit validate_dlies(const std::string& algo,
                       const std::vector<std::string>& str)
    {
+#if defined(BOTAN_NO_DLIES)
+   return 0;
+#else
    if(str.size() != 6)
       throw Exception("Invalid input from pk_valid.dat");
 
@@ -643,8 +684,9 @@ u32bit validate_dlies(const std::string&
    bool failure = false;
    validate_encryption(e, d, algo, str[4], empty, str[5], failure);
    return (failure ? 1 : 0);
+#endif
    }
-
+*/
 void do_pk_keygen_tests()
    {
    std::cout << "Testing PK key generation: " << std::flush;
@@ -679,7 +721,10 @@ void do_pk_keygen_tests()
    }
 
    IF_SIG_KEY(RSA_PrivateKey, 512);
+/*
+#if !defined(BOTAN_NO_RW)
    IF_SIG_KEY(RW_PrivateKey, 512);
+#endif
 
    DL_SIG_KEY(DSA_PrivateKey, "dsa/jce/512");
    DL_SIG_KEY(DSA_PrivateKey, "dsa/jce/768");
@@ -689,13 +734,17 @@ void do_pk_keygen_tests()
    DL_KEY(DH_PrivateKey, "modp/ietf/2048");
    DL_KEY(DH_PrivateKey, "dsa/jce/1024");
 
+#if !defined(BOTAN_NO_NR)
    DL_SIG_KEY(NR_PrivateKey, "dsa/jce/512");
    DL_SIG_KEY(NR_PrivateKey, "dsa/jce/768");
    DL_SIG_KEY(NR_PrivateKey, "dsa/jce/1024");
+#endif
 
+#if !defined(BOTAN_NO_ELG)
    DL_ENC_KEY(ElGamal_PrivateKey, "modp/ietf/768");
    DL_ENC_KEY(ElGamal_PrivateKey, "modp/ietf/1024");
    DL_ENC_KEY(ElGamal_PrivateKey, "dsa/jce/1024");
-
+#endif
+*/
    std::cout << std::endl;
    }
============================================================
--- checks/pk_bench.cpp	ef6c4d7fb50c3e1f9e48fde2d793b0aff37eb76e
+++ checks/pk_bench.cpp	5a0d834374305d0fb3ea0c934f012d69097dda90
@@ -1,16 +1,24 @@
-#include <botan/dsa.h>
+//#include <botan/dsa.h>
 #include <botan/rsa.h>
 #include <botan/dh.h>
-#include <botan/nr.h>
-#include <botan/rw.h>
-#include <botan/elgamal.h>
-
 #include <botan/pkcs8.h>
 #include <botan/look_pk.h>
 #include <botan/rng.h>
+#include <botan/parsing.h>
 
-#include <botan/parsing.h>
+/*
+#if !defined(BOTAN_NO_NR)
+  #include <botan/nr.h>
+#endif
 
+#if !defined(BOTAN_NO_RW)
+  #include <botan/rw.h>
+#endif
+
+#if !defined(BOTAN_NO_ELG)
+  #include <botan/elgamal.h>
+#endif
+*/
 using namespace Botan;
 
 #include "common.h"
@@ -18,21 +26,103 @@ using namespace Botan;
 #include <iostream>
 #include <fstream>
 #include <string>
-#include <memory>
 
+#define DEBUG 0
+
 #define PRINT_MS_PER_OP 0 /* If 0, print ops / second */
 
-void bench_enc(PK_Encryptor*, const std::string&, double, bool);
-void bench_dec(PK_Encryptor*, PK_Decryptor*, const std::string&, double, bool);
-void bench_sig(PK_Signer*, const std::string&, double, bool);
-void bench_ver(PK_Signer*, PK_Verifier*, const std::string&, double, bool);
-void bench_kas(PK_Key_Agreement*, const std::string&, double, bool);
+std::auto_ptr<RSA_PrivateKey> load_rsa_key(const std::string&);
+/*
+#if !defined(BOTAN_NO_RW)
+RW_PrivateKey  load_rw_key(const std::string&);
+#endif
+*/
+/*
+static BigInt to_bigint(const std::string& h)
+   {
+   return BigInt::decode((const byte*)h.data(),
+                         h.length(), BigInt::Hexadecimal);
+   }
+*/
+void bench_enc(std::auto_ptr<PK_Encryptor>, const std::string&, double, bool);
+void bench_dec(std::auto_ptr<PK_Encryptor>, std::auto_ptr<PK_Decryptor>, const std::string&, double, bool);
+void bench_sig(std::auto_ptr<PK_Signer>, const std::string&, double, bool);
+void bench_ver(std::auto_ptr<PK_Signer>, std::auto_ptr<PK_Verifier>, const std::string&, double, bool);
+void bench_kas(std::auto_ptr<PK_Key_Agreement>, const Public_Key& pubkey, const std::string&, double, bool);
+/*
+void bench_rsa(RSA_PrivateKey& key, const std::string keybits,
+               double seconds, bool html)
+   {
+   bench_enc(get_pk_encryptor(key, "Raw"),
+             "RSA-" + keybits, seconds, html);
+   bench_dec(get_pk_encryptor(key, "Raw"),
+             get_pk_decryptor(key, "Raw"),
+             "RSA-" + keybits, seconds, html);
+   }
+*/
+/*
+void bench_dsa(DSA_PrivateKey& key, const std::string keybits,
+               double seconds, bool html)
+   {
+   bench_ver(get_pk_signer(key, "EMSA1(SHA-1)"),
+             get_pk_verifier(key, "EMSA1(SHA-1)"),
+             "DSA-" + keybits, seconds, html);
+   bench_sig(get_pk_signer(key, "EMSA1(SHA-1)"),
+             "DSA-" + keybits, seconds, html);
+   }
 
+*/
+/*
+void bench_dh(DH_PrivateKey& key, const std::string keybits,
+              double seconds, bool html)
+   {
+   bench_kas(get_pk_kas(key, "Raw"),
+             "DH-" + keybits, seconds, html);
+   }
+   */
+/*
+#if !defined(BOTAN_NO_RW)
+void bench_rw(RW_PrivateKey& key, const std::string keybits,
+              double seconds, bool html)
+   {
+   bench_ver(get_pk_signer(key, "EMSA2(SHA-1)"),
+             get_pk_verifier(key, "EMSA2(SHA-1)"),
+             "RW-" + keybits, seconds, html);
+   bench_sig(get_pk_signer(key, "EMSA2(SHA-1)"),
+             "RW-" + keybits, seconds, html);
+   }
+#endif
+
+#if !defined(BOTAN_NO_NR)
+void bench_nr(NR_PrivateKey& key, const std::string keybits,
+              double seconds, bool html)
+   {
+   bench_ver(get_pk_signer(key, "EMSA1(SHA-1)"),
+             get_pk_verifier(key, "EMSA1(SHA-1)"),
+             "NR-" + keybits, seconds, html);
+   bench_sig(get_pk_signer(key, "EMSA1(SHA-1)"),
+             "NR-" + keybits, seconds, html);
+   }
+#endif
+
+#if !defined(BOTAN_NO_ELG)
+void bench_elg(ElGamal_PrivateKey& key, const std::string keybits,
+               double seconds, bool html)
+   {
+   bench_enc(get_pk_encryptor(key, "Raw"),
+             "ELG-" + keybits, seconds, html);
+   bench_dec(get_pk_encryptor(key, "Raw"),
+             get_pk_decryptor(key, "Raw"),
+             "ELG-" + keybits, seconds, html);
+   }
+#endif
+*/
+
 void bench_pk(const std::string& algo, bool html, double seconds)
    {
    /*
      There is some strangeness going on here. It looks like algorithms
-     at the end take some kind of penalty. For example, running the RW tests
+     at the end take some kind of pentalty. For example, running the RW tests
      first got a result of:
          RW-1024: 148.14 ms / private operation
      but running them last output:
@@ -55,20 +145,25 @@ void bench_pk(const std::string& algo, b
      ad-hoc format (the RW algorithm has no assigned OID that I know of, so
      there is no way to encode a RW key into a PKCS #8 structure).
    */
+   try {
 
    if(algo == "All" || algo == "RSA")
       {
       const u32bit keylen[] = { 512, 1024, 1536, 2048, 3072, 4096, 0 };
 
       for(size_t j = 0; keylen[j]; j++)
-         {
-         const std::string len_str = to_string(keylen[j]);
-         const std::string file = "checks/keys/rsa" + len_str + ".pem";
+      {
+    	  const std::string len_str = to_string(keylen[j]);
+    	  const std::string file = "checks/keys/rsa" + len_str + ".pem";
 
-         std::auto_ptr<RSA_PrivateKey> key(
-            dynamic_cast<RSA_PrivateKey*>(PKCS8::load_key(file))
-            );
+    	  std::auto_ptr<RSA_PrivateKey> key = load_rsa_key(file);
+//    	  std::auto_ptr<RSA_PrivateKey> key(dynamic_cast<RSA_PrivateKey*>(PKCS8::load_key(file)));
+//    	          bench_rsa(*(rsa.get()), len_str, seconds, html);
 
+//    	  std::auto_ptr<RSA_PrivateKey> key(
+//            dynamic_cast<RSA_PrivateKey*>(PKCS8::load_key(file))
+//            );
+
          if(key.get() == 0)
             throw Invalid_Argument(file + " doesn't have an RSA key in it!");
 
@@ -77,103 +172,94 @@ void bench_pk(const std::string& algo, b
 
          bench_dec(get_pk_encryptor(*key, "Raw"),
                    get_pk_decryptor(*key, "Raw"),
-                   "RSA-" + len_str, seconds, html);
+                 "RSA-" + len_str, seconds, html);
          }
-      }
 
-   if(algo == "All" || algo == "DSA")
-      {
-      const u32bit keylen[] = { 512, 768, 1024, 0 };
-
-      for(size_t j = 0; keylen[j]; j++)
-         {
-         const std::string len_str = to_string(keylen[j]);
-
-         DSA_PrivateKey key("dsa/jce/" + len_str);
-
-         bench_ver(get_pk_signer(key, "EMSA1(SHA-1)"),
-                   get_pk_verifier(key, "EMSA1(SHA-1)"),
-                   "DSA-" + len_str, seconds, html);
-
-         bench_sig(get_pk_signer(key, "EMSA1(SHA-1)"),
-                   "DSA-" + len_str, seconds, html);
-         }
       }
-
    if(algo == "All" || algo == "DH")
       {
+
       const u32bit keylen[] = { 768, 1024, 1536, 2048, 3072, 4096, 0 };
 
       for(size_t j = 0; keylen[j]; j++)
-         {
+      {
          const std::string len_str = to_string(keylen[j]);
-
          DH_PrivateKey key("modp/ietf/" + len_str);
 
-         bench_kas(get_pk_kas(key, "Raw"), "DH-" + len_str, seconds, html);
-         }
+         bench_kas(get_pk_kas(key, "Raw"), key, "DH-" + len_str, seconds, html);
       }
 
+     }
+/*
+#if !defined(BOTAN_NO_ELG)
    if(algo == "All" || algo == "ELG" || algo == "ElGamal")
       {
-      const u32bit keylen[] = { 768, 1024, 1536, 2048, 3072, 4096, 0 };
-
-      for(size_t j = 0; keylen[j]; j++)
-         {
-         const std::string len_str = to_string(keylen[j]);
-
-         ElGamal_PrivateKey key("modp/ietf/" + len_str);
-
-         bench_enc(get_pk_encryptor(key, "Raw"),
-                   "ELG-" + len_str, seconds, html);
-
-         bench_dec(get_pk_encryptor(key, "Raw"),
-                   get_pk_decryptor(key, "Raw"),
-                   "ELG-" + len_str, seconds, html);
+      #define DO_ELG(NUM_STR, GROUP)                  \
+         {                                            \
+         ElGamal_PrivateKey elg(DL_Group(GROUP)); \
+         bench_elg(elg, NUM_STR, seconds, html);      \
          }
+      DO_ELG("768", "modp/ietf/768");
+      DO_ELG("1024", "modp/ietf/1024");
+      DO_ELG("1536", "modp/ietf/1536");
+      DO_ELG("2048", "modp/ietf/2048");
+      DO_ELG("3072", "modp/ietf/3072");
+      DO_ELG("4096", "modp/ietf/4096");
+      #undef DO_ELG
       }
+#endif
 
+#if !defined(BOTAN_NO_NR)
    if(algo == "All" || algo == "NR")
       {
-      const u32bit keylen[] = { 512, 768, 1024, 0 };
+      #define DO_NR(NUM_STR, GROUP)             \
+         {                                      \
+         NR_PrivateKey nr(DL_Group(GROUP)); \
+         bench_nr(nr, NUM_STR, seconds, html);  \
+         }
 
-      for(size_t j = 0; keylen[j]; j++)
-         {
-         const std::string len_str = to_string(keylen[j]);
-
-         NR_PrivateKey key("dsa/jce/" + len_str);
-
-         bench_ver(get_pk_signer(key, "EMSA1(SHA-1)"),
-                   get_pk_verifier(key, "EMSA1(SHA-1)"),
-                   "NR-" + len_str, seconds, html);
-
-         bench_sig(get_pk_signer(key, "EMSA1(SHA-1)"),
-                   "NR-" + len_str, seconds, html);
-         }
+      DO_NR("512",  "dsa/jce/512");
+      DO_NR("768",  "dsa/jce/768");
+      DO_NR("1024", "dsa/jce/1024");
+      #undef DO_NR
       }
+#endif
 
+#if !defined(BOTAN_NO_RW)
    if(algo == "All" || algo == "RW")
       {
-      const u32bit keylen[] = { 512, 1024, 0 };
+      #define DO_RW(NUM_STR, FILENAME)             \
+         {                                         \
+         RW_PrivateKey rw = load_rw_key(FILENAME); \
+         bench_rw(rw, NUM_STR, seconds, html);     \
+         }
 
-      for(size_t j = 0; keylen[j]; j++)
-         {
-         const std::string len_str = to_string(keylen[j]);
-         const std::string file = "checks/keys/rw" + len_str + ".pem";
-
-         RW_PrivateKey* key = dynamic_cast<RW_PrivateKey*>(PKCS8::load_key(file));
-
-         bench_ver(get_pk_signer(*key, "EMSA2(SHA-1)"),
-                   get_pk_verifier(*key, "EMSA2(SHA-1)"),
-                   "RW-" + len_str, seconds, html);
-         bench_sig(get_pk_signer(*key, "EMSA2(SHA-1)"),
-                   "RW-" + len_str, seconds, html);
-
-         delete key;
-         }
+      DO_RW("512",  "checks/keys/rw512.key")
+      DO_RW("1024", "checks/keys/rw1024.key")
+      #undef DO_RW
       }
+#endif
+*/
    }
+   catch(Botan::Exception& e)
+      {
+      std::cout << "Exception caught: " << e.what() << std::endl;
+      return;
+      }
+   catch(std::exception& e)
+      {
+      std::cout << "Standard library exception caught: "
+                << e.what() << std::endl;
+      return;
+      }
+   catch(...)
+      {
+      std::cout << "Unknown exception caught." << std::endl;
+      return;
+      }
 
+   }
+
 void print_result(bool html, u32bit runs, u64bit clocks_used,
                   const std::string& algo_name, const std::string& op)
    {
@@ -203,11 +289,12 @@ void print_result(bool html, u32bit runs
       if(PRINT_MS_PER_OP)
          std::cout << mseconds_per_run << " ms / " << op << std::endl;
       else
-         std::cout << runs_per_sec << " ops / second (" << op << ")" << std::endl;
+         std::cout << runs_per_sec << " ops / second (" << op << ")"
+                   << std::endl;
       }
    }
 
-void bench_enc(PK_Encryptor* enc, const std::string& algo_name,
+void bench_enc(std::auto_ptr<PK_Encryptor> enc, const std::string& algo_name,
                double seconds, bool html)
    {
    static const u32bit MSG_SIZE = 16;
@@ -228,12 +315,10 @@ void bench_enc(PK_Encryptor* enc, const 
       clocks_used += get_clock() - start;
       }
 
-   delete enc;
-
    print_result(html, runs, clocks_used, algo_name, "public operation");
    }
 
-void bench_dec(PK_Encryptor* enc, PK_Decryptor* dec,
+void bench_dec(std::auto_ptr<PK_Encryptor> enc, std::auto_ptr<PK_Decryptor> dec,
                const std::string& algo_name,
                double seconds, bool html)
    {
@@ -269,13 +354,10 @@ void bench_dec(PK_Encryptor* enc, PK_Dec
          }
       }
 
-   delete enc;
-   delete dec;
-
    print_result(html, runs, clocks_used, algo_name, "private operation");
    }
 
-void bench_sig(PK_Signer* sig, const std::string& algo_name,
+void bench_sig(std::auto_ptr<PK_Signer> sig, const std::string& algo_name,
                double seconds, bool html)
    {
    static const u32bit MSG_SIZE = 16;
@@ -295,12 +377,10 @@ void bench_sig(PK_Signer* sig, const std
       clocks_used += get_clock() - start;
       }
 
-   delete sig;
-
    print_result(html, runs, clocks_used, algo_name, "private operation");
    }
 
-void bench_ver(PK_Signer* sig, PK_Verifier* ver,
+void bench_ver(std::auto_ptr<PK_Signer> sig, std::auto_ptr<PK_Verifier> ver,
                const std::string& algo_name,
                double seconds, bool html)
    {
@@ -334,13 +414,10 @@ void bench_ver(PK_Signer* sig, PK_Verifi
          throw Internal_Error("Signature check failed during benchmark");
       }
 
-   delete sig;
-   delete ver;
-
    print_result(html, runs, clocks_used, algo_name, "public operation");
    }
 
-void bench_kas(PK_Key_Agreement* kas, const std::string& algo_name,
+void bench_kas(std::auto_ptr<PK_Key_Agreement> kas, const Public_Key& pubkey, const std::string& algo_name,
                double seconds, bool html)
    {
    /* 128 bits: should always be considered valid (what about ECC?) */
@@ -357,11 +434,47 @@ void bench_kas(PK_Key_Agreement* kas, co
       Global_RNG::randomize(key, REMOTE_KEY_SIZE);
 
       u64bit start = get_clock();
-      kas->derive_key(0, key, REMOTE_KEY_SIZE);
+      //kas->derive_key(0, key, REMOTE_KEY_SIZE);
+      kas->derive_key(0, pubkey);
       clocks_used += get_clock() - start;
       }
 
-   delete kas;
+   print_result(html, runs, clocks_used, algo_name, "key agreement");
+   }
 
-   print_result(html, runs, clocks_used, algo_name, "key agreement");
+/*************************************************
+* Key loading procedures                         *
+*************************************************/
+
+std::auto_ptr<RSA_PrivateKey> load_rsa_key(const std::string& file)
+   {
+   std::auto_ptr<Private_Key> key = PKCS8::load_key(file);
+
+   std::auto_ptr<RSA_PrivateKey> rsakey(dynamic_cast<RSA_PrivateKey*>(key.get()));
+
+   if(rsakey.get() == 0)
+      throw Invalid_Argument(file + " doesn't have an RSA key in it!");
+
+   return rsakey;
    }
+
+/*
+#if !defined(BOTAN_NO_RW)
+RW_PrivateKey load_rw_key(const std::string& file)
+   {
+   std::ifstream keyfile(file.c_str());
+   if(!keyfile)
+      throw Exception("Couldn't open the RW key file " + file);
+
+   std::string e, p, q;
+
+   std::getline(keyfile, e);
+   std::getline(keyfile, p);
+   std::getline(keyfile, q);
+
+   RW_PrivateKey key(to_bigint(p), to_bigint(q), to_bigint(e));
+
+   return key;
+   }
+#endif
+*/
============================================================
--- checks/pk_valid.dat	d9ffd4c599088a120eb095cdb0a0a1222ffb47f8
+++ checks/pk_valid.dat	cf31bbd8598d7c0bd0eca450a80403d07fd9dacd
@@ -818,2769 +818,82 @@ CF9EC32CEDF93087CBD39E784FA66B3BD32A427D
 ADF48B7ECDDB296544D8FAE80E2FFF084671E88A88334EB8E718FE8B2524358C\
 CF9EC32CEDF93087CBD39E784FA66B3BD32A427D69EEC93607A8352955C774E1
 
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIICETAbBgkqhkiG9w0BBQMwDgQI164w6OtruCcCAggABIIB8HCD8Ae9Zia6ppjK\
-OgZTy4I85VqUgHT1lcOjveqRTtnKeexhbhwR+M8kN4p4wiCHoLu+kNp2lX56Id7+\
-wt+PnN4HofDGkepxS7bve4emEIJN3TLMS1ux17Ste7cJMs4KAKLbtwh5E/slQeAz\
-/uEpTpKnyfDXbI21GxRdiJtHQuw7z+RpX1uuOIZB9t4dE5QSASdbtDJsrvekcNaV\
-tDxzWkZ1BoXcf2otaEW9yzFWlVCuerzc+IcsAtyt3GUuOkLAoY82TQ5XuJFpc2XX\
-J1GVtncjReFdzLyb1gZePiEyE9TZDtbzR2Q/iJkJE61hgNIptCwhe4nvHzMs+fGV\
-8zsudkfzvsgwb05qHt9CJVSs6Hd0frCJsqahpQSsiNUoV3SD2EsH44T5gJrTg3Ke\
-DJu46uIpMyM8VbFc5Ra6CSOuD5udSx2yV1klx7bMHWONzTOCLZnaZVT9cKC/4og/\
-em3A9OdPrfAZouqZsQ3j8u7ZS9Qun9WOZApjRxD1vObuz2VPHglIxp/ckvDJ8BJt\
-Sb4QEqFwe+Vd6tBiBTmK7Is8Fji5Ummbx0tLMSd/Xtw6jBtrrzyf85ywnFAAoTyZ\
-Or4ey/Mf5KDp4LscmXVgkAauBn/Q/wWjK+rdjTBMUW8eQFiLsQnv6087sLSdEUSm\
-jg3w4Mg=\
------END ENCRYPTED PRIVATE KEY-----:\
-012E1CD97DB414715594E404B8B0BA9C3928CDC2CCF5F71C712C462B7BC44B90\
-F36869701C7DE17111C575CA752F66AE583371242868409A9486C5104B10A03E\
-780AAE94878F0599547A63C9AAC97802FCE926255167BFE5ED84F5389496760D::\
-3ACD3EC198014D833BBF4DF281C82C96777C9534584CC926F9DEC42E7C1F846B\
-582A267B95EE4CDAAEA7AA953330BE584BDAF75089FCAF66D386AFAE39C9BF70\
-B9D21C0E4C6590C67302AAC0A8917A3F33A39F7F921820E8DF6E6DF85CD6B6E2:\
-password
+#-----BEGIN ENCRYPTED PRIVATE KEY-----\
+#MIICETAbBgkqhkiG9w0BBQMwDgQI164w6OtruCcCAggABIIB8HCD8Ae9Zia6ppjK\
+#OgZTy4I85VqUgHT1lcOjveqRTtnKeexhbhwR+M8kN4p4wiCHoLu+kNp2lX56Id7+\
+#wt+PnN4HofDGkepxS7bve4emEIJN3TLMS1ux17Ste7cJMs4KAKLbtwh5E/slQeAz\
+#/uEpTpKnyfDXbI21GxRdiJtHQuw7z+RpX1uuOIZB9t4dE5QSASdbtDJsrvekcNaV\
+#tDxzWkZ1BoXcf2otaEW9yzFWlVCuerzc+IcsAtyt3GUuOkLAoY82TQ5XuJFpc2XX\
+#J1GVtncjReFdzLyb1gZePiEyE9TZDtbzR2Q/iJkJE61hgNIptCwhe4nvHzMs+fGV\
+#8zsudkfzvsgwb05qHt9CJVSs6Hd0frCJsqahpQSsiNUoV3SD2EsH44T5gJrTg3Ke\
+#DJu46uIpMyM8VbFc5Ra6CSOuD5udSx2yV1klx7bMHWONzTOCLZnaZVT9cKC/4og/\
+#em3A9OdPrfAZouqZsQ3j8u7ZS9Qun9WOZApjRxD1vObuz2VPHglIxp/ckvDJ8BJt\
+#Sb4QEqFwe+Vd6tBiBTmK7Is8Fji5Ummbx0tLMSd/Xtw6jBtrrzyf85ywnFAAoTyZ\
+#Or4ey/Mf5KDp4LscmXVgkAauBn/Q/wWjK+rdjTBMUW8eQFiLsQnv6087sLSdEUSm\
+#jg3w4Mg=\
+#-----END ENCRYPTED PRIVATE KEY-----:\
+#012E1CD97DB414715594E404B8B0BA9C3928CDC2CCF5F71C712C462B7BC44B90\
+#F36869701C7DE17111C575CA752F66AE583371242868409A9486C5104B10A03E\
+#780AAE94878F0599547A63C9AAC97802FCE926255167BFE5ED84F5389496760D::\
+#3ACD3EC198014D833BBF4DF281C82C96777C9534584CC926F9DEC42E7C1F846B\
+#582A267B95EE4CDAAEA7AA953330BE584BDAF75089FCAF66D386AFAE39C9BF70\
+#B9D21C0E4C6590C67302AAC0A8917A3F33A39F7F921820E8DF6E6DF85CD6B6E2:\
+#password
 
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIICoTAbBgkqhkiG9w0BBQMwDgQIXbcBBmYh+DoCAggABIICgFFUCKS9lRmjJR33\
-Gndp+hSXD7IHV1kpR6ayZcbGGfYlqsDc63yaWcLiROTQzZ+DMYxaFxePhd8tKtLP\
-38iw/MyXa6IRAYA/C6JHPsXATrKRc+Og8cD5pCxc4STCrt0Wg/SCWl7V6nbnnWco\
-vfOBUHXmflnvQYMEUahsu6lZkR0wJeSyK8G5dMKb4IZ6vOffADQ0U8UuYYK+ymfJ\
-bv5XKXhfje0Iesg6eReLdQMxLI1CURCg4oio1aQsfTosa0wJ9deSry0cjXk7K4c+\
-7MROei4UWXT0Otv1CFYR6zbmBrFbds+CY7EaqoVzgsBcNPLmWWdFlrKebquGc8xy\
-HoIvJ9e/YSnE+YU+C/LapQpmyXoqcQB/Gr4Zdrb3+5ED5WYzgVY+jw8z2f2DAGJt\
-bdzzL9JvFuEG4iZ1vNi9TSy9CyEgoqTyxfcLlHZY9BG2iIhu8pajkjnYmrxodSQB\
-uRyYNJ/T9vFOJGUWHbe9Zii82TedNUBnF0G0e/aRMxBT6wQUrsB4Q2P6ntIIHuaW\
-8q0lhOG7MRnC1FtQ+qSrzpMTX9i/01F0YXegnzeiww4ROMTcO4vUtIRmF55LZv0v\
-8YOjZClzYQP6nNhpHX/+jDpZy+4GFXPVmiOhqjnqJtRbclu+CcDZG6NRFH2V9vrg\
-P+leIuPeA4hV20lbkG3xxrlnxEUAqMNCC+uwj1zTVdNKY8AlWK7umsdWiAPIIITY\
-GQCn/D/Jom7PzbMSVa4HmvsGntPxXP4PxrwErWbCNOZpE2fe0y+tiZidaoQZqmUj\
-UDvM5gYsamu9O5UcEes6QneMr6+NakYwWNl14V3jNB480sI5z8R5bmJW+tGRmYr7\
-/+MveWY=\
------END ENCRYPTED PRIVATE KEY-----:\
-01C4B6CAAFF5ABF4FA027C945EE26974E77DAF3FDE5F51899CD64DD7DDDCAE09\
-A164D350597E445481C1E8DFA352538ACF03C9AD621A37FEF184D5CE6083D701\
-E8AB5141299695AA577E89FAD0DD849FE04E4C4268834159071628689AFF6982\
-AABBC3D451597EA8D708A2A7E52646C5749207DD1648361D5F5E85F95EEF7B08::\
-8095B914D477DE2AE3F2AC7648B32EB497B7C1F4FF298D4B82F0A77298574E94\
-530DD9FF57A205499100D5920999182E1CED1F25971B27C0C3BCB06F0507305E\
-E90AD35A00469341B47A6E2E1BB7DD792F6543F74D1FDC2CDBD433DC7C9728F5\
-58DA656E5134FC174723012151360E0310B31D4112FF5CC5829B0709F8EE7303:\
-alt.alien.vampire.die.die.die
+#-----BEGIN ENCRYPTED PRIVATE KEY-----\
+#MIICoTAbBgkqhkiG9w0BBQMwDgQIXbcBBmYh+DoCAggABIICgFFUCKS9lRmjJR33\
+#Gndp+hSXD7IHV1kpR6ayZcbGGfYlqsDc63yaWcLiROTQzZ+DMYxaFxePhd8tKtLP\
+#38iw/MyXa6IRAYA/C6JHPsXATrKRc+Og8cD5pCxc4STCrt0Wg/SCWl7V6nbnnWco\
+#vfOBUHXmflnvQYMEUahsu6lZkR0wJeSyK8G5dMKb4IZ6vOffADQ0U8UuYYK+ymfJ\
+#bv5XKXhfje0Iesg6eReLdQMxLI1CURCg4oio1aQsfTosa0wJ9deSry0cjXk7K4c+\
+#7MROei4UWXT0Otv1CFYR6zbmBrFbds+CY7EaqoVzgsBcNPLmWWdFlrKebquGc8xy\
+#HoIvJ9e/YSnE+YU+C/LapQpmyXoqcQB/Gr4Zdrb3+5ED5WYzgVY+jw8z2f2DAGJt\
+#bdzzL9JvFuEG4iZ1vNi9TSy9CyEgoqTyxfcLlHZY9BG2iIhu8pajkjnYmrxodSQB\
+#uRyYNJ/T9vFOJGUWHbe9Zii82TedNUBnF0G0e/aRMxBT6wQUrsB4Q2P6ntIIHuaW\
+#8q0lhOG7MRnC1FtQ+qSrzpMTX9i/01F0YXegnzeiww4ROMTcO4vUtIRmF55LZv0v\
+#8YOjZClzYQP6nNhpHX/+jDpZy+4GFXPVmiOhqjnqJtRbclu+CcDZG6NRFH2V9vrg\
+#P+leIuPeA4hV20lbkG3xxrlnxEUAqMNCC+uwj1zTVdNKY8AlWK7umsdWiAPIIITY\
+#GQCn/D/Jom7PzbMSVa4HmvsGntPxXP4PxrwErWbCNOZpE2fe0y+tiZidaoQZqmUj\
+#UDvM5gYsamu9O5UcEes6QneMr6+NakYwWNl14V3jNB480sI5z8R5bmJW+tGRmYr7\
+#/+MveWY=\
+#-----END ENCRYPTED PRIVATE KEY-----:\
+#01C4B6CAAFF5ABF4FA027C945EE26974E77DAF3FDE5F51899CD64DD7DDDCAE09\
+#A164D350597E445481C1E8DFA352538ACF03C9AD621A37FEF184D5CE6083D701\
+#E8AB5141299695AA577E89FAD0DD849FE04E4C4268834159071628689AFF6982\
+#AABBC3D451597EA8D708A2A7E52646C5749207DD1648361D5F5E85F95EEF7B08::\
+#8095B914D477DE2AE3F2AC7648B32EB497B7C1F4FF298D4B82F0A77298574E94\
+#530DD9FF57A205499100D5920999182E1CED1F25971B27C0C3BCB06F0507305E\
+#E90AD35A00469341B47A6E2E1BB7DD792F6543F74D1FDC2CDBD433DC7C9728F5\
+#58DA656E5134FC174723012151360E0310B31D4112FF5CC5829B0709F8EE7303:\
+#alt.alien.vampire.die.die.die
 
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIICoTAbBgkqhkiG9w0BBQMwDgQIfbv0EM4sRhcCAggABIICgIOfgSDzsjOhLX+b\
-1h3lXZiIw4nhiyV9q88CDEyB0x5y+aNkWipVetWoRPqZ6oAD6qE4yGQRhJuSa0o7\
-SzHQlZ7aqBAjtiNXw3Q7yeAP9lagXLolhnIovOKbhyj9iyblgKQgzTerbevaDgp/\
-jYTWXutKLhvjZeYVH1lRBgQYw3z1jIQQDRxw5ok4sYwD0/fpv9WtQ0Rr7XvdDRDB\
-PUhDqEu8GelR+qO7yH3M8Q5qhnTxHRpDWRU+K7f3XRNwJQTdiwWJtSJtUdrSpqYV\
-cqhDzejL3BJZRTcMbjsmq/uABwL5X9prXG2M6j2+9SrQQTWFQrLsyRIGXfKbKN8i\
-wFXaUNzGFKMskk7N6ywkiLMvAIhcaDO2ATm1bHunAcTeuIfdJfdpSWcQ6oz9x9Re\
-ACnWiQ0CRRYQlSYib/u0tt28rwOvCj4F/dSSUMyXegVz0gq3koGNwk3pbHEVvvUm\
-1bqiGQSr2d7DJ+ffe5IoIWB9cUgLeTFP4BBC1hegjDfTsaGEYPVFv5Qxi6W0BaN8\
-cq/HVWofFqu9jXeGgFq1W0IjYU7zftoVc9DyKor6ffDoDzYbNcivd8OcDydLnRVI\
-aofPN+fBAREXHuSz3cYr+arBe5PLbaHTz0iCi4zZUCWU83Usz8oLAtwkK/Ta4rDR\
-KLdv8RB3C3z4r811tWuTrgvoZeG2a4Xa94rb6okHWqOXbSHV00Z2eaqqLIuc89eX\
-JDu1iJrfARsaCN/Xu9unUnJWBRcqGzWgDRMSjnOoUhTCtjKqF3WDTsOfS1n8RSQs\
-F0zMsrXMiHXrWfcN4gDB8q/uz/laLapd8BTp6IZ0oygsHc9J5OHy36TLfoPhObo5\
-HcVJbxc=\
------END ENCRYPTED PRIVATE KEY-----:\
-01C84780E9F341C7AC81703D1E1727D134E08DE7F80636F38284BC4EE3D55F95\
-9DA715879A564E46D8BF83F6D6AAC70B8A55F2825B2875DDAC312B90068B25A4\
-323A2BCC9079126838965F0F40261ACB7B0C4DD634C3B3E1F4DF71FB6A969F9C\
-D0CA6860437AC97C10288B514EA51CCAB169A0E52C54C62133371C9DCDBB399D::\
-A22AF2E3FDC9AD8215510CF6B55118A720DE36C84DE8CE00FA769325E03BB0CA\
-81BBD2960E834543443472E58754F9ECDE84D32B4F7CB2C2A5A14A60CA91C908\
-0D3AA675E56E53B2198627938C9B00ADAC3F07A50AB0622833F2DAD34C73D0EC\
-5717613E02A58936EEA60928C1A894C589FE4995607B1AF62C2BE8FD3E8ABB83:\
-foofoofoo_bar
+#-----BEGIN ENCRYPTED PRIVATE KEY-----\
+#MIICoTAbBgkqhkiG9w0BBQMwDgQIfbv0EM4sRhcCAggABIICgIOfgSDzsjOhLX+b\
+#1h3lXZiIw4nhiyV9q88CDEyB0x5y+aNkWipVetWoRPqZ6oAD6qE4yGQRhJuSa0o7\
+#SzHQlZ7aqBAjtiNXw3Q7yeAP9lagXLolhnIovOKbhyj9iyblgKQgzTerbevaDgp/\
+#jYTWXutKLhvjZeYVH1lRBgQYw3z1jIQQDRxw5ok4sYwD0/fpv9WtQ0Rr7XvdDRDB\
+#PUhDqEu8GelR+qO7yH3M8Q5qhnTxHRpDWRU+K7f3XRNwJQTdiwWJtSJtUdrSpqYV\
+#cqhDzejL3BJZRTcMbjsmq/uABwL5X9prXG2M6j2+9SrQQTWFQrLsyRIGXfKbKN8i\
+#wFXaUNzGFKMskk7N6ywkiLMvAIhcaDO2ATm1bHunAcTeuIfdJfdpSWcQ6oz9x9Re\
+#ACnWiQ0CRRYQlSYib/u0tt28rwOvCj4F/dSSUMyXegVz0gq3koGNwk3pbHEVvvUm\
+#1bqiGQSr2d7DJ+ffe5IoIWB9cUgLeTFP4BBC1hegjDfTsaGEYPVFv5Qxi6W0BaN8\
+#cq/HVWofFqu9jXeGgFq1W0IjYU7zftoVc9DyKor6ffDoDzYbNcivd8OcDydLnRVI\
+#aofPN+fBAREXHuSz3cYr+arBe5PLbaHTz0iCi4zZUCWU83Usz8oLAtwkK/Ta4rDR\
+#KLdv8RB3C3z4r811tWuTrgvoZeG2a4Xa94rb6okHWqOXbSHV00Z2eaqqLIuc89eX\
+#JDu1iJrfARsaCN/Xu9unUnJWBRcqGzWgDRMSjnOoUhTCtjKqF3WDTsOfS1n8RSQs\
+#F0zMsrXMiHXrWfcN4gDB8q/uz/laLapd8BTp6IZ0oygsHc9J5OHy36TLfoPhObo5\
+#HcVJbxc=\
+#-----END ENCRYPTED PRIVATE KEY-----:\
+#01C84780E9F341C7AC81703D1E1727D134E08DE7F80636F38284BC4EE3D55F95\
+#9DA715879A564E46D8BF83F6D6AAC70B8A55F2825B2875DDAC312B90068B25A4\
+#323A2BCC9079126838965F0F40261ACB7B0C4DD634C3B3E1F4DF71FB6A969F9C\
+#D0CA6860437AC97C10288B514EA51CCAB169A0E52C54C62133371C9DCDBB399D::\
+#A22AF2E3FDC9AD8215510CF6B55118A720DE36C84DE8CE00FA769325E03BB0CA\
+#81BBD2960E834543443472E58754F9ECDE84D32B4F7CB2C2A5A14A60CA91C908\
+#0D3AA675E56E53B2198627938C9B00ADAC3F07A50AB0622833F2DAD34C73D0EC\
+#5717613E02A58936EEA60928C1A894C589FE4995607B1AF62C2BE8FD3E8ABB83:\
+#foofoofoo_bar
 
-# PBES2 encrypted (DES-EDE)
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIzgSAjcnspfUCAggA\
-MBQGCCqGSIb3DQMHBAiupWhsYLF7rQSCAoC8ySMPx/GEUvnlb4pj/KjYaeyUJ7En\
-9jzyLKNhfP2L+aCLao3FRSXEz3UL/Bzqx15XW96xfADw+LOXbVfM+HDyDwTm8W33\
-XQbjSyTCf+4hG+XZdzCppTo5jlGLv+3St6Tx/V4D4GbN7mZnO9tSHKim2qPzITE4\
-PCiV1pzDkOFDz/BtOEqL4AQaelBHldyyTrsSBuBVk5iN20mZ5SiEA7bhSuyBxIYW\
-QAqo2/M1JSvqXzXfgcLUNWG02ROmEc1hEvGIdZZAnjVHRUaC8oecTZlROCGyQ0ec\
-5HJt+hSVTtjVvVYRyR9k0Qn+E2tz1VBLFTxXdL2bD+vbGXhHUKLG0NM1Ks9Xea7s\
-YHTGb1wvwxAGh9MoK4bWeEl14fDRIlDlEnHtt6CpF+hXhOcI1UU9MHDQhXqA6E5w\
-+0FtnGMdxd/RgSkOvkvmMzTlbBGnA2W93R3Vv66iiDVIUO4DMAxOSlH4lZmn4kiG\
-gXHIu2BpYiR/CaeKCGDW1L5Ii/T5gnxYz6rKE1NJihRlrCplGe3ip9Ra7K4h+yA4\
-S3P2OuTjImCwBI1uL65vwnPLvdKuA6exGtI6eTyoyL3XN8Wt8LAXQwn1ijVNMXej\
-f/9zQnrdkhgYwQU5yvCi5yi5ewGi+Lqfo4rxJV2lt2b2wDfHoUULFVpIHlpUsWnR\
-aVIwa0t7S5gq/lFRxbnhsHBREJgZWP9kN1XHv8hrEcyedFO4aFj2J6I9GX1vvqrp\
-F5o4a38RBjfmR8FDsH9Au7IvuuH/TUipBybgCbIUyvQADexibuthq5MI2lpmS53c\
-vo6QOp6bwusFSPUE/qbDoW4lX9SWi3vF/RcQs1j7opsDbhqQk+G05h0R\
------END ENCRYPTED PRIVATE KEY-----:\
-3BA94D8CC1749902F4599D63A527DACA74870714BC794813247D000DCF31BC57\
-E285CE5A1236EFD1956723B800C3C19094185EAAD7C744DA4917E34D3DCE5FCE\
-F4E6D797510B7A5BA67087ABBFB69FCEE5D8A98AD9A3D3B2AEE9876B9358562F\
-460A0D6C4B5D98E3D305D6B944832859CFB01072C6FCEB5D0558BA7D101458BD::\
-1185126E43C7B5F8D15523E65DAEEB6526CDCF2C8901DC7A1EC836C22CD4C344\
-1C24B16AC8ABC3E00A95C6BD03EBEC74DCA1EBD0DA6E61395452587B36DCD734\
-7184C9005177839FEDA5273007DD0AAC0E8C87A3EEA71F7DBEDDC7FDDD637A2D\
-FCA2FA1215DE8C332ED4BA093B6443C65B32AF294D8A56A1BF8702C1B9086E36:\
-foo
-
-# PBES2 encrypted (DES-EDE)
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBoTBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQItEsDvV486kcCAggA\
-AgEYMBQGCCqGSIb3DQMHBAgzfU6L9FUlJgSCAViXz0OqV1SBvbiF0sEH8GsMQJwB\
-Q1RVEjyO8uncdbujalyVCeLukh/H0W0unlgceVMSdN7/nQBitkGkvLSoWRv9hYc/\
-UlkCMcq4R3Fx2hLF6Yquq/DyBgF57LVyOpomRa/Kj8TYjfZkx3JXJnRsqjoLhTbH\
-USzwv3DkKV5gljZqLTXdPAYFyWw28GAb+3iNfzwhudblH5JXaZ3X0GWSJEium0UC\
-WPpvBGlNOUyoMFo44q100ywORYAWl/Cc7UNXWMFLQT773FypPsx+bcWpA6Lmx665\
-POrVFb4rTh+AGX9f6Kp/yfgY1VJxuju55imTaHIHZUf6phAnwoTDI+UIZTw1IwHT\
-JdYbYaxjEZglCx0u9wZT5J9IwQVKT7/eLjowV4GS8zDr/tlssDMixQboJ/dRmUYp\
-jcwhnv36cThFx6GoqWMA7ShTVT//QDpvBbebuDOnlSmqq+5qmw==\
------END ENCRYPTED PRIVATE KEY-----:\
-35489193F2E4B7B7FC7A52CB4A3AE2F7F97C02CBF43A60934CBD8AC221592666\
-92767C6C587BAE7B73E63EA470A07EA67927923FEC2ACDDB1ADDDAC75E8FFA15::\
-29772BC15B6095A66060CC76884B3E4C77A2330A880D9FE64B007C1DF792CBA5\
-B3422F9BDDF51C48E567F114776566653A7F7DDDB8686BFCEBC94B224D7CB0B3:\
-i_am_very_poor
-
-# PBES2 encrypted (DES)
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBnjBABgkqhkiG9w0BBQ0wMzAeBgkqhkiG9w0BBQwwEQQI9uqEGDMT/W0CAggA\
-AgEIMBEGBSsOAwIHBAiMfWZMW3qofASCAVgcAhB3yW1aNLIQaoo+WlTe6IRLjKWF\
-itkCW4/m6qJRvR0Yy5BTyDy5mD4QyOcVwvPGUPs6q5R+tjfbBb1orWttBDXvQn38\
-OMD8qV7voCVlDgljidAtSLmHOHy1jq7gCeyKdyC3XEMX1RZa9NIS5/fyJtrcQKxd\
-ktclLolFkiujbGH5i+LiRHWJBE8+9StxBdO+v0PE0FYR7vwxj05xKieg4UiKAVfp\
-C3+iX5XpVqMI+FTqtz/+4sm51ZgGRpz3vmNRJWqh3VqDWiwN8/w53qceDfjmNm5T\
-SfyA0K0dfSkaylprLFd666567HjDXGJlxtA4nM8N1yahRWMz/ufSd1u70dfN9l2L\
-mjghOP+WWverl+Td1cNHRE7/rvkOuhwLJpC4rnZHA4rnIxzwcQmsapk8rsu0S3I4\
-tdZEBhRZsoswIVQo030K6x9DZHMSIpghSc6BlMmu2Jbnew==\
------END ENCRYPTED PRIVATE KEY-----:\
-35068206D5C287A47F95BD8ECD11E557D86EDDC993FCAD94F03D86C1BC97E2B2\
-68E637ED1A6B0EE459214E0F61099B74469AD36A3A37217182C42B0C48A4B413::\
-261D5A9298BE592400EE703BC27C2A16761F6C855607D9AA62A9B36307FC5100\
-6EEE06E59C55C9606FFBCF8DF74A98B5C9FBD17F0D7ABB867B4A7CB8DD5DC15D:\
-give_me_$$$
-
-# The first bunch are from an RSA DSI document
-[RSAES/EME1(SHA-1)]
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-6628194E12073DB03BA94CDA9EF9532397D50DBA79B987004AFEFE34:\
-18B776EA21069D69776A33E96BAD48E1DDA0A5EF:\
-354FE67B4A126D5D35FE36C777791A3F7BA13DEF484E2D3908AFF722FAD468FB\
-21696DE95D0BE911C2D3174F8AFCC201035F7B6D8E69402DE5451618C21A535F\
-A9D7BFC5B8DD9FC243F8CF927DB31322D6E881EAA91A996170E657A05A266426\
-D98C88003F8477C1227094A0D9FA1E8C4024309CE1ECCCB5210035D47AC72E8A
-
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-D94AE0832E6445CE42331CB06D531A82B1DB4BAAD30F746DC916DF24D4E3C245\
-1FFF59A6423EB0E1D02D4FE646CF699DFD818C6E97B051:\
-2514DF4695755A67B288EAF4905C36EEC66FD2FD:\
-423736ED035F6026AF276C35C0B3741B365E5F76CA091B4E8C29E2F0BEFEE603\
-595AA8322D602D2E625E95EB81B2F1C9724E822ECA76DB8618CF09C5343503A4\
-360835B5903BC637E3879FB05E0EF32685D5AEC5067CD7CC96FE4B2670B6EAC3\
-066B1FCF5686B68589AAFB7D629B02D8F8625CA3833624D4800FB081B1CF94EB
-
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-26521050844271:\
-E4EC0982C2336F3A677F6A356174EB0CE887ABC2:\
-42CEE2617B1ECEA4DB3F4829386FBD61DAFBF038E180D837C96366DF24C097B4\
-AB0FAC6BDF590D821C9F10642E681AD05B8D78B378C0F46CE2FAD63F74E0AD3D\
-F06B075D7EB5F5636F8D403B9059CA761B5C62BB52AA45002EA70BAACE08DED2\
-43B9D8CBD62A68ADE265832B56564E43A6FA42ED199A099769742DF1539E8255
-
-10001:\
-0159DBDE04A33EF06FB608B80B190F4D3E22BCC13AC8E4A081033ABFA416EDB0B3\
-38AA08B57309EA5A5240E7DC6E54378C69414C31D97DDB1F406DB3769CC41A43:\
-012B652F30403B38B40995FD6FF41A1ACC8ADA70373236B7202D39B2EE30CFB46D\
-B09511F6F307CC61CC21606C18A75B8A62F822DF031BA0DF0DAFD5506F568BD7:\
-8FF00CAA605C702830634D9A6C3D42C652B58CF1D92FEC570BEEE7:\
-8C407B5EC2899E5099C53E8CE793BF94E71B1782:\
-0181AF8922B9FCB4D79D92EBE19815992FC0C1439D8BCD491398A0F4AD3A329A\
-5BD9385560DB532683C8B7DA04E4B12AED6AACDF471C34C9CDA891ADDCC2DF34\
-56653AA6382E9AE59B54455257EB099D562BBE10453F2B6D13C59C02E10F1F8A\
-BB5DA0D0570932DACF2D0901DB729D0FEFCC054E70968EA540C81B04BCAEFE720E
-
-10001:\
-0159DBDE04A33EF06FB608B80B190F4D3E22BCC13AC8E4A081033ABFA416EDB0B3\
-38AA08B57309EA5A5240E7DC6E54378C69414C31D97DDB1F406DB3769CC41A43:\
-012B652F30403B38B40995FD6FF41A1ACC8ADA70373236B7202D39B2EE30CFB46D\
-B09511F6F307CC61CC21606C18A75B8A62F822DF031BA0DF0DAFD5506F568BD7:\
-A7EB2A5036931D27D4E891326D99692FFADDA9BF7EFD3E34E622C4ADC085F721\
-DFE885072C78A203B151739BE540FA8C153A10F00A:\
-9A7B3B0E708BD96F8190ECAB4FB9B2B3805A8156:\
-00A4578CBC176318A638FBA7D01DF15746AF44D4F6CD96D7E7C495CBF425B09C\
-649D32BF886DA48FBAF989A2117187CAFB1FB580317690E3CCD446920B7AF82B\
-31DB5804D87D01514ACBFA9156E782F867F6BED9449E0E9A2C09BCECC6AA0876\
-36965E34B3EC766F2FE2E43018A2FDDEB140616A0E9D82E5331024EE0652FC7641
-
-10001:\
-0159DBDE04A33EF06FB608B80B190F4D3E22BCC13AC8E4A081033ABFA416EDB0B3\
-38AA08B57309EA5A5240E7DC6E54378C69414C31D97DDB1F406DB3769CC41A43:\
-012B652F30403B38B40995FD6FF41A1ACC8ADA70373236B7202D39B2EE30CFB46D\
-B09511F6F307CC61CC21606C18A75B8A62F822DF031BA0DF0DAFD5506F568BD7:\
-2EF2B066F854C33F3BDCBB5994A435E73D6C6C:\
-EB3CEBBC4ADC16BB48E88C8AEC0E34AF7F427FD3:\
-00EBC5F5FDA77CFDAD3C83641A9025E77D72D8A6FB33A810F5950F8D74C73E8D\
-931E8634D86AB1246256AE07B6005B71B7F2FB98351218331CE69B8FFBDC9DA0\
-8BBC9C704F876DEB9DF9FC2EC065CAD87F9090B07ACC17AA7F997B27ACA48806\
-E897F771D95141FE4526D8A5301B678627EFAB707FD40FBEBD6E792A25613E7AEC
-
-10001:\
-0159DBDE04A33EF06FB608B80B190F4D3E22BCC13AC8E4A081033ABFA416EDB0B3\
-38AA08B57309EA5A5240E7DC6E54378C69414C31D97DDB1F406DB3769CC41A43:\
-012B652F30403B38B40995FD6FF41A1ACC8ADA70373236B7202D39B2EE30CFB46D\
-B09511F6F307CC61CC21606C18A75B8A62F822DF031BA0DF0DAFD5506F568BD7:\
-2D:B600CF3C2E506D7F16778C910D3A8B003EEE61D5:\
-018759FF1DF63B2792410562314416A8AEAF2AC634B46F940AB82D64DBF165EE\
-E33011DA749D4BAB6E2FCD18129C9E49277D8453112B429A222A8471B0709939\
-98E758861C4D3F6D749D91C4290D332C7A4AB3F7EA35FF3A07D497C955FF0FFC\
-95006B62C6D296810D9BFAB024196C7934012C2DF978EF299ABA239940CBA10245
-
-10001:\
-01BF01D216D73595CF0270C2BEB78D40A0D8447D31DA919A983F7EEA781B77D85F\
-E371B3E9373E7B69217D3150A02D8958DE7FAD9D555160958B4454127E0E7EAF:\
-018D3399658166DB3829816D7B295416759E9C91987F5B2D8AECD63B04B48BD7B2\
-FCF229BB7F8A6DC88BA13DD2E39AD55B6D1A06160708F9700BE80B8FD3744CE7:\
-087820B569E8FA8D:\
-8CED6B196290805790E909074015E6A20B0C4894:\
-026A0485D96AEBD96B4382085099B962E6A2BDEC3D90C8DB625E14372DE85E2D5B\
-7BAAB65C8FAF91BB5504FB495AFCE5C988B3F6A52E20E1D6CBD3566C5CD1F2B831\
-8BB542CC0EA25C4AAB9932AFA20760EADDEC784396A07EA0EF24D4E6F4D37E5052\
-A7A31E146AA480A111BBE926401307E00F410033842B6D82FE5CE4DFAE80
-
-10001:\
-01BF01D216D73595CF0270C2BEB78D40A0D8447D31DA919A983F7EEA781B77D85F\
-E371B3E9373E7B69217D3150A02D8958DE7FAD9D555160958B4454127E0E7EAF:\
-018D3399658166DB3829816D7B295416759E9C91987F5B2D8AECD63B04B48BD7B2\
-FCF229BB7F8A6DC88BA13DD2E39AD55B6D1A06160708F9700BE80B8FD3744CE7:\
-6CC641B6B61E6F963974DAD23A9013284EF1:\
-6E2979F52D6814A57D83B090054888F119A5B9A3:\
-02994C62AFD76F498BA1FD2CF642857FCA81F4373CB08F1CBAEE6F025C3B512B42\
-C3E8779113476648039DBE0493F9246292FAC28950600E7C0F32EDF9C81B9DEC45\
-C3BDE0CC8D8847590169907B7DC5991CEB29BB0714D613D96DF0F12EC5D8D3507C\
-8EE7AE78DD83F216FA61DE100363ACA48A7E914AE9F42DDFBE943B09D9A0
-
-10001:\
-027458C19EC1636919E736C9AF25D609A51B8F561D19C6BF6943DD1EE1AB8A4A3F\
-232100BD40B88DECC6BA235548B6EF792A11C9DE823D0A7922C7095B6EBA5701:\
-0210EE9B33AB61716E27D251BD465F4B35A1A232E2DA00901C294BF22350CE490D\
-099F642B5375612DB63BA1F20386492BF04D34B3C22BCEB909D13441B53B5139:\
-4A86609534EE434A6CBCA3F7E962E76D455E3264C19F605F6E5FF6137C65C56D\
-7FB344CD52BC93374F3D166C9F0C6F9C506BAD19330972D2:\
-1CAC19CE993DEF55F98203F6852896C95CCCA1F3:\
-04CCE19614845E094152A3FE18E54E3330C44E5EFBC64AE16886CB1869014CC578\
-1B1F8F9E045384D0112A135CA0D12E9C88A8E4063416DEAAE3844F60D6E96FE155\
-145F4525B9A34431CA3766180F70E15A5E5D8E8B1A516FF870609F13F896935CED\
-188279A58ED13D07114277D75C6568607E0AB092FD803A223E4A8EE0B1A8
-
-10001:\
-027458C19EC1636919E736C9AF25D609A51B8F561D19C6BF6943DD1EE1AB8A4A3F\
-232100BD40B88DECC6BA235548B6EF792A11C9DE823D0A7922C7095B6EBA5701:\
-0210EE9B33AB61716E27D251BD465F4B35A1A232E2DA00901C294BF22350CE490D\
-099F642B5375612DB63BA1F20386492BF04D34B3C22BCEB909D13441B53B5139:\
-B0ADC4F3FE11DA59CE992773D9059943C03046497EE9D9F9A06DF1166DB46D98\
-F58D27EC074C02EEE6CBE2449C8B9FC5080C5C3F4433092512EC46AA793743C8:\
-F545D5897585E3DB71AA0CB8DA76C51D032AE963:\
-0097B698C6165645B303486FBF5A2A4479C0EE85889B541A6F0B858D6B6597B13B\
-854EB4F839AF03399A80D79BDA6578C841F90D645715B280D37143992DD186C80B\
-949B775CAE97370E4EC97443136C6DA484E970FFDB1323A20847821D3B18381DE1\
-3BB49AAEA66530C4A4B8271F3EAE172CD366E07E6636F1019D2A28AED15E
-
-10001:\
-03B0D3962F6D17549CBFCA11294348DCF0E7E39F8C2BC6824F2164B606D687860D\
-AE1E632393CFEDF513228229069E2F60E4ACD7E633A436063F82385F48993707:\
-02E4C32E2F517269B7072309F00C0E31365F7CE28B236B82912DF239ABF39572CF\
-0ED604B02982E53564C52D6A05397DE5C052A2FDDC141EF7189836346AEB331F:\
-AF71A901E3A61D3132F0FC1FDB474F9EA6579257FFC24D164170145B3DBDE8:\
-44C92E283F77B9499C603D963660C87D2F939461:\
-036046A4A47D9ED3BA9A89139C105038EB7492B05A5D68BFD53ACCFF4597F7A686\
-51B47B4A4627D927E485EED7B4566420E8B409879E5D606EAE251D22A5DF799F79\
-20BFC117B992572A53B1263146BCEA03385CC5E853C9A101C8C3E1BDA31A519807\
-496C6CB5E5EFB408823A352B8FA0661FB664EFADD593DEB99FFF5ED000E5
-
-10001:\
-03B0D3962F6D17549CBFCA11294348DCF0E7E39F8C2BC6824F2164B606D687860D\
-AE1E632393CFEDF513228229069E2F60E4ACD7E633A436063F82385F48993707:\
-02E4C32E2F517269B7072309F00C0E31365F7CE28B236B82912DF239ABF39572CF\
-0ED604B02982E53564C52D6A05397DE5C052A2FDDC141EF7189836346AEB331F:\
-15C5B9EE1185:49FA45D3A78DD10DFD577399D1EB00AF7EED5513:\
-0812B76768EBCB642D040258E5F4441A018521BD96687E6C5E899FCD6C17588FF5\
-9A82CC8AE03A4B45B31299AF1788C329F7DCD285F8CF4CED82606B97612671A45B\
-EDCA133442144D1617D114F802857F0F9D739751C57A3F9EE400912C61E2E6992B\
-E031A43DD48FA6BA14EEF7C422B5EDC4E7AFA04FDD38F402D1C8BB719ABF
-
-10001:\
-04A6CE8B7358DFA69BDCF742617005AFB5385F5F3A58A24EF74A22A8C05CB7CC38\
-EBD4CC9D9A9D789A62CD0F60F0CB941D3423C9692EFA4FE3ADFF290C4749A38B:\
-0404C9A803371FEDB4C5BE39F3C00B009E5E08A63BE1E40035CDACA5011CC701CF\
-7EEBCB99F0FFE17CFD0A4BF7BEFD2DD536AC946DB797FDBC4ABE8F29349B91ED:\
-684E3038C5C041F7:\
-3BBC3BD6637DFE12846901029BF5B0C07103439C:\
-008E7A67CACFB5C4E24BEC7DEE149117F19598CE8C45808FEF88C608FF9CD6E6\
-95263B9A3C0AD4B8BA4C95238E96A8422B8535629C8D5382374479AD13FA3997\
-4B242F9A759EEAF9C83AD5A8CA18940A0162BA755876DF263F4BD50C6525C560\
-90267C1F0E09CE0899A0CF359E88120ABD9BF893445B3CAE77D3607359AE9A52F8
-
-10001:\
-04A6CE8B7358DFA69BDCF742617005AFB5385F5F3A58A24EF74A22A8C05CB7CC38\
-EBD4CC9D9A9D789A62CD0F60F0CB941D3423C9692EFA4FE3ADFF290C4749A38B:\
-0404C9A803371FEDB4C5BE39F3C00B009E5E08A63BE1E40035CDACA5011CC701CF\
-7EEBCB99F0FFE17CFD0A4BF7BEFD2DD536AC946DB797FDBC4ABE8F29349B91ED:\
-4046CA8BAA3347CA27F49E0D81F9CC1D71BE9BA517D4:\
-DD0F6CFE415E88E5A469A51FBBA6DFD40ADB4384:\
-0630EEBCD2856C24F798806E41F9E67345EDA9CEDA386ACC9FACAEA1EEED06ACE5\
-83709718D9D169FADF414D5C76F92996833EF305B75B1E4B95F662A20FAEDC3BAE\
-0C4827A8BF8A88EDBD57EC203A27A841F02E43A615BAB1A8CAC0701DE34DEBDEF6\
-2A088089B55EC36EA7522FD3EC8D06B6A073E6DF833153BC0AEFD93BD1A3
-
-10001:\
-0749262C111CD470EC2566E6B3732FC09329469AA19071D3B9C01906514C6F1D26\
-BAA14BEAB0971C8B7E611A4F79009D6FEA776928CA25285B0DE3643D1A3F8C71:\
-06BC1E50E96C02BF636E9EEA8B899BBEBF7651DE77DD474C3E9BC23BAD8182B619\
-04C7D97DFBEBFB1E00108878B6E67E415391D67942C2B2BF9B4435F88B0CB023:\
-47AAE909:43DD09A07FF4CAC71CAA4632EE5E1C1DAEE4CD8F:\
-1688E4CE7794BBA6CB7014169ECD559CEDE2A30B56A52B68D9FE18CF1973EF97B2\
-A03153951C755F6294AA49ADBDB55845AB6875FB3986C93ECF927962840D282F9E\
-54CE8B690F7C0CB8BBD73440D9571D1B16CD9260F9EAB4783CC482E5223DC60973\
-871783EC27B0AE0FD47732CBC286A173FC92B00FB4BA6824647CD93C85C1
-
-10001:\
-0749262C111CD470EC2566E6B3732FC09329469AA19071D3B9C01906514C6F1D26\
-BAA14BEAB0971C8B7E611A4F79009D6FEA776928CA25285B0DE3643D1A3F8C71:\
-06BC1E50E96C02BF636E9EEA8B899BBEBF7651DE77DD474C3E9BC23BAD8182B619\
-04C7D97DFBEBFB1E00108878B6E67E415391D67942C2B2BF9B4435F88B0CB023:\
-D4738623DF223AA43843DF8467534C41D013E0C803C624E263666B239BDE40A5\
-F29AEB8DE79E3DAA61DD0370F49BD4B013834B98212AEF6B1C5EE373B3CB:\
-7866314A6AD6F2B250A35941DB28F5864B585859:\
-0AB14C373AEB7D4328D0AAAD8C094D88B9EB098B95F21054A29082522BE7C27A31\
-2878B637917E3D819E6C3C568DB5D843802B06D51D9E98A2BE0BF40C031423B00E\
-DFBFF8320EFB9171BD2044653A4CB9C5122F6C65E83CDA2EC3C126027A9C1A56BA\
-874D0FEA23F380B82CF240B8CF540004758C4C77D934157A74F3FC12BFAC
-
-10001:\
-0A02EF8448D9FAD8BBD0D004C8C2AA9751EF9721C1B0D03236A54B0DF947CBAED5\
-A255EE9E8E20D491EA1723FE094704A9762E88AFD16EBB5994412CA966DC4F9F:\
-092D362E7ED3A0BFD9E9FD0E6C0301B6DF29159CF50CC83B9B0CF4D6EEA71A61E0\
-02B46E0AE9F2DE62D25B5D7452D498B81C9AC6FC58593D4C3FB4F5D72DFBB0A9:\
-050B755E5E6880F7B9E9D692A74C37AAE449B31BFEA6DEFF83747A897F6C2C82\
-5BB1ADBF850A3C96994B5DE5B33CBC7D4A17913A7967:\
-7706FFCA1ECFB1EBEE2A55E5C6E24CD2797A4125:\
-09B3683D8A2EB0FB295B62ED1FB9290B714457B7825319F4647872AF889B304094\
-72020AD12912BF19B11D4819F49614824FFD84D09C0A17E7D17309D12919790410\
-AA2995699F6A86DBE3242B5ACC23AF45691080D6B1AE810FB3E3057087F0970092\
-CE00BE9562FF4053B6262CE0CAA93E13723D2E3A5BA075D45F0D61B54B61
-
-10001:\
-0A02EF8448D9FAD8BBD0D004C8C2AA9751EF9721C1B0D03236A54B0DF947CBAED5\
-A255EE9E8E20D491EA1723FE094704A9762E88AFD16EBB5994412CA966DC4F9F:\
-092D362E7ED3A0BFD9E9FD0E6C0301B6DF29159CF50CC83B9B0CF4D6EEA71A61E0\
-02B46E0AE9F2DE62D25B5D7452D498B81C9AC6FC58593D4C3FB4F5D72DFBB0A9:\
-8604AC56328C1AB5AD917861:EE06209073CCA026BB264E5185BF8C68B7739F86:\
-4BC89130A5B2DABB7C2FCF90EB5D0EAF9E681B7146A38F3173A3D9CFEC52EA9E0A\
-41932E648A9D69344C50DA763F51A03C95762131E8052254DCD2248CBA40FD3166\
-7786CE05A2B7B531AC9DAC9ED584A59B677C1A8AED8C5D15D68C05569E2BE780BF\
-7DB638FD2BFD2A85AB276860F3777338FCA989FFD743D13EE08E0CA9893F
-
-10001:\
-FC8D6C04BEC4EB9A8192CA7900CBE536E2E8B519DECF33B2459798C6909DF4F1\
-76DB7D23190FC72B8865A718AF895F1BCD9145298027423B605E70A47CF58390\
-A8C3E88FC8C48E8B32E3DA210DFBE3E881EA5674B6A348C21E93F9E55EA65EFD:\
-D200D45E788AACEA606A401D0460F87DD5C1027E12DC1A0D7586E8939D9CF789\
-B40F51AC0442961DE7D21CC21E05C83155C1F2AA9193387CFDF956CB48D153BA\
-270406F9BBBA537D4987D9E2F9942D7A14CBFFFEA74FECDDA928D23E259F5EE1:\
-F735FD55BA92592C3B52B8F9C4F69AAA1CBEF8FE88ADD095595412467F9CF4EC\
-0B896C59EDA16210E7549C8ABB10CDBC21A12EC9B6B5B8FD2F10399EB6:\
-8EC965F134A3EC9931E92A1CA0DC8169D5EA705C:\
-267BCD118ACAB1FC8BA81C85D73003CB8610FA55C1D97DA8D48A7C7F06896A4D\
-B751AA284255B9D36AD65F37653D829F1B37F97B8001942545B2FC2C55A7376C\
-A7A1BE4B1760C8E05A33E5AA2526B8D98E317088E7834C755B2A59B12631A182\
-C05D5D43AB1779264F8456F515CE57DFDF512D5493DAB7B7338DC4B7D78DB9C0\
-91AC3BAF537A69FC7F549D979F0EFF9A94FDA4169BD4D1D19A69C99E33C3B554\
-90D501B39B1EDAE118FF6793A153261584D3A5F39F6E682E3D17C8CD1261FA72
-
-10001:\
-FC8D6C04BEC4EB9A8192CA7900CBE536E2E8B519DECF33B2459798C6909DF4F1\
-76DB7D23190FC72B8865A718AF895F1BCD9145298027423B605E70A47CF58390\
-A8C3E88FC8C48E8B32E3DA210DFBE3E881EA5674B6A348C21E93F9E55EA65EFD:\
-D200D45E788AACEA606A401D0460F87DD5C1027E12DC1A0D7586E8939D9CF789\
-B40F51AC0442961DE7D21CC21E05C83155C1F2AA9193387CFDF956CB48D153BA\
-270406F9BBBA537D4987D9E2F9942D7A14CBFFFEA74FECDDA928D23E259F5EE1:\
-53E6E8C729D6F9C319DD317E74B0DB8E4CCCA25F3C8305746E137AC63A63EF37\
-39E7B595ABB96E8D55E54F7BD41AB433378FFB911D:\
-FCBC421402E9ECABC6082AFA40BA5F26522C840E:\
-232AFBC927FA08C2F6A27B87D4A5CB09C07DC26FAE73D73A90558839F4FD66D2\
-81B87EC734BCE237BA166698ED829106A7DE6942CD6CDCE78FED8D2E4D81428E\
-66490D036264CEF92AF941D3E35055FE3981E14D29CBB9A4F67473063BAEC79A\
-1179F5A17C9C1832F2838FD7D5E59BB9659D56DCE8A019EDEF1BB3ACCC697CC6\
-CC7A778F60A064C7F6F5D529C6210262E003DE583E81E3167B89971FB8C0E15D\
-44FFFEF89B53D8D64DD797D159B56D2B08EA5307EA12C241BD58D4EE278A1F2E
-
-10001:\
-ECF5AECD1E5515FFFACBD75A2816C6EBF49018CDFB4638E185D66A7396B6F809\
-0F8018C7FD95CC34B857DC17F0CC6516BB1346AB4D582CADAD7B4103352387B7\
-0338D084047C9D9539B6496204B3DD6EA442499207BEC01F964287FF6336C398\
-4658336846F56E46861881C10233D2176BF15A5E96DDC780BC868AA77D3CE769:\
-BC46C464FC6AC4CA783B0EB08A3C841B772F7E9B2F28BABD588AE885E1A0C61E\
-4858A0FB25AC299990F35BE85164C259BA1175CDD7192707135184992B6C29B7\
-46DD0D2CABE142835F7D148CC161524B4A09946D48B828473F1CE76B6CB6886C\
-345C03E05F41D51B5C3A90A3F24073C7D74A4FE25D9CF21C75960F3FC3863183:\
-BCDD190DA3B7D300DF9A06E22CAAE2A75F10C91FF667B7C16BDE8B53064A2649\
-A94045C9:\
-5CACA6A0F764161A9684F85D92B6E0EF37CA8B65:\
-6318E9FB5C0D05E5307E1683436E903293AC4642358AAA223D7163013ABA87E2\
-DFDA8E60C6860E29A1E92686163EA0B9175F329CA3B131A1EDD3A77759A8B97B\
-AD6A4F8F4396F28CF6F39CA58112E48160D6E203DAA5856F3ACA5FFED577AF49\
-9408E3DFD233E3E604DBE34A9C4C9082DE65527CAC6331D29DC80E0508A0FA71\
-22E7F329F6CCA5CFA34D4D1DA417805457E008BEC549E478FF9E12A763C477D1\
-5BBB78F5B69BD57830FC2C4ED686D79BC72A95D85F88134C6B0AFE56A8CCFBC8\
-55828BB339BD17909CF1D70DE3335AE07039093E606D655365DE6550B872CD6D\
-E1D440EE031B61945F629AD8A353B0D40939E96A3C450D2A8D5EEE9F678093C8
-
-5:\
-C7FBA2CB9FB24C6034C9E239E9350080AC8B9CB2DC8D428C5A1DA72767179679\
-1021093809F5F79052ACACA1EC1ED7E019818D8B2D417E8FC60812EE1A67992B:\
-FD06033468C106ADBCAA26AC4B6BD24CF4919EA5EEB99458D6E3C758ED606D63\
-9AA3D3B0BC36CFCAEC3507AD0280BF6E9F9C3EBCF41A0B33A95CC6EEBBDD57EF:\
-7730307421:67C6697351FF4AEC29CDBAABF2FBE3467CC254F8:\
-1A025CC4A2C1B8488760786162C62EC677F6546F329D84E6EE0DA11379573D17\
-92526104BF637DE57807C4394C492919021DD81ADECE3530D8D2BC1802EC2E88\
-A46C9C5E8FF11E34D7476530B7E11DE0236992DE293355494471223263664199\
-01CA2F27E4A996512BDC650D76280A54D1DE2BE17D6E59EE1D156745036D8DC5
-
-11:\
-EECFAE81B1B9B3C908810B10A1B5600199EB9F44AEF4FDA493B81A9E3D84F632\
-124EF0236E5D1E3B7E28FAE7AA040A2D5B252176459D1F397541BA2A58FB6599:\
-C97FB1F027F453F6341233EAAAD1D9353F6C42D08866B1D05A0F2035028B9D86\
-9840B41666B42E92EA0DA3B43204B5CFCE3352524D0416A5A441E700AF461503:\
-D436E99569FD32A7C8A05BBC90D32C49:\
-AAFD12F659CAE63489B479E5076DDEC2F06CB58F:\
-1253E04DC0A5397BB44A7AB87E9BF2A039A33D1E996FC82A94CCD30074C95DF7\
-63722017069E5268DA5D1C0B4F872CF653C11DF82314A67968DFEAE28DEF04BB\
-6D84B1C31D654A1970E5783BD6EB96A024C2CA2F4A90FE9F2EF5C9C140E5BB48\
-DA9536AD8700C84FC9130ADEA74E558D51A74DDF85D8B50DE96838D6063E0955
-
-11:\
-C078DF95FFF0FC15570627120760AE74601094E47D0C879075B1F1A3EC33B255\
-3490AB1484E588C18A62A166876C5FD1F9790C265CD5ECB5ADA8BE03D5ACE4DF:\
-CDECBA049D6379CAF66158D85E5A1CA40ECFB849E832109B6E018DBE5F2DC8D8\
-63DDC8DF00D93BBAD5AA1EEEF896AEF694D253C11B806547D8F3621F6C0B7041:\
-7730307421:67C6697351FF4AEC29CDBAABF2FBE3467CC254F8:\
-40BD2CCDFEB88BDBF6AE80EE37045142EEBA60D51063335F6145BD30223A1635\
-D18C4E67FAD80D158BFA711A6BBCCCE8980A171027083D2D4E6B7DA2C465ADDB\
-D1F44350C51A9E03D808EB5784F0A3602B7E23903CE4530DF3D45829375E1113\
-7FCD639874F71E68742B9C145D21ADF4C4C8416B54AC4A01B25AB4CF1570CFBD
-
-13:\
-C975657B7786E7335EA9B72E0DFE6FA895F5F7CE9E559CED9E6C9960ECECFCC1\
-EC9D515BD14849E798B4D699F7C2898B6C256A63EA5F33D2FD77A51232B722A3:\
-D502E40CEA5B850C45E3BDE7E05EF0B13F4AE0DE9D93FCE969E5A119191785A6\
-3E5C181BD0CB3F440A1B519B3961B2FB519A8526BF29A3DA6DAC68261F70149B:\
-7730307421:67C6697351FF4AEC29CDBAABF2FBE3467CC254F8:\
-4B4B2F855CE4E8D5675589DE93335E31C1EC3ADA263855252DF49BD4836DBF29\
-3E07BE72C537B9C7685B38F7C838E067BC9172DF032C1F7AE337310A41A5F103\
-B00E662E3F78E04C234825A3DA6D31CC84D591EF5E8FE970ECC2C0B23E280463\
-25D88534EC256FED8C501034F8017C771983A07EB60E396F97418AD903282B59
-
-67:\
-BEDC7B14D1A21178D999DAAF657792371C8E55D29DA042030BBCAF411D36FDD2\
-F2A1F79DBEF6B61AF19A750562ED9C7A73386929951C9D330789504FB322C99B:\
-DA9ACA1C011181903DD4C24863408D49E4E134283CE92C65C842B753FBFBA463\
-4024837D6C1C17C18254BD8CA696F85BFCEB2578BD41B2584F2F47D6B12C18F7:\
-7730307421:67C6697351FF4AEC29CDBAABF2FBE3467CC254F8:\
-11C86DA2269774A6F24161A81B25D913B1A8C9F7332D066F96AE896221BF0B30\
-63C2254FF1B082721C18BE2BC3F0B1E0CEC028D8CEF7C762E985A6C327ECEE03\
-6070B9BCA0E6E41EF72B8404C7874CBA08E2D05612D69D11DD14C1EA42E605A2\
-92AB1C5A19C2F0EF39441225C783BC573775A28857F8AEFFF4C7748C164C8A79
-
-FFFB:\
-C7479D7196291025D82523AC1840AAF09C3FF8844A444A9FED1C63996FD34566\
-B75FB997746D175CB1B253C470AF4CBC5A0EB9969A85EF32A12C75053B8D7681:\
-EC73649E669157A56375BEC8AA903491543605C6A55AA7E4C804A0A8854C1363\
-56485CF4595B5922FF408E2A364F19F8BA82D658CD179118227BAC50046802B1:\
-4920414D20534F20475245415421204920414D20534F20475245415421:\
-67C6697351FF4AEC29CDBAABF2FBE3467CC254F8:\
-B73D7477B95133222DF24ECE7F6FC3E183DC7378503F2DB0E95CCBCAD9134CB4\
-7F5CEBDBE94AB4063E473A5168CB7402E75B2423E5774FB328D2D463AB79D62D\
-46DBC2AE11382F90AB2D63CC061816991062C17B08FF6D29DB1F646C57BF122A\
-1F23017207DF6630B739134995B250260907096971F530E8006B06534A333974
-
-11:\
-FAEC2B060722051B29D1A7E1D3E060CE3CCBCB29CCFC68819F26BB7566B7C5BB\
-D02C16C5A99E7F8EC22AA7050175DEA2C6C8939A24FBFD9015DA5C33C9E13985\
-F6E788E3BB02771A4B273B4C9D376E8204E469EE1433CE4ADEE78FF6B0B96445\
-673D5A0CB10156647B5F0418CC47A3469C6D0027D6AAEBC402D2DDBA1DA5B693:\
-D4795D21407AB236151E75957B45907F27BCFCDC38A0D9E322B1F2810FADA359\
-61527F1834B1909BDAFDD8D6B779C60694E36380BA45CFC786FD28C8310AEE62\
-30432FBA0996E87D22F7792D101EA4C171AAE38956762E3EDB2DCC8919BA0269\
-F9CDE6B3D95F6D9EC93D22D118FCC837B2EE5990D6E84CB181D3416FCFFA9A23:\
-7730307421:67C6697351FF4AEC29CDBAABF2FBE3467CC254F8:\
-67114A6F725F764D578FFB44F36CEB3A2B51CDEB1183AEA7201337DF4D2F9A0E\
-7DADE80202AD35BE2C5A209E493D31437189B95C86B53EE4B849536F94782E03\
-35E1501978588A525192001D2D1B1C521A31F94ADC1A3119D50E07318246D352\
-61F44EB0C2677F0E358E486A82E2B971996C926474F3199A4686ABAE7AFE130F\
-BF419FDB7B92CB69D8FCB7FD1536234C9B82409474F9968BF16CFBDFBB57EA34\
-C01436A684B8C521A435462CB6A6EBDB5DA4D97AAD2662738810DBC40C2616D3\
-241D47085D53D92518BB24D26B2D7E8404ABE334E6C4848DEE793F0EB6B61ACA\
-D0BAAFB220CB2C9ECBCF9667ACA41661B21E0A68E187DCBB39C3D7C5C31A7771
-
-# These catch a bug in versions before 0.8.7
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-54657374206F6620454D453120286F75745B305D3D3D6F75745B315D3D3D3029:\
-55BF28124E5DCC8B92E4419464AAD74B9D489259:\
-21154AF8EAAB2063615CE16397CB0AE8FA55C94D8DB6A1738F90CE17B1F2B77C\
-57A5E2B7D892FCE8715B950070C2AEDCC6972A5B06BB20607D948FE755E24EBC\
-408456375121DB3A0205F45030DC840EBFF0ED359449B670B3AB77B9E8167658\
-DD73AE971C6B131F77C3A5143974393A2121F2F457146C7AA22DD56A7EEE86EB
-
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-454D45313A20286F75745B302C312C325D3D3D3029:\
-825B0D7E7CCA6E1DE021437268D678C0CB8427D2:\
-039FB7DCBC3ED3DC57BF06055A269E47C00119FBF1F55FEF6E4174F9859C1BBE\
-FC40B0A73E128FC5DF5DC6DA3C292BD13E428CB90A181983FA2383B092375B1B\
-66FB2263174CD75266AD03B1DA49FC5BF69ED911017ACB87FA405DC118E8EE69\
-26C7ADE4392802C8CBD26D7534B8347F9C6C40F7CB776857F45EFF31D6D17CA5
-
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-454D45313A20286F75745B302C312C325D3D3D3029:\
-20A708C1E55F288CFAE84EE6A521D3268234673B:\
-80960E4DF6DBD44A685EF7175BDCC12A53EC5DB0C8CD2866D72C120274D0F525\
-88A71E97B449B65A9E0D36AF3A6C3437440163444EA9CC03C26FC52596576B54\
-67CAFB8F171A2156135FD8CE93F7BA2E1418A4646E977DE60B19F1E7140B28EF\
-C241AB3068FD4F0B70332962F253D67B6FC41D60806D0E6B62A81C759C24F405
-
-[RSAES_PKCS8/EME1(SHA-1)]
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIICoTAbBgkqhkiG9w0BBQMwDgQIvr4d1PWvUvsCAggABIICgHacnCUtLfHl6orN\
-3TlqanvKYD4NVYiXpM4lhPbOk43UDH4iR+uEXmoGbt6HCjDJuFLt8HNcxMO0jrrZ\
-fjD14doLd5Byv8oldAKBHz4GHP2wGxb0l5vPqHE9WgDN/NKke35TJLuzkrV104K+\
-hir+LhhwDsDCV71jqsVL7ld2+AxCKF8+1uC+uSOoD91tFAXPLt2BApqByMJ59OMQ\
-MK5LKsTQJivywXSyQHVXVTCkJyx0jiChpr/ns+ABsZ7BVD8B+C2QTY4j9w4F80ms\
-dJkdEmmiRtIIPZoHrLKisPjLWE2oBgMxwfgE0twL6LgjMPAKaXPX5z9rmD+is0D7\
-BovbmCVNDLNvIB0z3ehP/EzP9V2WtPfpjwnKL746+Hy4h5bdt7pVUYjWiTxXpiAr\
-twjm8R5OUseNYrsVf2mitm8VRF97egF9BTQ74kUDQPKvwDSfVxkaOPttfo7xB0j2\
-GYRgXOsO/fosiafakBs3ARLJ7U8vjq2JtkTbKBtWvlJQmc3VHALZ64Ukt7epOlV3\
-W+hE1Hd6YnAuzCQIgPW8TtJkcSeUbH2NtR1ZCY7hUnLmqbiLAVqNezmYg5HIKZIQ\
-/IWMonvvrJimIRzz9F+EUIGM1JjgMrIIQ2zHIB8Hp0IhLNel+pWtSAZ/CDSTbOkP\
-An63u+Btp0CNGaIYPBNkW3rN9rKSRn85QFAU54LKRrtY3agVJs8VCH/jU1nBNl+P\
-pti1MKjJGAa8yCjn15jLBmS/PSRmLT04XwlDEuxBrfsAy8zScQkvMYLlVUj0JXJj\
-uEsBmm2wi8aCsD7cylqyflyePKOSAlig88cmFGWR37nq2HP8Gfi6IrzSFcLFyeOi\
-SJjGj3U=\
------END ENCRYPTED PRIVATE KEY-----:\
-B2207519BAFEA1FFA5561CE47F903CE59DA9FE82DA7D4C867A92F28F180D:\
-FC0DBB14EEF2D2FBD6D75C7D920D96F5057C45DA:\
-C1659606D25D6D3274B0380373D8F0F740EECFBE0E7C5AF20F22ADFE54063E0D\
-B5AA23737992C216A66550E8B0D1730684588B1CA0FEAC63680A7EAC2EB6DD73\
-EA5B2DFDFE2A41C47D28027E9400FD71A2A8109271993C629A39A9B006AA11AB\
-E798FCB1297BCA3B42CE1BFCE817928DC3BDD7661BFB2CFEA5B1C2D02B48B821:\
-ilikepie
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQIeNQ67v0/C1QCAggABIIBYDTbkO1cl0ur+Osz\
-kTIQYqsi+YChtwLeTE0HipSPbuvlsFI5eoQvKjaEZjSMjsZwT6hX9zVbaclDFu7o\
-fOzrEwGSGXoquFzS0GfbtynnUhk1IAPviLRdesPFCrRWFByaTRC4y2G3zT0bopo+\
-Q6as/Tk28V88dpN7qC0Q5GlAaPTzc2PAy9FGc4lnu71WGQQOVByZ4LFomBPez2F8\
-S95H85Q0OZADlp+7gGUjUtlhZqlmn0b1OGNIsU9Ua4VntOFODr2AWMhoKpmZ2nNd\
-9Nc97uwP4jx1F8hfQP3/eRlG/FgYPX9FtVPAmKV8NA1QoBIIrfW0T8/JDnOYsxA1\
-/EwyNoamD1UJ3xq0kHS9a6c1zU00l7fgc1Cn+qECu93FxAffVN/cpA/+QwQwNXhs\
-ypmHWNSJuTUwx+MvjO/aEUAaGFN5HNwiwjOgoPecnSbHyPeyc7Fy6fVp6bjYuCJH\
-gjnIOR4=\
------END ENCRYPTED PRIVATE KEY-----:\
-A3208DF23DFB014D257B4C3D7238A857AD:\
-0E151CD5DD9014F9BCE7BB3500D1E3A7EF3F36F8:\
-374FCFFE225903D58CE988FC469AF9B6D660A90A48FFB7DCE207888D871587D5\
-0494260231664CB03C18A427B04BED666770B503B6EF08632A00D9D03888B1A0:\
-unguessable_password
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQIfovX98csqwwCAggABIIBYA3nZapMLCVG6H+1\
-GVg9ThDA2RPjb5bI24AU8UcRV08Tw81SMQmZ3BCFgcbUlcEAM8BlGfc3g4KbxSt0\
-P8o0/ImCsZG4tcjQqw10CjQkG7Wg4WrKJ7wVUoKenR+9vPkzDtAFLctNqfWgbtmX\
-hD/O0twe0NT3puypunDReKq0HRu4LnMnXBzSNg9FHFvW95KU3JX6Lk0Yt77Lb0nk\
-663We9Tdr5kQnONjai5Q9gPst8suI6K9miInimPWgPSyCVy8Yp9Epl660QOpS3P4\
-mSg5ZPCT3pzcyKdSK/I1HfFSuXfP8+XYixjNHGjX3TZWl/x0g0EACowNlKQi63s2\
-9MRpBpMxu5Y/AhrpZ2GwUPQnFxmJXKOIXoSaTSzAW15QwfBGybB9F2goM3KM+xEY\
-g177HF0JWHexJGbMurT8shUjwrxFb190hoHIUYsmVN2qRT4tFNsUYAGjDAE287SW\
-YX8pFFg=\
------END ENCRYPTED PRIVATE KEY-----:\
-8F6B78A9F0D0F35BEFD38B:25D6DBAA5DEA01099646C5DD25589A10C414B6AE:\
-0091AA69E80C2690C78B99D5BB71002BDF019B12CC6ED5F7ADB0D2AF7284D1E2F\
-E14E372C71FEBBCE91309D7D18EC979DACCFE11799E31BEFF9B4D25D2B9DEF8DD:\
-akira
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQI4boeHBzsmTgCAggABIIBYNQg9WdcjfVuPIof\
-D5/vhwOE3m3fxFqPmEeGf1m6729KiaVGuICWos3o0+rca6zGwulfUe++yARG4TW4\
-Ug/kjQhYVBZ6C+0cU8HmkpyO7mNcOrIGLJVgYmfcZbIm5DKS4g8vdLLF+mC7ic3n\
-ccBmbAN7JpPUjUiPVLlmNU691TajXdf0H14oKvmagjW9revy6KPrp9Hm0DkA5k9m\
-eMc6CyVk5IUijwEQyl5kwgCZMvR1N5ojum+FS5/+m4oOOPlowypEWPJYIIrH8vqv\
-bL/ZrBN1BsNKo2vkFvgs2AUJWhtuCdOI30HpVuI9t8crCZ2jHD1N+UdPQK474xhj\
-7/kTvM+LxAJm5ZKbcTJ8IlwVvEKvjN3+NPHpOIhThNI7IuBiLbljf5Q2hO68fUrL\
-D+6blox9MfSfpObyHzAk1sz9TnglnwgszUnnQDnF0akbR0sjmAntr2J0SPQ04Ore\
-GMrVEDI=\
------END ENCRYPTED PRIVATE KEY-----:\
-E729D4D596553F96AF:36FBC9529B999745EF9F19DF5A7C4E783013C661:\
-02A9176EF95FD74880B641C1E67367F3780B59456EBBDC05A4B6EEC3D3F8B8ED\
-E063DD1E2300E24CFABF475C8F3BCCF987C043A9A839976ED7B3995752EB3A746B:\
-It's my hobby, Sakura-chan
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQIikN0UUeS0WcCAggABIIBYB5e4OfogtTUEoKL\
-N1xxteoWJirrMjzmXFVbief3OhiPTrLLAHZxQFdvnljURvY3UTUCDAJsBwgVfQlt\
-v0sYNdgxCv3seyb4f+MmDQKppHcaoPUfoE6R7J35lwE8eZs7S7sQIhA2loBuYrGf\
-V7GJ1nr0zWzb+JfRoOypMWbt0f06PMfJGdjd9dWaiR01L8PAHwwNNNREtbobrGcc\
-9jrw3bUDwMW/hkJIIrrPbQ41OqIJsQ09x+1VVBqaqcS/dy9wnB6FmUT8xvGY8YMx\
-ru23dTzd7ONBVWmhOq3Sov6o0i2eaFG8U656/L64qlw74lAUgJOVlZ8YNUEgaegc\
-rOSDDAe04/Piddbq8wpgpkB3pqJzFkleNVSBfduZaQ5azdtgpNKahIneAPbltnKm\
-hJVZ9OZImRKQaVOVZfqM5dJoohTrvTee+rT4n9O6/YcBgoP3QtTscPLSHyaQB8+A\
-X2ppo4M=\
------END ENCRYPTED PRIVATE KEY-----:\
-45A04558B8:6587ECBA1C8A7BA7C2A8B4DAE9D4076D85CAA2FE:\
-011F8E0F8A7FAF157D2C5938B137AE3A8A2158F9784E1F09E205A7C7C71505E7\
-D50DB8E967B1CC637EDB766B12570328B7C7832DAE3F79C25D14F26DF0729F72\
-6C80:qwerty
-
------BEGIN PRIVATE KEY-----\
-MIIB4QIBADANBgkqhkiG9w0BAQEFAASCAcswggHHAgEAAmEAsgsx0714GvWOspp9\
-CrFOjZ+rSKi2q1nt22CJM/vGvtVr3wfCvaszroOths+vl8OzNFWJWXLQjYx6vsiX\
-n5lcQyzeXW7Qd9VCRGoTwgd6aVvhHjfqEBttQVDJmFf+R1wrAgELAmBAvkCqFlo4\
-WUsprIqPhkscOg+9VJ+EILOVl3e1z+suHw/0AtJzhBLLGJwxBbQ3L+N3a0aQYOwP\
-uiYXuJbt7KzaKWnFP0XHzme+6X3zOGai7+2xM0CkIiAzNqdHJ49xneMCMQDkL4WP\
-uwc4vo4biGjfjqqdb29RLR3JLZ+b3C9c0LZYlW7oA/L4zeaWs1TvobkCuWMCMQDH\
-vwG8rUApjgPiBI+xv9ZNy4wt07LJMAVbi8oIW6nQsqSO5wVT764dxyilCXrMMJkC\
-MHx3AwiUj5NQqpqnfwWTouGCmc8v4bONP8lg1AQUwI1oyCF2hIe2IK9Ki2tvfDAI\
-BwIwNnnpM3URf7JeJl5VvB0L5qvgaZbTqzukXskIjep0IaUVm1ZHRW/pqwfFREhn\
-TvX7AjA/Z/CkJNDAkHNUTW67+VzPRulGiW4+Lzs0f+laa/ZL9SizJ1nS+HtUeREG\
-Ya7AO/g=\
------END PRIVATE KEY-----:\
-F5BF1834145D40D0A09D6331204035F76EB7DC981734E09CD1D755B46484675A\
-447F8E58DDCE287D6B8CAE8BCCE3833A9A5F:\
-C91DFAC04EBDD389B0A172520B3D189C6E19FDFB:\
-75CBD6ABBDDA5A8DF4470955E212778FD872B0816E659C42F9D796A48ED86EAE\
-FFAE39EB4D25A218A5EB6252DAC6A73DA23B35D967286C673FC9A603AC9B2803\
-A8F75BAA72A22A3601FC0A1AD9923CF8A75B749126E2C98BD3AEB4EE2FE3452F
-
-# The actual (internal) name is PKCS1v15, so test out the aliasing code.
-[RSAES/EME-PKCS1-v1_5]
-5:\
-DA8D6D0AE1B959B8A446CE3807F195BC6737491490206535AC8F85E5D6E5C18F:\
-F74FE3F3CFC5BDF517A50A887676E7CC2D20C509758B7657ACAB73DFDD581D07:\
-426C696E672D426C696E672E:\
-C66FF974AC57FF20D15AADF04D472ECF48F945F50945822FDA962591C160072A\
-AFAC9AB61302ABAD458A2528D610C73DCD:\
-11F10A948BAE2ED28555EE8B36028C8AE3001E8AE76DA4567A59DD59EE8B490E\
-54617009CF6E346360BE39E22B432DD7B50F0C41BEB1A6DF655E486FD5D822AA
-
-C3E9:\
-B90114E3BA96AD3076C08F63255E07A6BA0F46C0EC9332EB9081EA81100FFF2E\
-D3F886DB2DE1CE4F01ABD44D477DA8E61B66C65A9FB666B1CA8F79FC7B3EF25F:\
-E67921A8F5C8C04169E8CCEDE6EE147CB3B1E139BFA6CB6789E24238CBBA10AD\
-522B4BBA6F3B3138C7B038856F01C3735B2B61FDB18A47DB57D5B4B5B52B6E77:\
-426C696E672D426C696E672E:\
-8D4557C36F53ECB344131ADE3F85684BD10DCE1B84BB9B95A8AAF565D73283C4\
-46251D7FAFAF6C84FB216C627EEBEBD0F38C0E4C2849BB5FD95E453C9F4729E8\
-B54E0AA5700EA7ED197A0A64DA43AA33A0D232ED403F2DD5C519FD070242DBA4\
-6FAA023D4FCA255AABB85A9AEC28DB83A6:\
-9642171747FA6A731DF3D17AE28EC0AA0FB8E4046CDC0170335610B1FEBA9673\
-8E4A7FB6BD7761A035B41161696A2270AD429C09980005307A6F154B65F6CCAE\
-0C7C9CC1FC2E61BB52B5AE4AB41618023B673201D14C83DFADFDCB21BC7EF65F\
-CB497A7625E324F1ABE70B045D465051C4668A02B5F38F25606FACFAF62296FD
-
-11:\
-F233C84BB80BD0BCA772A629AFAE474650A81C10B863747364DF21776B1ED919\
-39FE9011E45B6C317F7C913F1A2E9395797C2E778FB97A0B1F57AEF663213557:\
-FB5B0E26BDD59E3494998727361831FDEC1715C0DB65E0FFF318A2BE9B33993B\
-76984F868CA9179807F29C1DE6C5489C1D43C76BBB7959BBF85922016BCECC43:\
-4C65742773206F7665727468726F772074686520676F7665726E6D656E742120\
-286D616B65207375726520746F20656E6372797074207374756666206C696B65\
-207468617429:\
-2D76481668E437FBFD3DF446DF2BC5F7F0EAA857CB913E739D5CDB6042D32ACD\
-BD332E5A99EDD3B4B210FC2937440EF8EDA3EEDE33D7B7:\
-7B8F8AAC5BBC997CD4A1DE682FBB96AC8E80C6FC2102B1E7926D9AAD97BC10A4\
-6F981BE12F8F1B51F9A9E1F8D8B7AED9CC42F2AC0420368341D994D942071766\
-79B5F2187FB6BD8F962B678CC379009D0A82ABB9933093371B71C6CDECEED957\
-EE08962B0A94C7DCF40325E5CE38C61C81D327AAE5E140F345597EE7774B8A11
-
-11:\
-C768A0691EA020997054C37D371440D61BBE79DA842AB00DB0FED730D00BEFB7\
-A466BEFED1BD928211E7E3F56B59A275135C80EF31B6F7348EAA7887E798FE41:\
-E12F3186A97838D1D57671508F249E538C85DCFD34CFEC3A98DF3A16C9559408\
-5A7F706FBAD2ABB69D654BDF2EF64C11A0B20CF70BA9AF62E416031C090F6D8B:\
-57616E7465643A20437574652063727970746F2067726F757069652E20507265\
-66657261626C792066656D616C652E:\
-22FA636CF24BFC2DAA1ED4FFA8D8D65370A45AD16A24454A2132ABA993A935B6\
-EAF3932BF7AFCC89CCE080CC4AD06914148C164C659A24468DAC947B73BE7B5B\
-09FC516E16EF7E89AE02F590EC23:\
-A0DF6D9AB85D31C7AF2E9748005C10E245A25987BA91990046FAD410E9640CE9\
-DDB51D11E8A05423D80CA8AEA69AA08A42D58AC8609B0D1390F4FBB6E48EE8D4\
-FB031A13CBA1050240E1CB5C03793CA0ECBCD543718B3DF51F6ED411512ACE95\
-FACCEF2A127D731AC0E25A47722C07FFD1A1DD5DFE0B1EEF6EDEB3C8C654AAD4
-
-1300D:\
-E8E314B7ECD4CEDE513D6E229A3A3A0E1D0DAF974ABDA9997E1978972FD0863A\
-FFD6259861CFC26F136DEBD1ED9CB227E091823C21DD79B57E8ECF67B9293113:\
-CE47F1506E6DDA70A95A6EC56E34B9F3F929D15C92DD4AC537162C6E3BD6C4EB\
-FD3C51D08BA61216685A333062EBABA4B5E647C81550C7FBE132A1D48D7EF00D:\
-486F7720646F2049206C6F766520746865653F20204D7920616363756D756C61\
-746F72206F766572666C6F77732E:\
-25B8D6560A33737B64EE77A02D5A3BA53F0F165468CCB98E7DBC6DFFA4C29033\
-A209E8B6821A3A7CF9EE89C02B42CD25F62FAFCE56B80E703897A3299F78520B\
-A251DAC421CC5A0B52E0E4B15FBB1E:\
-5A188A2132B9331B1072BCEA281DAE53070C0AAB0722D583BC7FE767BC85443B\
-5E36286AC568246781792CE04FCEA86D26124F14F3E8ADB69CF1E8A0A1D86E3E\
-0AC0F141C18CCA5F1B8228AC2996E81938B6593F37A603A41128D4CC0D453610\
-42B5F86539BDBAC1B1867E4FE351F599E955B452F675B0945093FE8310A70C9F
-
-13271:\
-D4AA40364C695FC262073498EAE363EAE585720A8AA211D37CC2BB74ABDAE7A8\
-B6D9C55D5D8E3A0E4D3B39D57D543E8A17F697FBBD45E32EC53B9240188F7EF5:\
-D4420A0041902AFD838833F2EF3AD89AFCF3EF66CA5B20036692BDC45FF861B2\
-0BE756CE35DCEC97A7BDD28DBBC09315E5B7E0249E61772436CA728C7639A8B5:\
-5768617465766572206F63637572732066726F6D206C6F766520697320616C77\
-617973206265796F6E6420676F6F6420616E64206576696C2E:\
-25C23B57F9C9E9A3A2C08F3320214F5365B1A70417F5A6AFDAEFDCF76D4CCA56\
-3D9F9625E2BA783733DE9691108973AF66BDE07A7E8854035B972387BEEA4DBD\
-4A2081CF:\
-985B3B945917B229B8274441C174B1748627F6A83986AAE295745694174928AF\
-8D6E3D309A8FDEB57F3BFB73AF2B776D13278028E7A7CFDD3F489AD3A46B2045\
-409683AABDD1C01CDF60ED850D4C918608ABC5B58C9BE3A438DB0D6D6B9C1019\
-C9498E17233D5092165471B0A1DAECE0A68104539FB85C51648176E8B7AEC1B4
-
-1A11:\
-32A4716E0F397B9340565530800F691F9E457C2C5F8ABF0A8F62971B89B43584\
-EFCD7EF66765E8BF6B84163D914364F855DF8F6C82DD49BEF76EDB1397257215:\
-360C8C90CA0B2216B342A9681EEF05BB8CF8DE2AB8F0997C97738AA32B88B956\
-D94515E35FE96238974AE8A8F0164E0FBE25C1161D7A1E9D170B821FEAD5A3CD:\
-4772617669746174696F6E2063616E6E6F742062652068656C6420726573706F\
-6E7369626C6520666F722070656F706C652066616C6C696E6720696E206C6F76\
-652E20202D2D20416C626572742045696E737465696E:\
-DADE975E4B9FCE8E3010EB1568FFDF1BCDED9A454796A0DFA6F793093A2FBE25\
-813FC6EADC4225:\
-06DE6646853E49A067C85492FCA580E49D286981CCFDC4E13B5642489CC19E80\
-3A69116BC2D75CD005B768F3FE7AA780BF7E5A2A3EA53085619946DB4B3E9DB7\
-592A8D060CDF185B3AB2C1BD551587EA8AC3745FEF60D945387B27C2001CF7A9\
-EAE9A086AA58B769A59CC4D09BCF9E100ED630EE44889F341C8DCCF52F003CF1
-
-[RSAES_PKCS8/EME-PKCS1-v1_5]
------BEGIN PRIVATE KEY-----\
-MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAt1wZLCQfj0PUKyhr\
-fWhKMm1DnCH+sT6xKHwPiyH1UTbaMaXjoKLKdfwK42UwDgJHGcSfQ9/ZYjj97o8P\
-8YiBSwIBAwJAej1mHW1qX4KNchryU5rcIZ4tEsFUdinLcFK1B2v44M4Z6+AwBTtS\
-Kb4KbbDsY3vruqonUnKa/wxxIhzZdero+wIhAO59Gs349up2k0gUJhwl+ght6JOs\
-cjb84p4QGQfob0EvAiEAxNK6zZ/S5MDLsyq1sVLOXRPc0JvBuebDtitKwdg44qUC\
-IQCe/hHepfnxpGIwDW69bqawSUW3yEwkqJcUCrtamvTWHwIhAIM3JzO/4e3V3SIc\
-eSDh3ui36IsSgSaZ187Hhyvle0HDAiEAmIKQMDlgg/7bJV+gm28s7qMpWyFfT+HI\
-oGFH/wROJlI=\
------END PRIVATE KEY-----:\
-A7AAF7FC80A74D35A163A575173A094DB366949207150DBFFF1D0B9DB01A43:\
-77BA577E606EF4A69F7C66726923ECDAB4EFF065BCAB972AD9EEF7478C09:\
-AF1F80B3057046EDE4EB139FE4954141350325E0D8291D1431F73FB601F57DA6\
-05D986965EC3B141E7BD467108EC29003C7F56315E11FA89708588B7A562A738
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQIndH0S5IM+YwCAggABIIBYPxUf3adJCBZMSwg\
-whFKB9mFbB++xWg9UxkyZwpUsqReJMloMmtyYqGhAVvR753CWAkSi/l4cUK9hwnO\
-zs0vbQcU8MfwihHed61SwDqVHN2gp76KwdFtXKAsPlQ2WHBp2azO4VySxIYu8yMr\
-zpl5o6dnKqX9p0m38OcuMOvWiWjUbPdtNKPP9/t9xUY2dYdxoOJ02h2dWRH1bYth\
-jXFD5Zf0dgv958tcsUvCd6Omn6zyYvm0k0j8XFr3btJN6msWALYadCN7QrrJDsZL\
-eKD+a5eu3AYHA7Kk4or3AAKGH4LfDN/JsFe+Z9PO1xdxwwEf75mJbOyG4LQWkDP9\
-+pUPkPY311fcblEOx9Vin5c3is/+QnackDvnKjwU7JhP7mLHk5sRwDVswN1DPA+c\
-mlC3M8/Bib94M3ts/U6EjE4r+JW3/bVsVslKelJ2zOEiqt9HK+wZBb38NgGWwrBZ\
-7Ik3umA=\
------END ENCRYPTED PRIVATE KEY-----:\
-6ECA65B7FDB0986062B70E8C68171DCAF736:A83BC3A6BA075EDE453B7338CEE\
-83BB8F5AE8B5968E3A99462181DC4E73F943B66E433F43D0E8E6F08DA14:\
-1346A7E48F0ED39B333041451A0A293DBD8E1C906B21200A1AAC228DB8C9FC0A\
-9A24DD2B434E2279051106BD625AE24DD1554704E57EC48D659AA3E9515D2B41:\
-password
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQIjb2KJZiMO9cCAggABIIBYHQXbyKPzgfuHZYm\
-b81zMQ7Kk4w5O+3XrNpFjSiRppkx3stZphGJ6vtI6NwDKb7mCf7arfeCzMIiF+gg\
-n4j27huU1KRl8SRSD9qaLaqrYrHOCpxnG3owavB8LtWacGQq3tD1/pyw/DXM/H3F\
-bdOd4q2ByvvltRAREy+0PjAwRaGBCdF3bEUP+ikIZ1zUUAhGalil1H8pPTf+8W04\
-/4NvlCyhWPqNwUEZJhFzzO1IRrAWSvn0PZAg0CHsNGHVwCRGB5/MfdEvvn6D31V2\
-wDFR/BzgNmPo7jFo7x83C/RRP/HCHHMhfTg3LHxehf1oCGI65Pj04PyHkYSNmyXz\
-QbQoP/Z6cTcbC250Q/2AT0xPamF9eAnhAcvu8QRq7M7wQQtW1z2+B/kvA5mf2020\
-4mGslEX3Iz08lZcdMwghw0xwVBZW+VCB1y07JXE8KxAhlsEj6aIbwg0KBM+d+npX\
-Ddyijnc=\
------END ENCRYPTED PRIVATE KEY-----:\
-64E8425A6B898502A081B6B78A0546F4BF2DEB85E187ED:57893B2A6A4AA7863\
-785AB8FFA68E81F3239BDA659E704833319DF5E3377AEC911AA90F205B1:\
-871A94A51ED756EAD36EE976354D2D6DE467CA5B8C9D198FAFA6D5B24BFA674A\
-20F89CF53B85F75F7E17481E212F2BF543AEC428B841C79E3E36CFD75BB7CA8D:\
-pkcsv15_isnt_very_secure
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBgTAbBgkqhkiG9w0BBQMwDgQIbcPIyX5hozwCAggABIIBYIL0VCCWjld4Zk1N\
-0s3+Uec+axsZm1cuOEm6KKqiSDUPA5bIwWJFTksEWqEfspq6VkQVGGD95hQY4a7u\
-PflXcQ2PcFeTe5vvKNcQ/5lnSY56gidhFIHYEUQMPXjzkruxzbnLMBN5Cc4oFf15\
-YnF4B3uZjsb9e0k7hb1h7lSbf1/Y2du1xdbhvXhF3q/uoCsrnxeGnjKIwesA9skS\
-U8gdojj96STbZl78HZ9vbS+RP9Dtg73qCQkeWnMz4pES9GZ1u9HJ7Q/D4sU/NaOq\
-Gg5y/WW1oNqI6Q8hTtat6oWE0pBnD5q8xuovlycEk9PJbh/b4waGh5Lc/CFUV75b\
-gxAbqn9OIzeXVZsKnHU+JQpgX3x/3+dGHKGd54w1N/0a+N8YUNyYXxyDlU7f4zNp\
-fuc2uwzfxFm4spigfxTTul+E90SMMZOIVHSp58cakq+ibeprcp2zMJcxO2EpXfas\
-GfgFhK0=\
------END ENCRYPTED PRIVATE KEY-----:\
-1548C7CEC500A26A59D493176E3B6ECECDC23FFBC485D75E4E20C978AD14F9C2\
-5CC19021C1328B1A061E317559A04326628222:66832C587BB0FC43A7380A:\
-022092438BAB2CF4A6C50D71EE39419E2E11C9E9644E0B9C2221EF81098FE318\
-8E9BE0E6E27C02A742571C0BD757C6B7F2160DCFA9A734AB6E90BDB0EF27DCD567:\
-whereismymind
-
-[RSASSA/EMSA1(SHA-1)]
-5:\
-BE88E0EF4EC64120FBD9E0CC62E931D0DCB02D7FBC59FC6B\
-3E919777E5178DA0E1C83696670F02DF3166D8ACB5B09A15:\
-EC1C473C7D3ED0B090C7DEC82343B1E3C5E6018947DC6820\
-17941BA4754715A8599D779A340FD85FC6613A1757D5B51B:\
-4920686F70652049276C6C2062652061626C6520746F2066\
-696E6420776F726B20746869732073756D6D6572::\
-9F35898F6508FB66FBF266C8D057F4FA9FB875213FA62051AFC62ABA177D42F4\
-B37FBC6F7236B01F27C1A856EA2F8CBDF88AD9FB4FEFDE0065BB7FE6F8978225\
-074A8F220C3D328C50070A953BB4E852B3F56E84594CD289A14F8F8717F5A4D1
-
-4F:\
-F1066D3E8128C009B795BBC5AC0988D73A981C108E631AC43424D63E6C964FDE\
-6B0E331D4A1FE6CEF3B744607723F4BDB1F9683D69651813AC03C757ED2412A1:\
-C00F576BC6CD63F75ECA04FB7FA5CABCC3287CBCBF99EC456CB75E9F56E2D20A\
-7F8C99BE857FA9E819BFE02C08D0405CC5045BB97C3F766F734390D881B27DEB:\
-447564652C2077686572652773206D79206361723F::\
-AD50D554C24FDE2B4D312C64D17B25F471C32CF76E54430BE37CAD31E6C961C3\
-4957AB1B4D1D2AC6782B4A979118CF7FE58BA40FB0900C2C2F5BFF26134C9489\
-136EC16EFA0E82A9B01F1C6AE744E4D4C4D126FC6466AEBA86353E83D69065AB\
-A220F460AD4AE3AB3083732290FED091D4675864EBA47B0DCB7C858264574360
-
-[RSASSA/EMSA2(SHA-1)]
-11:\
-BEFBF638255034EFF995CF15A610243A48784CEFB89CF10A11982F5ADFA0C5F2\
-49B373E33900A1A4A957F38A1EBFD49C4C74A2D7E74EEF2168F18424C6B6A843:\
-E538D5D8FE4A5800F16398B7732FCDCBBA9D397A8E77A67204458F0A89F13BEC\
-8AADE35E2346F489FF7005398596BA8A496D48D114BDBCC6D9CE292EE6ED7C93:\
-447564652C2077686572652773206D79206361723F::\
-4B9BE36BE0AAACC62FFA857A34D8032BE865C0D757C7A7827AD5D5C6DF6C5FD6\
-FD32A2EB0E851A0D04258FDBB94849CA2AD78FFA2CCC56070219B8AC198D0F98\
-165956D027A6D0325619B8C1458F01EC6A34DA517D89F3F3046AED0F169A2797\
-442FB6E586C6099B7CBE4F07682ACF751E291123AC5DF312088A9D84A54A7D54
-
-# An official IEEE 1363 test vector, sort of. The vector in question is using
-# the RSA2 signing primitives, where the output is "modulus - signature" if
-# signature is greater than modulus/2. So we just use the intermediate result,
-# since Botan doesn't support the RSA2 scheme
-3:\
-D8CD81F035EC57EFE822955149D3BFF70C53520D769D6D76646C7A792E16EBD8\
-9FE6FC5B606B56F63EB11317A8DCCDF203650EF28D0CB9A6D2B2619C52480F51:\
-CC1092495D867E64065DEE3E7955F2EBC7D47A2D7C9953388F97DDDC3E1CA19C\
-35CA659EDC3D6C08F64068EAFEDBD91127F9CB7EDC1748711B624E30B857CAAD:\
-616263::\
-A6B496F4A802AF9092F1F561931D84DBD0B943EF34C102B94DD51AB01E1054BC\
-0E0572A1FB2DB034569883F382B74E449F6C80C4060FBC0FFBD3A9CA9D66685B\
-90873007D207C1D64C692D0111157BB976A4551E72DDC83C767A9D75A4746C51\
-9B73CE52C2BFBD1C3C431D254FE8BB4308FEA486787F239FD2944390DA49DE45
-
-[RSASSA/EMSA3(MD2)]
-10001:\
-33D48445C859E52340DE704BCDDA065FBB4058D740BD1D67D29E9C146C11CF61:\
-335E8408866B0FD38DC7002D3F972C67389A65D5D8306566D5C4F2A5AA52628B:\
-45766572796F6E65206765747320467269646179206F66662E::\
-05FA6A812FC7DF8BF4F2542509E03E846E11B9C620BE2009EFB440EFBCC66921\
-6994AC04F341B57D05202D428FB2A27B5C77DFD9B15BFC3D559353503410C1E1
-
-[RSASSA/EMSA3(MD5)]
-11:\
-F8C72F6AD1A116B15688E6DDB4458E1CD69A21E4330AAB1F1024CA09AEA20C57\
-C1A1D3DFB612928E7FEEE51987D5898A24817F9A389A39A0E5A7C43CF30A16D9:\
-DDA05F490F538B6F09B2C1D14D85E66DC724D8B77D3218958A8AD6D1E9DC62D3\
-05A1FD010251CF0AD2BE511464CF33E5D8F7108E4E6E0FDBE0ED524A95DBF027:\
-556E7265717569746564206C6F7665207375636B732E::\
-7B558B0763B621830BDAF0AF9BD183A026041051579C303F351DCBC9DC168444\
-75D54EF5CCCEF59467015C4E4F8E17FF233BDE1D69B01DE46837884DFC265664\
-C5384E734555E5811259A206A05126EE70C2C1ED36A7EC2FD4F71F4F637EEF5C\
-833F92FAC30062434C43788DFB75B85BAF05227F5B1258CBC9EFF3F1D7BB9916
-
-10003:\
-D53E981F3D9AE9628B5038C8E48CBB944534522E8293145A3A98B855C4BB091E\
-67493348454DFDE02FF3C7148E313B917A199415937407B4856A98E50A570BDF:\
-CE8671329A80756167093EEFDB10D2E0E0906BDBC58C4A1A8E8FF1CD2AD25086\
-8C79F360A357B7EDC1A7220CF698D0565385ECCC9FFBB89EE76EFAA6B70E8881:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E::\
-319F7DA1448E5BA7EDAC7A5FB422A401481E895E0508D1C0FDEDA2AC51DE1D39\
-913F0D412E6E6D9313141992A202FBEFF3BD333542C88F626457046190AEB16F\
-F2A499DF5820240A5248074445B2D54DDF0C298F57B61D89EEABE7ABC728D4BD\
-E82834BA594C2231F2757A7FCD047039D3A3FE220571F30C41B5C25FDDE4FE87
-
-5:\
-314C5009A2E3B5B5C7C2E1C2A44AD98921F8005CD2C2AAB617F4DE5932FD5599\
-391584977B46ACB1020DE1E106E6B2861C2A6E0C980C151860967E51372E19F09:\
-331C1FA43BF7B78EEC60EB3627954A971FC50357F1ABDA7EFBF758793A75D601\
-6154DD9F5F878CFFDA6C5DD4F88BB5958C4D6EF4633DB0F3E578382BD69B2D567:\
-2831303238206269742074657374206F6620504B4353233129::\
-0484FEA19814279782BD0732A7A7E29738B2B2DF0D0D2928253921990B4F3908\
-F69B968FAF934C227FAF39BD35DBFD82F1C9BEAE66C4977E3AF69E0567635E18\
-A7D831D5C66A75AD8D80A6BC994EDBBE7D6F7FEC327A1E2055AA81720B336530\
-05C2CE87DF23E4A286D5A3CFF376643B969134C49E6929CC69A23E4137CE9AC719
-
-7:\
-436D230A470CA8401CA047FF1AEBAFF72FECC04A3D085576866701D5B2108D7B\
-355E8AFBEF3A687EEB6FBFF7C1152769E100EC77D72D000D6460E99C68BE30065:\
-57CDC664033ACB369AD87F6624A1342CD57E95F1CA0B44386AABD1664B511690\
-10AD4D724A900DBA16A8F10411800C15A91BE59D10ABF7147B4C291B0B0DE3AFB:\
-2831303239206269742074657374206F6620504B4353233129205075752120::\
-13AB41A8252B19A23ECC3781A7AA969ABF929AA562418750B9347F140F2C6DEE\
-BD760C27F650D403D4BC692B1BB9C99B0A8CB20D75502C3B451AEFE81BB1278E\
-23A4B7F5C3C438064CFC25890F68ED689EC7815F015C018BDCE766EE3A4A1535\
-19020BEAEC16F56F5559B8413BF0C4240645D2D8EF69B023639B336F1A2BD2A622
-
-3:\
-77757FAB85AED403810500EC7FF71C2D702A2681F4152757A6F553B3BFE264D8\
-78800D4D8021F95A425FF61153BBB9536BC67E92B5DA6FF752EC17B7F812A3DE9:\
-686C51FF0113EE267F13E63615215EF4988EF8EE5D519B41BCE5F405CFA73E7F\
-FD01E8B16727733A9F09F9E8114FDE3E6E40E93CB6B0D6DBAEBA9CE2368BBAFD3:\
-2831303330206269742074657374206F6620504B4353233129205075752120::\
-0F017BEC0E1206F2F7BD50500898EA57A1E798FBE0D8C66594F85064E1CD7FF6\
-FD528D562667C9B1D75492B83131CB1262906ABD657B3B15871CDE20F871D81D\
-E98CDF6FD87C5753A0A9E8C223BA1F1761273B9BF8756ACBDC0BD7E6E1CDCFAB\
-3C1722F1B3053ED85CE3CAA15A843112788E779E463BBF51BE3B51243CB14E6FF1
-
-B:\
-800CE163A96B6457B06761B5D3869E44137E7213E39ADE143127E9A539E1B0D8\
-1B28C3B950E90F437EF6ED8B983C0EDCA9A63B0B995A06230769069576CE144C3:\
-92A8C827CFD05C51EFA0BE5C958ED88B9813948B99A20042E3F54A8FF71F2FD3\
-5BC83DE9A242CBB3760071EDD6980C3BA7204B5CFB625FAC1367CB2DC83200CB7:\
-2831303330206269742074657374206F6620504B4353233129205075752120::\
-38DE0D39AECE20C3DA94E1B869C09F04BD22C072B1DB012E986DEEA9E254A5DD\
-5E6A946901EFC92A5EBABE010603125B60FD594A3D974986F58F6FC714473334\
-27B1FDC960512C121E8C81F0354EB956698EEE49A4F989390950B679E03A0B6D\
-964EBA3829C52C989A1ADDAE430D600188F1A215BB306EDFDE6E512E23F113C52C
-
-5:\
-A9E8F0A318CB66175E30DA2291CD2EDCD9A48DBDE30CC6D4AE4E479452DCB873\
-370599E4417350FA1F70E2F9B918C2284DF773680950983BBE35743010439A9F1:\
-83BAD868C9AD825C6C6CADE47F55F4D89974B2056293DA9C3D867EC11147720D\
-F048357E3331384C0EE2F6AFD28B9B8746BCA799C8896190C6879C1F59BD1B363:\
-2831303331206269742074657374206F6620504B4353233129205075752120::\
-192283FBAF7B9018D464D30A428689046AE3E25A499F8E437096800E09F4883B\
-E72626B9C0B50E982C5D53B6C733CECB6FF5C3CC2958BCE854BE89AA1D166361\
-ADFC0CA4B23D7A5D404B0F75ADE3FB134C965E427233F743925AB36DD45564F0\
-7FEC46F424A61977645E0C4D275A2BFB65A403FE14B20210B0CD3ED319C9D31420
-
-723B:\
-D7AFE0CDE0A05A44FEA97C7710960C3F1D7341279C025CBE16D4038C8EEF49BD\
-A81F1149AD31B33DE594C97431C52AF0F2D52198E3847CCE0AD02C5D6BFFE39D\
-52824BD671CE867AC0E219612A2AB769D82DCEA187E8AAA02428FCDE8ACCBDEF:\
-BA36A3D8F1F8AFFC57251452119236A532516ECBE4CF5AA6AC44533F4CA9995A\
-DA0FD9B0A742941AACA7FF0B12F2D317B046F5C3BC0609B519C4F564604D2969\
-19F677D590AF519ED70DE189ADEC8E024286D4C2E8866F7056E2333AF584E847:\
-47697665206D652073747566662E::\
-5C9417A66AE951AFD8900FF15463CBEC5D01DB8D771BE4BC35FBB2416D2D4D1D\
-89151E3CE6AFBC4F676627B538511C40EA1361FC2AE34DA5DE06C6507EF6FE27\
-E362830230F3B990AE26221960B459CAF308246EB6183FBB75A38A89A1A34A2D\
-D4466F18832917AC3A68AE63A8920FFC7F3353802D8E18F760F00B3BC62D5981\
-0F7F132CCB8C4A5EE2F2ABD6EC2A8FE03911F1336D70A4BBA00DDE153683CA0A\
-F730619C15AF48AC2021DF431C675874BD10B42432260EC07FAF5C2E93DE868F
-
-7205:\
-DEFB5C1A68C464B3190677215DD4D5098673AC1B510684135E5BF2AA8EF07395\
-6F29BE13C058AFD613308000261A2C90D8A8328AC2DCFBD65AD132B5D32FEDA8\
-FDF4601AA0BBCE72B56B1C01C65E6B2F3F1DAB6975574B70160BC2DA2F72F658\
-9FB9C35A8DEC519F7E4759CA4E71EB27C3CE37BF6152134B477CD8E9F5656D23:\
-EF363BC1C200BA863315BE1EBB8D0FBD5445D168BD8802D9E0DA108D4ABA276F\
-64C54006D180B53DDB655692740BE6FFAFE82565526E45626683C5CEFB768E64\
-6CA0348F5D70F435247775C5DCDFF681D955480EE5C41A2E739DDF27F321F24D\
-A4022998624D43FD566453C4603F2207A4CE906660D0D6EEFDCBC6B0585A633B:\
-47697665206D652073747566662E::\
-693E0EB1075D852FC14E4C3E54CC180F9B215A663C53AA85FE3F8777F25EF089\
-8871C922DE5508B7CD068559DEAAF1BB2C8FF590CDA7586BB8D8CD2FED31122F\
-E09A858ACE8BE7CDBD7DCEB1FB6E80ED4D1E203EA60DA5B4FC4127D3B649FE4E\
-F4991394F4B28AE8D2FF33A4B89FF8E18B9656137C43F4F950FB013882C1CCAB\
-486289B162256038F882AECFA6A5FC0B377A1B61F95B34ABCE4562805E614859\
-22B36B10C1DABAB069BDFE0EFBA0C44587CCB4FEB6839E6B2F7F07B2E90EFC1F\
-C8FA953FD56D603AE54458AFDEBDBDB99BCC29733194E1DF5DB9E7E63E993756\
-A043443A254CF4E41A171A65BE4DD3CF5AA4079F3AA69D220615B0BF935134E0
-
-71BB:\
-EED87D797D13FDD31AAD41AC7F88FED35F6483D4AC6989FDDCB540C04E69E2B5\
-085FF650613BDF8B8BCFF09E328176B8C6E5E8608A6B0BC6EA2C6461BC060FD7\
-B884A9155FB7DA583F95EA9EC896AE8C678454D9D9337C9E21F658E6B5B2EAE9\
-A8477E7D2A3F9115625A1D429087C3DA4DC71E7C9A08A44C91697B564A8ECE7C\
-E7BFF1C626F6C2D898E512CEED855A64090648FF5B71B385B551658B04F29D81\
-A00C6DA0600375D7BCB26AAE5E211EFA97AB806DABB4D783C5F8FE61BEE81565:\
-E9E6B997D92FB0DB4162D4412326D008CEA106665DEEBFC9B819E5B044A7B98B\
-3E628887BAE89C86066FFDBADFD0A52715DADCE0F4A2CCCBCCCBB095A2DD0014\
-FD8BEE4FEDEB95F19C1B7CF694E2C505BD614D06E18F362713A3DCAA41DA398D\
-29D507698D4B3FB1D8C070285A4B8A4808BE4BF60299D4E6912BA4C43CAB65D9\
-5B06F96FF50838E13B4938084C4D736FFB28477B30E4FBCD4C6826D1250B3A85\
-68DC0A7A0997CB2669DA44D925FCBD248ACDED9F5930DC805F019014AA806781:\
-47697665206D652073747566662E::\
-D0C2D44B72627C4CDF868393F38BA331742F7C553F930DBD85C2F52E8C57CEB5\
-08C31D7284DFCAD0EE161F298AB52D0B3E04FB0A6D1785F7EF0AD2B527F1DB04\
-50831A832F3F1D46357F042970DFEA8F81BBEC44B2B99272D15D6ED9587F116D\
-97E572B6534B4ED107BF43AA3DE758C074B4EB391B9AE3BDFE6D4A4FB2180A60\
-A1EC259E22825FDEADD6A13B19F011045EE8DDEF14EB404A0063DE0D953E9245\
-EF022943AF6476118600E6A726994C94309571C47B2155C9459D8BC757CB226C\
-057820443E593B4A78023F5D8BAA64BB48DD46C4AA77CE39E256A6388E2FC59C\
-E2B453AF687DA37A2C6D7E10D8328D25FF1CDE51926BB27C6200A590C8BA4BF4\
-274CC8E72CCD10271F14018573A1F41F9F1C582FC102D7621C2AC5078A14DAAB\
-36D26E055B3AA6DFBE6BE1C463C4415891086DECA173D99495188FA21F497E9D\
-270FDEB830B3F9D62F15CC843AE19F490717E9A7979139175BB7240F706851A0\
-F56BAD12970F2E0F031C313F93C9DAD4AAD0A26592D5E618B9E73566E68DCF72
-
-6FC1:\
-F34CAEA3D0B3D9BBEA6519414CDBAAF20A44AB2014D51545961B5917FF2D8F40\
-ADB5971ACB2116B7C5600DB30D8F80D54F54DDDE605A4AB5C7A4269A5678508A\
-545BB9EC585EA877EDC4C23C2370F44DB68A2FCEB73C09307CF22468CC4F51A4\
-2C1EF139FCE1867598F909931E7C364AFF8B5C1B60FAD396A641FE949888C6A0\
-C2FFF84FD7EB476B1292FACFF2DFB7F8B48934ED0352615E1AD701491C47098A\
-49920DCA9C9BE01C1C70F4AFC9BCFE869362816E21C552BBB918F521FD57688C\
-018969C6C48308D18589C2EC486A8C84E41263F594BC35993F15BD23BCE1EAB3\
-185D0828F441064D38D84148367DA2F6FFC9C29510ABABEBC33F6E525090C7B3:\
-FF433D0B39AE58722F5A84FBF7A09D31AC8D7A8A78C30E00EDB3B062C635C6DB\
-29472989F3039DB7319AC5F806E02BFAD02BFE61C01BDAD786DEFA6445E6F36E\
-CB3773B5A509E14BD414491DF694D4C5E798A33B1E4A0D371DA83B4C7B8D8D9C\
-7C8AAD77FE9ADC5CC67CFA0C9DC0772435EC455A6BC7F65D43E1B5653A80064A\
-E4EA6D910F509E16BBA32C3949BE9037F52A9A96AE49ACE787BEB0FF28E6061D\
-DB8004F4B34F65FB96DB8173AC72ACD89CFAA3428944612D4509546A3CBD0AB1\
-5B8C9CCCECF2D634CEF7D7DBB2DB35C107E7E3E6AAD6C8C73FF22166FADF2C6B\
-4F788889B7720A43EA2DA69203BE545C5A7897A8B9971E5EED87C3D57072A985:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E::\
-C4F7914A7930FF55A16083CCF84D72F03C900374BF60145EDEF156AF48ADCBCC\
-51AD3912EF0F27A84AACE8CF7DB7EDFC2133BE617EDA7AD5C69C82C2BC1532CC\
-04B005CE6349EC5F4951BDECCA0D65AA5A07923570A23F51A30C972B0966B2C7\
-FC3D0821D14555A2A2EF281AB0D533F5C37FA6B3A683B794C8770CCD41BBE418\
-262D1D6EFB98108BEFA271BA5441FCF68FDFAA450E02AEB78AAE5FBE8FE02D37\
-EFF8D7D250503F6BD5E6805BEDF3177FBBF8DEEEE4D2A36BEC34106B7E2FA7ED\
-1874C9023B6B71CBA87ED2954D0B0F52C1C51D8242B4012AA22689F9FCCA74C4\
-C1BEB23DA240C6FA183A2AFC494615382D3AB7C3A96601C2097B381C5EB5F530\
-AF1DA74FB05BDBC52B5F08030CB8C3518D8B9AE17A6164A781493FA7827E1E95\
-7EE09D0277019DE3304C03FA8071F8A4C720290DCF4ADEBA54C93BA3B71F886C\
-D20D959424599480BC35D7F6D6A3B0A112BCB5CD99F16DEF87B08816497E9B6A\
-6FA9D28049239776B0266AA28557D3B811B48FEB601E6CA16951CB899D6F56C7\
-828E37201420A9A51360750698BAD1DB0567BE0A3CE32CFEF34566FCEAC272FF\
-944FB8990C29A3430A5CFE9048D8F595B47AFA93CD910FEB471139FC9D992EEC\
-BDC0DD304AD20F551D2AC1AF97AA7C2F058DEDD9302BB7EAA3210748B49BBA81\
-95BC3B83719656AC55773D0A49A9F74F0DA0FFFA76BAF700F430EFCE96DF961C
-
-[RSASSA/EMSA3(SHA-1)]
-10001:\
-33D48445C859E52340DE704BCDDA065FBB4058D740BD1D67D29E9C146C11CF61:\
-335E8408866B0FD38DC7002D3F972C67389A65D5D8306566D5C4F2A5AA52628B:\
-45766572796F6E65206765747320467269646179206F66662E::\
-0610761F95FFD1B8F29DA34212947EC2AA0E358866A722F03CC3C41487ADC604\
-A48FF54F5C6BEDB9FB7BD59F82D6E55D8F3174BA361B2214B2D74E8825E04E81
-
-10001:\
-D7103CD676E39824E2BE50B8E6533FE7CB7484348E283802AD2B8D00C80D19DF:\
-C89996DC169CEB3F227958275968804D4BE9FC4012C3219662F1A438C9950BB3:\
-74657374::\
-A7E00CE4391F914D82158D9B732759808E25A1C6383FE87A5199157650D4296C\
-F612E9FF809E686A0AF328238306E79965F6D0138138829D9A1A22764306F6CE
-
-11:\
-D255E2DEC6F7B4A61424CCDBAA356FAC0D29CA7912EC755AD4C72D8F4C4ADA5B\
-51790C518C074098C5CF97CF651AD8F5D2D3926BC16872D69DF533ADCF71251D:\
-DAF30344A35FE911419B2BFB9C8B461B57A1FAB11DA8451391357AEA6B81348F\
-5CCC4E23B38D3DBA82603CC52AA5F1BDC6F37015246F33CD02C3027F557A265D:\
-7730307421::\
-A372D1D551F9260896C2513932A0828748086C5AAE2E8B5DFADEA3250E9A8748\
-3C9DBA5D6F3513202510C2970624C1EFDE858C432DE7E50ADCDC7D639C30AE8D\
-9D3B6E521AAC286D8613223066559148E6B06EFCEF9799541447C468D6B49ABD\
-E9B51B14B34E475B3D04A6747DEB2CCAC5400D1032DD977C0A98D79A74EB38AE
-
-11:\
-BFE1C1173207E6E33F699074865B0C285CDB92A7973DD2DE1E10F525E845DDA0\
-2A2145CE553BC039DFEE68AA6826855F9DD8398820536BCF83EF422E2E75A93F:\
-C542F0BF4CB661A6D3B0FBC3952BC85BF7C8A13F81F3D66A78A39A1A4480A172\
-26B913A53D0AF44775D76E611030782BEFFD979C74BF3483A709FF1A58F140A7:\
-556E7265717569746564206C6F7665207375636B732E::\
-0B43E57A2A216D15795C2538ADFE794FF0D4342CE4F61D0D0A5E7F38A2968F9D\
-6A032DF4B772DC7E0AEE89B5BC829D3F0BBB05758F0B95A10CF8B26677862737\
-CC3277443E4B5D162182B326723E210A3E2D8E6E9BFDC7C935CA2BF4E57036A5\
-A83661AC1EACC4033E79FD2B9EC525623B1EBA9F13BD70822EEFD0EF443B0993
-
-10003:\
-C739CEC54F45D25B3B4D69D70CAE94F2B5299A406F4F045076ACD84687A59E8A\
-1AFBE7DBE229186EC588D12397E401CE51A42BEA67CB6B10C984C117E2CB876B:\
-D549FD1428B28FBFC7CFE760D16AD9E4BD6129AB407AD79D4B964F6362B78DDF\
-AF20C8EA51471CD49A5E329F49420571F3A6E30E781BEB80CEB1CD7E07F57D61:\
-49742773206D7920626972746864617920746F646179212053656E64206D6520\
-736F6D657468696E6721::\
-1EE0E873EE0EBF9DCFD452596D731936F8115BD3EFDFA2D1383CDCF04B97DCE6\
-ED35853C19ECBCADAE81E431BD31ACBF9E4CD709D2490E552853FD523D6C680E\
-C59A0E6E51DC0BBDC4E783608BACF3B6648931B5DCC2979D932652A42D9F0EFC\
-6B1E6AAA85C97BF5DF88736BBDAF33139B729FB0340C89CED70AD556097EBA0F
-
-10003:\
-BAE8E1ECE4B7E06903A894BCDB1E4B576D8C7719D23343814D6EA2B65E26EA06\
-ED68DAA07048917EA74B8A75B6DF6BB68060BE68F3C0594EF99DAD5CAF9C2A75:\
-F1C1AF40EBC0BBD628E105246AC61FBDFE7C926156D8A644F6297C758500DC4E\
-943B392014068978BEBB3ACDEB73358D1E1F035DB73D01BDCF0536928EBDE885:\
-49206D65616E206974212053656E64206D6520736F6D657468696E6721204E4F\
-5721203A29::\
-4D0AC8B75C4338C456533A431596339617955F786998BA05BFE41A4BE24AEBAD\
-DF92201340E076E7384BB8E211FBEC7662573C1F63915E3033CD6C351D7CDAB8\
-AED5F3458AFFEBEFAB21612BF742EE012674D04AAD37C592775A55D6F78C6674\
-DFC0F927303F486E82AFDAFE28A55660E91687FEC0CA2AEDDC83512BEADA05B2
-
-11:\
-FBBB490DE6F5F485B0A25B71394A393488AF8131B5391C8D3F99ADAB2B5B1F89\
-87B9556C5FBF2F85DD56BA0F9507C500787E07C88726476F56A07491CC4FB97F:\
-E1C5F70CC3DA03313682723C22241CEC93AAE0455B59501F4E6603E790A06083\
-3710E9CFBD2D8472E193C0B9433B2290CF303389B3CEED97CD1F5C934AFDCAF3:\
-57687920646F204920616C7761797320656E64207570206C696B696E67206769\
-726C7320696E206C6F6E672D7465726D2072656C6174696F6E73686970733F::\
-4AE5B5600003871EDF01BC589DBDE5F5F8B558AF6F286D09572555FB4D34F640\
-173F0D17AEB67E18D05CD598595C78AA4E1246DDB0D311F38E3E21C02241F4F5\
-542B872DA50ADFE17407DC115C14DCB35847C3AFF8914967D8714B89CECC5745\
-C353D9831AE5B2C666A3077D5AC1131160AA59113193278587308D3E5BAED895
-
-3:\
-B6E4B50A4B61F147CC30C319CCEBEA1BB8151EE3012BFD2C80E8B13DBAE1657E\
-7AED914E80A26A4D1FCAFED54BF4457D609A33C6AE7631DE9A310E3EFD4353F1:\
-B841BF00069AE6F05A68CB11FF5E6389ED0C8AC9D2DBDD24CF0E0076B05FC226\
-E771C0D06C220908A559E5BF6626537B265B8D9C50E05E214724155F1C14A7E1:\
-4920616D20736F20677265617421204920616D20736F2067726561742120::\
-24D98B51D0419DD3D987D7E51528F571790AC78D2C80F36F64C7B4E05D90239E\
-8A5D9D7F46D636741B9F9A1DA58E58002D268A814528A4BF6B0AEE3B8EFEF0BD\
-72C956E4895FAA28E3EBD13E7EFD46A7BDFC3872D220EF4A2455E6CCCC407411\
-C2274D7F2BEDF4A727B569BFAE999F910BF69F5689DB7686328F97DED76C64E5
-
-7:\
-1343E65E7C11BE13536BB8BB569AAF091119ADE46FDCA9AE627910A39F9F909B\
-F921EDD9AB862813AA5AA5969620FD97ABD051352C89A336E420D1BCFB37A9CDF:\
-10A76D6261BE5FB018492566D9819028CA13B55A982C8A2A7CA31520124AB832\
-0F583BD5003F0E800775664DE2718481C15C841888350BF980D8F3EC017B9D851:\
-4920616D20736F20677265617421204920616D20736F20677265617421202831\
-3032352062697429::\
-0069212B4D49B93D56DBFD35534686BC4CE5EF057D3E5EB08E38C0CAC44A33C8\
-1ACF7E54ACB2F7D7029F63778B55D63C31E0FEBED8AF57050EC46E7C6B857112\
-B8A1FA0B4D5C11F976D01B5F56EBF55C678393CECFC801E51D6040A3631A0E77\
-56F9E81E2FF7A03E1B8A20F7DFAE90CF631043029AFFE3F615A54EA68ED470B393
-
-3:\
-1F16A49C815B9878A399B22419F0D948B33E8D7367A9F5928ED63146FEA7C69F\
-6C8A0EACA711970E370FB87CA3CCCDA71E1DBA9A12DBC003ED79F545876BFDA7D:\
-1F5C7840900C1C2E18340C156F8BE4EE70A4A0603412E689602C93B09FDD205E\
-23A775E7E1EAD3078EF9D5487D8A2EA5BABE8EE94AA0536CBA268B3BE7AD4B519:\
-4920616D20736F20677265617421204920616D20736F20677265617421202831\
-3032362062697429::\
-030551DE7296296876189AC2155EA4F80B3A68EF2A51F926494821E038A52548\
-4BDCA8CC4525D4BD04BEE373313D79DFEC59E22F21FB853C688FF9DA4CDCF6D1\
-2255BECED6DF3EFDED6046D4381D69B89EF17B892685707AE7B49E2205D95F73\
-0A1A003638FBCDDE5F4A5AEB028252F46195DB3CA1C708AAE22ACA7687B0DD2401
-
-7:\
-2037B35FDD14FACFA8B6DC8F48EC575F43CE8E2B5B89375A6FDDE1CFB66DACB9\
-8D7C57CE0F025BC7DD15533233AFCCBF392C0CB9DD79F49334D31F1FC0D17465D:\
-21265626E63E26739C0D086C3F19D7C8DA5B2FCD1452CE5290FF16F80AE6CDC3\
-49722661765B5AE418F23FBDAE4048C4FBB845822B2264C012ED6A8A257365F69:\
-4920616D20736F20677265617421204920616D20736F20677265617421202831\
-3032372062697429::\
-0090FD2E6B167F5B8E68AD965C170F87E2DDC69BA9312DE03B79018C90A80BF1\
-67704999C1A1B8AD31041428DBFE74FD89B398F5682F252DE85E19F33830CA2B\
-B775966C01EFCD6F95A5334DCEF07A0DF1F1114C21FEAA03D619EBCA60010F47\
-F671C35D754BD63DD5045E45CA21F7CB15FE2731AB27D91162D52320A540B17AE1
-
-# These are (some of) the official RSADSI PSS test vectors,
-# plus a few specially constructed ones at the end
-[RSASSA/EMSA4(SHA-1)]
-10001:\
-E7E8942720A877517273A356053EA2A1BC0C94AA72D55C6E86296B2DFC967948\
-C0A72CBCCCA7EACB35706E09A1DF55A1535BD9B3CC34160B3B6DCD3EDA8E6443:\
-B69DCA1CF7D4D7EC81E75B90FCCA874ABCDE123FD2700180AA90479B6E48DE8D\
-67ED24F9F19D85BA275874F542CD20DC723E6963364A1F9425452B269A6799FD:\
-10AAE9A0AB0B595D0841207B700D48D75FAEDDE3B775CD6B4CC88AE06E4694EC\
-74BA18F8520D4F5EA69CBBE7CC2BEBA43EFDC10215AC4EB32DC302A1F53DC6C4\
-352267E7936CFEBF7C8D67035784A3909FA859C7B7B59B8E39C5C2349F1886B7\
-05A30267D402F7486AB4F58CAD5D69ADB17AB8CD0CE1CAF5025AF4AE24B1FB87\
-94C6070CC09A51E2F9911311E3877D0044C71C57A993395008806B723AC38373\
-D395481818528C1E7053739282053529510E935CD0FA77B8FA53CC2D474BD4FB\
-3CC5C672D6FFDC90A00F9848712C4BCFE46C60573659B11E6457E861F0F604B6\
-138D144F8CE4E2DA73:A8AB69DD801F0074C2A1FC60649836C616D99681:\
-2A34F6125E1F6B0BF971E84FBD41C632BE8F2C2ACE7DE8B6926E31FF93E9AF98\
-7FBC06E51E9BE14F5198F91F3F953BD67DA60A9DF59764C3DC0FE08E1CBEF0B7\
-5F868D10AD3FBA749FEF59FB6DAC46A0D6E504369331586F58E4628F39AA2789\
-82543BC0EEB537DC61958019B394FB273F215858A0A01AC4D650B955C67F4C58
-
-10001:\
-D17F655BF27C8B16D35462C905CC04A26F37E2A67FA9C0CE0DCED472394A0DF7\
-43FE7F929E378EFDB368EDDFF453CF007AF6D948E0ADE757371F8A711E278F6B:\
-C6D92B6FEE7414D1358CE1546FB62987530B90BD15E0F14963A5E2635ADB6934\
-7EC0C01B2AB1763FD8AC1A592FB22757463A982425BB97A3A437C5BF86D03F2F:\
-859EEF2FD78ACA00308BDC471193BF55BF9D78DB8F8A672B484634F3C9C26E6478AE1026\
-0FE0DD8C082E53A5293AF2173CD50C6D5D354FEBF78B26021C25C02712E78CD4694C9F46\
-9777E451E7F8E9E04CD3739C6BBFEDAE487FB55644E9CA74FF77A53CB729802F6ED4A5FF\
-A8BA159890FC:E3B5D5D002C1BCE50C2B65EF88A188D83BCE7E61:\
-8DAA627D3DE7595D63056C7EC659E54406F10610128BAAE821C8B2A0F3936D54DC3BDCE4\
-6689F6B7951BB18E840542769718D5715D210D85EFBB596192032C42BE4C29972C856275\
-EB6D5A45F05F51876FC6743DEDDD28CAEC9BB30EA99E02C3488269604FE497F74CCD7C7F\
-CA1671897123CBD30DEF5D54A2B5536AD90A747E
-
-10001:\
-E7E8942720A877517273A356053EA2A1BC0C94AA72D55C6E86296B2DFC967948\
-C0A72CBCCCA7EACB35706E09A1DF55A1535BD9B3CC34160B3B6DCD3EDA8E6443:\
-B69DCA1CF7D4D7EC81E75B90FCCA874ABCDE123FD2700180AA90479B6E48DE8D\
-67ED24F9F19D85BA275874F542CD20DC723E6963364A1F9425452B269A6799FD:\
-BC656747FA9EAFB3F0:056F00985DE14D8EF5CEA9E82F8C27BEF720335E:\
-4609793B23E9D09362DC21BB47DA0B4F3A7622649A47D464019B9AEAFE53359C\
-178C91CD58BA6BCB78BE0346A7BC637F4B873D4BAB38EE661F199634C547A1AD\
-8442E03DA015B136E543F7AB07C0C13E4225B8DE8CCE25D4F6EB8400F81F7E18\
-33B7EE6E334D370964CA79FDB872B4D75223B5EEB08101591FB532D155A6DE87
-
-10001:\
-016601E926A0F8C9E26ECAB769EA65A5E7C52CC9E080EF519457C644DA6891C5A1\
-04D3EA7955929A22E7C68A7AF9FCAD777C3CCC2B9E3D3650BCE404399B7E59D1:\
-014EAFA1D4D0184DA7E31F877D1281DDDA625664869E8379E67AD3B75EAE74A580\
-E9827ABD6EB7A002CB5411F5266797768FB8E95AE40E3E8A01F35FF89E56C079:\
-DABA032066263FAEDB659848115278A52C44FAA3A76F37515ED336321072C40A\
-9D9B53BC05014078ADF520875146AAE70FF060226DCB7B1F1FC27E9360:\
-57BF160BCB02BB1DC7280CF0458530B7D2832FF7:\
-014C5BA5338328CCC6E7A90BF1C0AB3FD606FF4796D3C12E4B639ED9136A5FEC\
-6C16D8884BDD99CFDC521456B0742B736868CF90DE099ADB8D5FFD1DEFF39BA4\
-007AB746CEFDB22D7DF0E225F54627DC65466131721B90AF445363A8358B9F60\
-7642F78FAB0AB0F43B7168D64BAE70D8827848D8EF1E421C5754DDF42C2589B5B3
-
-10001:\
-016601E926A0F8C9E26ECAB769EA65A5E7C52CC9E080EF519457C644DA6891C5A1\
-04D3EA7955929A22E7C68A7AF9FCAD777C3CCC2B9E3D3650BCE404399B7E59D1:\
-014EAFA1D4D0184DA7E31F877D1281DDDA625664869E8379E67AD3B75EAE74A580\
-E9827ABD6EB7A002CB5411F5266797768FB8E95AE40E3E8A01F35FF89E56C079:\
-52A1D96C8AC39E41E455809801B927A5B445C10D902A0DCD3850D22A66D2BB07\
-03E67D5867114595AABF5A7AEB5A8F87034BBB30E13CFD4817A9BE7623002360\
-6D0286A3FAF8A4D22B728EC518079F9E64526E3A0CC7941AA338C437997C680C\
-CAC67C66BFA1:FCA862068BCE2246724B708A0519DA17E648688C:\
-007F0030018F53CDC71F23D03659FDE54D4241F758A750B42F185F87578520C3\
-0742AFD84359B6E6E8D3ED959DC6FE486BEDC8E2CF001F63A7ABE16256A1B84D\
-F0D249FC05D3194CE5F0912742DBBF80DD174F6C51F6BAD7F16CF3364EBA095A\
-06267DC3793803AC7526AEBE0A475D38B8C2247AB51C4898DF7047DC6ADF52C6C4
-
-10001:\
-01BD36E18ECE4B0FDB2E9C9D548BD1A7D6E2C21C6FDC35074A1D05B1C6C8B3D5\
-58EA2639C9A9A421680169317252558BD148AD215AAC550E2DCF12A82D0EBFE853:\
-01B1B656AD86D8E19D5DC86292B3A192FDF6E0DD37877BAD14822FA00190CAB2\
-65F90D3F02057B6F54D6ECB14491E5ADEACEBC48BF0EBD2A2AD26D402E54F61651:\
-594B37333BBB2C84524A87C1A01F75FCEC0E3256F108E38DCA36D70D0057:\
-F31AD6C8CF89DF78ED77FEACBCC2F8B0A8E4CFAA:\
-0088B135FB1794B6B96C4A3E678197F8CAC52B64B2FE907D6F27DE761124964A\
-99A01A882740ECFAED6C01A47464BB05182313C01338A8CD097214CD68CA103B\
-D57D3BC9E816213E61D784F182467ABF8A01CF253E99A156EAA8E3E1F90E3C6E\
-4E3AA2D83ED0345B89FAFC9C26077C14B6AC51454FA26E446E3A2F153B2B16797F
-
-10001:\
-01BD36E18ECE4B0FDB2E9C9D548BD1A7D6E2C21C6FDC35074A1D05B1C6C8B3D5\
-58EA2639C9A9A421680169317252558BD148AD215AAC550E2DCF12A82D0EBFE853:\
-01B1B656AD86D8E19D5DC86292B3A192FDF6E0DD37877BAD14822FA00190CAB2\
-65F90D3F02057B6F54D6ECB14491E5ADEACEBC48BF0EBD2A2AD26D402E54F61651:\
-8B769528884A0D1FFD090CF102993E796DADCFBDDD38E44FF6324CA451:\
-FCF9F0E1F199A3D1D0DA681C5B8606FC642939F7:\
-02A5F0A858A0864A4F65017A7D69454F3F973A2999839B7BBC48BF7864116917\
-9556F595FA41F6FF18E286C2783079BC0910EE9CC34F49BA681124F923DFA88F\
-426141A368A5F5A930C628C2C3C200E18A7644721A0CBEC6DD3F6279BDE3E8F2\
-BE5E2D4EE56F97E7CEAF33054BE7042BD91A63BB09F897BD41E81197DEE99B11AF
-
-10001:\
-01BD36E18ECE4B0FDB2E9C9D548BD1A7D6E2C21C6FDC35074A1D05B1C6C8B3D5\
-58EA2639C9A9A421680169317252558BD148AD215AAC550E2DCF12A82D0EBFE853:\
-01B1B656AD86D8E19D5DC86292B3A192FDF6E0DD37877BAD14822FA00190CAB2\
-65F90D3F02057B6F54D6ECB14491E5ADEACEBC48BF0EBD2A2AD26D402E54F61651:\
-1ABDBA489C5ADA2F995ED16F19D5A94D9E6EC34A8D84F84557D26E5EF9B02B22\
-887E3F9A4B690AD1149209C20C61431F0C017C36C2657B35D7B07D3F5AD87085\
-07A9C1B831DF835A56F831071814EA5D3D8D8F6ADE40CBA38B42DB7A2D3D7A29\
-C8F0A79A7838CF58A9757FA2FE4C40DF9BAA193BFC6F92B123AD57B07ACE3E6A\
-C068C9F106AFD9EEB03B4F37C25DBFBCFB3071F6F9771766D072F3BB070AF660\
-5532973AE25051:986E7C43DBB671BD41B9A7F4B6AFC80E805F2423:\
-0244BCD1C8C16955736C803BE401272E18CB990811B14F72DB964124D5FA7606\
-49CBB57AFB8755DBB62BF51F466CF23A0A1607576E983D778FCEFFA92DF7548A\
-EA8EA4ECAD2C29DD9F95BC07FE91ECF8BEE255BFE8762FD7690AA9BFA4FA0849\
-EF728C2C42C4532364522DF2AB7F9F8A03B63F7A499175828668F5EF5A29E3802C
-
-10001:\
-01BD36E18ECE4B0FDB2E9C9D548BD1A7D6E2C21C6FDC35074A1D05B1C6C8B3D5\
-58EA2639C9A9A421680169317252558BD148AD215AAC550E2DCF12A82D0EBFE853:\
-01B1B656AD86D8E19D5DC86292B3A192FDF6E0DD37877BAD14822FA00190CAB2\
-65F90D3F02057B6F54D6ECB14491E5ADEACEBC48BF0EBD2A2AD26D402E54F61651:\
-8FB431F5EE792B6C2AC7DB53CC428655AEB32D03F4E889C5C25DE683C461B53A\
-CF89F9F8D3AABDF6B9F0C2A1DE12E15B49EDB3919A652FE9491C25A7FCE1F722\
-C2543608B69DC375EC:F8312D9C8EEA13EC0A4C7B98120C87509087C478:\
-0196F12A005B98129C8DF13C4CB16F8AA887D3C40D96DF3A88E7532EF39CD992\
-F273ABC370BC1BE6F097CFEBBF0118FD9EF4B927155F3DF22B904D90702D1F7B\
-A7A52BED8B8942F412CD7BD676C9D18E170391DCD345C06A730964B3F30BCCE0\
-BB20BA106F9AB0EEB39CF8A6607F75C0347F0AF79F16AFA081D2C92D1EE6F836B8
-
-10001:\
-01BD36E18ECE4B0FDB2E9C9D548BD1A7D6E2C21C6FDC35074A1D05B1C6C8B3D5\
-58EA2639C9A9A421680169317252558BD148AD215AAC550E2DCF12A82D0EBFE853:\
-01B1B656AD86D8E19D5DC86292B3A192FDF6E0DD37877BAD14822FA00190CAB2\
-65F90D3F02057B6F54D6ECB14491E5ADEACEBC48BF0EBD2A2AD26D402E54F61651:\
-FEF4161DFAAF9C5295051DFC1FF3810C8C9EC2E866F7075422C8EC4216A9C4FF\
-49427D483CAE10C8534A41B2FD15FEE06960EC6FB3F7A7E94A2F8A2E3E43DC4A\
-40576C3097AC953B1DE86F0B4ED36D644F23AE14425529622464CA0CBF0B1741\
-347238157FAB59E4DE5524096D62BAEC63AC64:\
-50327EFEC6292F98019FC67A2A6638563E9B6E2D:\
-021ECA3AB4892264EC22411A752D92221076D4E01C0E6F0DDE9AFD26BA5ACF6D\
-739EF987545D16683E5674C9E70F1DE649D7E61D48D0CAEB4FB4D8B24FBA84A6\
-E3108FEE7D0705973266AC524B4AD280F7AE17DC59D96D3351586B5A3BDB895D\
-1E1F7820AC6135D8753480998382BA32B7349559608C38745290A85EF4E9F9BD83
-
-10001:\
-01BD36E18ECE4B0FDB2E9C9D548BD1A7D6E2C21C6FDC35074A1D05B1C6C8B3D5\
-58EA2639C9A9A421680169317252558BD148AD215AAC550E2DCF12A82D0EBFE853:\
-01B1B656AD86D8E19D5DC86292B3A192FDF6E0DD37877BAD14822FA00190CAB2\
-65F90D3F02057B6F54D6ECB14491E5ADEACEBC48BF0EBD2A2AD26D402E54F61651:\
-EFD237BB098A443AEEB2BF6C3F8C81B8C01B7FCB3FEB:\
-B0DE3FC25B65F5AF96B1D5CC3B27D0C6053087B3:\
-012FAFEC862F56E9E92F60AB0C77824F4299A0CA734ED26E0644D5D222C7F0BD\
-E03964F8E70A5CB65ED44E44D56AE0EDF1FF86CA032CC5DD4404DBB76AB85458\
-6C44EED8336D08D457CE6C03693B45C0F1EFEF93624B95B8EC169C616D20E553\
-8EBC0B6737A6F82B4BC0570924FC6B35759A3348426279F8B3D7744E2D222426CE
-
-10001:\
-029232336D2838945DBA9DD7723F4E624A05F7375B927A87ABE6A893A1658FD4\
-9F47F6C7B0FA596C65FA68A23F0AB432962D18D4343BD6FD671A5EA8D148413995:\
-020EF5EFE7C5394AED2272F7E81A74F4C02D145894CB1B3CAB23A9A0710A2AFC\
-7E3329ACBB743D01F680C4D02AFB4C8FDE7E20930811BB2B995788B5E872C20BB1:\
-9FB03B827C8217D9:ED7C98C95F30974FBE4FBDDCF0F28D6021C0E91D:\
-0323D5B7BF20BA4539289AE452AE4297080FEFF4518423FF4811A817837E7D82\
-F1836CDFAB54514FF0887BDDEEBF40BF99B047ABC3ECFA6A37A3EF00F4A0C4A8\
-8AAE0904B745C846C4107E8797723E8AC810D9E3D95DFA30FF4966F4D75D1376\
-8D20857F2B1406F264CFE75E27D7652F4B5ED3575F28A702F8C4ED9CF9B2D44948
-
-10001:\
-029232336D2838945DBA9DD7723F4E624A05F7375B927A87ABE6A893A1658FD4\
-9F47F6C7B0FA596C65FA68A23F0AB432962D18D4343BD6FD671A5EA8D148413995:\
-020EF5EFE7C5394AED2272F7E81A74F4C02D145894CB1B3CAB23A9A0710A2AFC\
-7E3329ACBB743D01F680C4D02AFB4C8FDE7E20930811BB2B995788B5E872C20BB1:\
-0CA2AD77797ECE86DE5BF768750DDB5ED6A3116AD99BBD17EDF7F782F0DB1CD0\
-5B0F677468C5EA420DC116B10E80D110DE2B0461EA14A38BE68620392E7E893C\
-B4EA9393FB886C20FF790642305BF302003892E54DF9F667509DC53920DF583F\
-50A3DD61ABB6FAB75D600377E383E6ACA6710EEEA27156E06752C94CE25AE99F\
-CBF8592DBE2D7E27453CB44DE07100EBB1A2A19811A478ADBEAB270F94E8FE36\
-9D90B3CA612F9F:22D71D54363A4217AA55113F059B3384E3E57E44:\
-049D0185845A264D28FEB1E69EDAEC090609E8E46D93ABB38371CE51F4AA65A5\
-99BDAAA81D24FBA66A08A116CB644F3F1E653D95C89DB8BBD5DAAC2709C89840\
-00178410A7C6AA8667DDC38C741F710EC8665AA9052BE929D4E3B16782C16621\
-14C5414BB0353455C392FC28F3DB59054B5F365C49E1D156F876EE10CB4FD70598
-
-10001:\
-029232336D2838945DBA9DD7723F4E624A05F7375B927A87ABE6A893A1658FD4\
-9F47F6C7B0FA596C65FA68A23F0AB432962D18D4343BD6FD671A5EA8D148413995:\
-020EF5EFE7C5394AED2272F7E81A74F4C02D145894CB1B3CAB23A9A0710A2AFC\
-7E3329ACBB743D01F680C4D02AFB4C8FDE7E20930811BB2B995788B5E872C20BB1:\
-288062AFC08FCDB7C5F8650B29837300461DD5676C17A20A3C8FB5148949E3F7\
-3D66B3AE82C7240E27C5B3EC4328EE7D6DDF6A6A0C9B5B15BCDA196A9D0C76B1\
-19D534D85ABD123962D583B76CE9D180BCE1CA:\
-4AF870FBC6516012CA916C70BA862AC7E8243617:\
-03FBC410A2CED59500FB99F9E2AF2781ADA74E13145624602782E2994813EEFC\
-A0519ECD253B855FB626A90D771EAE028B0C47A199CBD9F8E3269734AF416359\
-9090713A3FA910FA0960652721432B971036A7181A2BC0CAB43B0B598BC62174\
-61D7DB305FF7E954C5B5BB231C39E791AF6BCFA76B147B081321F72641482A2AAD
-
-10001:\
-029232336D2838945DBA9DD7723F4E624A05F7375B927A87ABE6A893A1658FD4\
-9F47F6C7B0FA596C65FA68A23F0AB432962D18D4343BD6FD671A5EA8D148413995:\
-020EF5EFE7C5394AED2272F7E81A74F4C02D145894CB1B3CAB23A9A0710A2AFC\
-7E3329ACBB743D01F680C4D02AFB4C8FDE7E20930811BB2B995788B5E872C20BB1:\
-6F4F9AB9501199CEF55C6CF408FE7B36C557C49D420A4763D2463C8AD44B3CFC\
-5BE2742C0E7D9B0F6608F08C7F47B693EE:\
-40D2E180FAE1EAC439C190B56C2C0E14DDF9A226:\
-0486644BC66BF75D28335A6179B10851F43F09BDED9FAC1AF33252BB9953BA42\
-98CD6466B27539A70ADAA3F89B3DB3C74AB635D122F4EE7CE557A61E59B82FFB\
-786630E5F9DB53C77D9A0C12FAB5958D4C2CE7DAA807CD89BA2CC7FCD02FF470\
-CA67B229FCCE814C852C73CC93BEA35BE68459CE478E9D4655D121C8472F371D4F
-
-10001:\
-029232336D2838945DBA9DD7723F4E624A05F7375B927A87ABE6A893A1658FD4\
-9F47F6C7B0FA596C65FA68A23F0AB432962D18D4343BD6FD671A5EA8D148413995:\
-020EF5EFE7C5394AED2272F7E81A74F4C02D145894CB1B3CAB23A9A0710A2AFC\
-7E3329ACBB743D01F680C4D02AFB4C8FDE7E20930811BB2B995788B5E872C20BB1:\
-E17D20385D501955823C3F666254C1D3DD36AD5168B8F18D286FDCF67A7DAD94\
-097085FAB7ED86FE2142A28771717997EF1A7A08884EFC39356D76077AAF8245\
-9A7FAD45848875F2819B098937FE923BCC9DC442D72D754D812025090C9BC03D\
-B3080C138DD63B355D0B4B85D6688AC19F4DE15084A0BA4E373B93EF4A555096\
-691915DC23C00E954CDEB20A47CD55D16C3D8681D46ED7F2ED5EA42795BE17BA\
-ED25F0F4D113B3636ADDD585F16A8B5AEC0C8FA9C5F03CBF3B9B73:\
-2497DC2B4615DFAE5A663D49FFD56BF7EFC11304:\
-022A80045353904CB30CBB542D7D4990421A6EEC16A8029A8422ADFD22D6AFF8\
-C4CC0294AF110A0C067EC86A7D364134459BB1AE8FF836D5A8A2579840996B32\
-0B19F13A13FAD378D931A65625DAE2739F0C53670B35D9D3CBAC08E733E4EC2B\
-83AF4B9196D63E7C4FF1DDEAE2A122791A125BFEA8DEB0DE8CCF1F4FFAF6E6FB0A
-
-10001:\
-029232336D2838945DBA9DD7723F4E624A05F7375B927A87ABE6A893A1658FD4\
-9F47F6C7B0FA596C65FA68A23F0AB432962D18D4343BD6FD671A5EA8D148413995:\
-020EF5EFE7C5394AED2272F7E81A74F4C02D145894CB1B3CAB23A9A0710A2AFC\
-7E3329ACBB743D01F680C4D02AFB4C8FDE7E20930811BB2B995788B5E872C20BB1:\
-AFBC19D479249018FDF4E09F618726440495DE11DDEEE38872D775FCEA74A238\
-96B5343C9C38D46AF0DBA224D047580CC60A65E9391CF9B59B36A860598D4E82\
-16722F993B91CFAE87BC255AF89A6A199BCA4A391EADBC3A24903C0BD667368F\
-6BE78E3FEABFB4FFD463122763740FFBBEFEAB9A25564BC5D1C24C93E422F750\
-73E2AD72BF45B10DF00B52A147128E73FEE33FA3F0577D77F80FBC2DF1BED313\
-290C12777F50:A334DB6FAEBF11081A04F87C2D621CDEC7930B9B:\
-00938DCB6D583046065F69C78DA7A1F1757066A7FA75125A9D2929F0B79A60B6\
-27B082F11F5B196F28EB9DAA6F21C05E5140F6AEF1737D2023075C05ECF04A02\
-8C686A2AB3E7D5A0664F295CE12995E890908B6AD21F0839EB65B70393A7B5AF\
-D9871DE0CAA0CEDEC5B819626756209D13AB1E7BB9546A26FF37E9A51AF9FD562E
-
-10001:\
-03F2F331F4142D4F24B43AA10279A89652D4E7537221A1A7B2A25DEB551E5DE9\
-AC497411C227A94E45F91C2D1C13CC046CF4CE14E32D058734210D44A87EE1B73F:\
-034F090D73B55803030CF0361A5D8081BFB79F851523FEAC0A2124D08D4013FF\
-08487771A870D0479DC0686C62F7718DFECF024B17C9267678059171339CC00839:\
-30C7D557458B436DECFDC14D06CB7B96B06718C48D7DE57482A868AE7F065870\
-A6216506D11B779323DFDF046CF5775129134B4D5689E4D9C0CE1E12D7D4B06C\
-B5FC5820DECFA41BAF59BF257B32F025B7679B445B9499C92555145885992F1B\
-76F84891EE4D3BE0F5150FD5901E3A4C8ED43FD36B61D022E65AD5008DBF3329\
-3C22BFBFD07321F0F1D5FA9FDF0014C2FCB0358AAD0E354B0D29:\
-081B233B43567750BD6E78F396A88B9F6A445151:\
-0BA373F76E0921B70A8FBFE622F0BF77B28A3DB98E361051C3D7CB92AD045291\
-5A4DE9C01722F6823EEB6ADF7E0CA8290F5DE3E549890AC2A3C5950AB217BA58\
-590894952DE96F8DF111B2575215DA6C161590C745BE612476EE578ED384AB33\
-E3ECE97481A252F5C79A98B5532AE00CDD62F2ECC0CD1BAEFE80D80B962193EC1D
-
-10001:\
-03F2F331F4142D4F24B43AA10279A89652D4E7537221A1A7B2A25DEB551E5DE9\
-AC497411C227A94E45F91C2D1C13CC046CF4CE14E32D058734210D44A87EE1B73F:\
-034F090D73B55803030CF0361A5D8081BFB79F851523FEAC0A2124D08D4013FF\
-08487771A870D0479DC0686C62F7718DFECF024B17C9267678059171339CC00839:\
-328C659E0A6437433CCEB73C14:\
-9AEC4A7480D5BBC42920D7CA235DB674989C9AAC:\
-0BC989853BC2EA86873271CE183A923AB65E8A53100E6DF5D87A24C4194EB797\
-813EE2A187C097DD872D591DA60C568605DD7E742D5AF4E33B11678CCB639032\
-04A3D080B0902C89ABA8868F009C0F1C0CB85810BBDD29121ABB8471FF2D39E4\
-9FD92D56C655C8E037AD18FAFBDC92C95863F7F61EA9EFA28FEA401369D19DAEA1
-
-10001:\
-04F0548C9626AB1EBF1244934741D99A06220EFA2A5856AA0E75730B2EC96ADC\
-86BE894FA2803B53A5E85D276ACBD29AB823F80A7391BB54A5051672FB04EEB543:\
-0483E0AE47915587743FF345362B555D3962D98BB6F15F848B4C92B1771CA8ED\
-107D8D3EE65EC44517DD0FAA481A387E902F7A2E747C269E7EA44480BC538B8E5B:\
-0F6195D04A6E6FC7E2C9600DBF840C39EA8D4D624FD53507016B0E26858A5E0A\
-ECD7ADA543AE5C0AB3A62599CBA0A54E6BF446E262F989978F9DDF5E9A41:\
-A87B8AED07D7B8E2DAF14DDCA4AC68C4D0AABFF8:\
-086DF6B500098C120F24FF8423F727D9C61A5C9007D3B6A31CE7CF8F3CBEC1A2\
-6BB20E2BD4A046793299E03E37A21B40194FB045F90B18BF20A47992CCD799CF\
-9C059C299C0526854954AADE8A6AD9D97EC91A1145383F42468B231F4D72F237\
-06D9853C3FA43CE8ACE8BFE7484987A1EC6A16C8DAF81F7C8BF42774707A9DF456
-
-10001:\
-04F0548C9626AB1EBF1244934741D99A06220EFA2A5856AA0E75730B2EC96ADC\
-86BE894FA2803B53A5E85D276ACBD29AB823F80A7391BB54A5051672FB04EEB543:\
-0483E0AE47915587743FF345362B555D3962D98BB6F15F848B4C92B1771CA8ED\
-107D8D3EE65EC44517DD0FAA481A387E902F7A2E747C269E7EA44480BC538B8E5B:\
-9906D89F97A9FDEDD3CCD824DB687326F30F00AA25A7FCA2AFCB3B0F86CD41E7\
-3F0E8FF7D2D83F59E28ED31A5A0D551523374DE22E4C7E8FF568B386EE3DC411\
-63F10BF67BB006261C9082F9AF90BF1D9049A6B9FAE71C7F84FBE6E55F02789D\
-E774F230F115026A4B4E96C55B04A95DA3AACBB2CECE8F81764A1F1C99515411\
-087CF7D34AEDED0932C183:FBBE059025B69B89FB14AE2289E7AAAFE60C0FCD:\
-0A40A16E2FE2B38D1DF90546167CF9469C9E3C3681A3442B4B2C2F581DEB385C\
-E99FC6188BB02A841D56E76D301891E24560550FCC2A26B55F4CCB26D837D350\
-A154BCACA8392D98FA67959E9727B78CAD03269F56968FC56B68BD679926D83C\
-C9CB215550645CCDA31C760FF35888943D2D8A1D351E81E5D07B86182E751081EF
-
-10001:\
-07EEFB424B0E3A40E4208EE5AFB280B22317308114DDE0B4B64F730184EC68DA\
-6CE2867A9F48ED7726D5E2614ED04A5410736C8C714EE702474298C6292AF07535:\
-070830DBF947EAC0228DE26314B59B66994CC60E8360E75D3876298F8F8A7D14\
-1DA064E5CA026A973E28F254738CEE669C721B034CB5F8E244DADD7CD1E159D547:\
-8D80D2D08DBD19C154DF3F14673A14BD03735231F24E86BF153D0E69E74CBFF7\
-B1836E664DE83F680124370FC0F96C9B65C07A366B644C4AB3:\
-0C09582266DF086310821BA7E18DF64DFEE6DE09:\
-10FD89768A60A67788ABB5856A787C8561F3EDCF9A83E898F7DC87AB8CCE7942\
-9B43E56906941A886194F137E591FE7C339555361FBBE1F24FEB2D4BCDB80601\
-F3096BC9132DEEA60AE13082F44F9AD41CD628936A4D51176E42FC59CB76DB81\
-5CE5AB4DB99A104AAFEA68F5D330329EBF258D4EDE16064BD1D00393D5E1570EB8
-
-10001:\
-07EEFB424B0E3A40E4208EE5AFB280B22317308114DDE0B4B64F730184EC68DA\
-6CE2867A9F48ED7726D5E2614ED04A5410736C8C714EE702474298C6292AF07535:\
-070830DBF947EAC0228DE26314B59B66994CC60E8360E75D3876298F8F8A7D14\
-1DA064E5CA026A973E28F254738CEE669C721B034CB5F8E244DADD7CD1E159D547:\
-45013CEBAFD960B255476A8E2598B9AA32EFBE6DC1F34F4A498D8CF5A2B4548D\
-08C55D5F95F7BCC9619163056F2D58B52FA032:\
-9D5AD8EB452134B65DC3A98B6A73B5F741609CD6:\
-07EB651D75F1B52BC263B2E198336E99FBEBC4F332049A922A10815607EE2D98\
-9DB3A4495B7DCCD38F58A211FB7E193171A3D891132437EBCA44F318B280509E\
-52B5FA98FCCE8205D9697C8EE4B7FF59D4C59C79038A1970BD2A0D451ECDC5EF\
-11D9979C9D35F8C70A6163717607890D586A7C6DC01C79F86A8F28E85235F8C2F1
-
-10001:\
-08DAD7F11363FAA623D5D6D5E8A319328D82190D7127D2846C439B0AB72619B0\
-A43A95320E4EC34FC3A9CEA876422305BD76C5BA7BE9E2F410C8060645A1D29EDB:\
-0847E732376FC7900F898EA82EB2B0FC418565FDAE62F7D9EC4CE2217B97990D\
-D272DB157F99F63C0DCBB9FBACDBD4C4DADB6DF67756358CA4174825B48F49706D:\
-E2F96EAF0E05E7BA326ECCA0BA7FD2F7C02356F3CEDE9D0FAABF4FCC8E60A973\
-E5595FD9EA08:435C098AA9909EB2377F1248B091B68987FF1838:\
-2707B9AD5115C58C94E932E8EC0A280F56339E44A1B58D4DDCFF2F312E5F34DC\
-FE39E89C6A94DCEE86DBBDAE5B79BA4E0819A9E7BFD9D982E7EE6C86EE68396E\
-8B3A14C9C8F34B178EB741F9D3F121109BF5C8172FADA2E768F9EA1433032C00\
-4A8AA07EB990000A48DC94C8BAC8AABE2B09B1AA46C0A2AA0E12F63FBBA775BA7E
-
-10001:\
-08DAD7F11363FAA623D5D6D5E8A319328D82190D7127D2846C439B0AB72619B0\
-A43A95320E4EC34FC3A9CEA876422305BD76C5BA7BE9E2F410C8060645A1D29EDB:\
-0847E732376FC7900F898EA82EB2B0FC418565FDAE62F7D9EC4CE2217B97990D\
-D272DB157F99F63C0DCBB9FBACDBD4C4DADB6DF67756358CA4174825B48F49706D:\
-04DC251BE72E88E5723485B6383A637E2FEFE07660C519A560B8BC18BDEDB86E\
-AE2364EA53BA9DCA6EB3D2E7D6B806AF42B3E87F291B4A8881D5BF572CC9A85E\
-19C86ACB28F098F9DA0383C566D3C0F58CFD8F395DCF602E5CD40E8C7183F714\
-996E2297EF:C558D7167CBB4508ADA042971E71B1377EEA4269:\
-33341BA3576A130A50E2A5CF8679224388D5693F5ACCC235AC95ADD68E5EB1EE\
-C31666D0CA7A1CDA6F70A1AA762C05752A51950CDB8AF3C5379F18CFE6B5BC55\
-A4648226A15E912EF19AD77ADEEA911D67CFEFD69BA43FA4119135FF642117BA\
-985A7E0100325E9519F1CA6A9216BDA055B5785015291125E90DCD07A2CA9673EE
-
-10001:\
-CFD50283FEEEB97F6F08D73CBC7B3836F82BBCD499479F5E6F76FDFCB8B38C4F\
-71DC9E88BD6A6F76371AFD65D2AF1862B32AFB34A95F71B8B132043FFEBE3A95\
-2BAF7592448148C03F9C69B1D68E4CE5CF32C86BAF46FED301CA1AB403069B32\
-F456B91F71898AB081CD8C4252EF5271915C9794B8F295851DA7510F99CB73EB:\
-CC4E90D2A1B3A065D3B2D1F5A8FCE31B544475664EAB561D2971B99FB7BEF844\
-E8EC1F360B8C2AC8359692971EA6A38F723FCC211F5DBCB177A0FDAC5164A1D4\
-FF7FBB4E829986353CB983659A148CDD420C7D31BA3822EA90A32BE46C030E8C\
-17E1FA0AD37859E06B0AA6FA3B216D9CBE6C0E22339769C0A615913E5DA719CF:\
-883177E5126B9BE2D9A9680327D5370C6F26861F5820C43DA67A3AD609:\
-04E215EE6FF934B9DA70D7730C8734ABFCECDE89:\
-82C2B160093B8AA3C0F7522B19F87354066C77847ABF2A9FCE542D0E84E920C5\
-AFB49FFDFDACE16560EE94A1369601148EBAD7A0E151CF16331791A5727D05F2\
-1E74E7EB811440206935D744765A15E79F015CB66C532C87A6A05961C8BFAD74\
-1A9A6657022894393E7223739796C02A77455D0F555B0EC01DDF259B6207FD0F\
-D57614CEF1A5573BAAFF4EC00069951659B85F24300A25160CA8522DC6E6727E\
-57D019D7E63629B8FE5E89E25CC15BEB3A647577559299280B9B28F79B040900\
-0BE25BBD96408BA3B43CC486184DD1C8E62553FA1AF4040F60663DE7F5E49C04\
-388E257F1CE89C95DAB48A315D9B66B1B7628233876FF2385230D070D07E1666
-
-# These have specially constructed seeds that result in leading
-# bytes of the output being 0 (this was a problem in version prior
-# to 0.8.7)
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-454D5341342074657374206F66206C656164696E67203073:\
-5C7F7F0932FC4FF8555C3875CE3A0F86BF5B744E:\
-049C40560875766E164A89B2D19D91EF2AABAB4AC182657CAD93680319D8CDBE\
-3CABCF3E87BF41C16013AC4E3D2DEBFB8F89E9E057012B8EDFD0310E24E2BBF4\
-3D54B2664DF3AC82D7E8913ABE29D0A022277EB74D2E0C8C5F4C3F46FABB35D9\
-32A4A713A82FC9464581D9B1F43A2AFB9AB8177DEE8C38CC9F15A7E8F3F9B4D3
-
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-454D5341342074657374206F66206C656164696E67203073:\
-B0E37FD9119056FBC17F9C726B0AE7829350F93D:\
-82E54D1CD28D562D85DD3774636C65313CF26628076FC16A4D25AACCB566FCC8\
-77401BB44DFCB8ADBC6E595D515146D227E9AE6D4D585759F435642DFF2BB1EA\
-3AC72E633C05FB3DC0D8E63395099D5A535DF6EA89341E36D73808D5116299EE\
-C827BB2B6C3141AC0A5698DCDC252B7EDC3A5C24DE75287EEB60F45A37DFBEA3
-
-10001:\
-D32737E7267FFE1341B2D5C0D150A81B586FB3132BED2F8D5262864A9CB9F30A\
-F38BE448598D413A172EFB802C21ACF1C11C520C2F26A471DCAD212EAC7CA39D:\
-CC8853D1D54DA630FAC004F471F281C7B8982D8224A490EDBEB33D3E3D5CC93C\
-4765703D1DD791642F1F116A0DD852BE2419B2AF72BFE9A030E860B0288B5D77:\
-454D5341342074657374206F66206C656164696E67203073:\
-E4AE5BB1DD6DF73F8F75E441DA531F0E493AC0A7:\
-8A64E30AEC76B278B08FF3BF61B7FF439DC2B0F6B789459F1386C0FBF24AF863\
-EFC5A58C5E9CB841EA08D2E22E40293B1876BBB976947038AEEAA36B1751FF97\
-13B9F7BD306D9360CC8D78B7A607F9CA7B4C18C308D85330E534337998D97D6F\
-70F828D6AD1C9C7F6916476127993E4E6F7D596BA6C246F0EB7312A02D09BFB3
-
-# These test verification with various seed sizes. Botan cannot actually create
-# such a signature, since seed sizes != size of hash are not allowed. These
-# were created by some RSA PSS test code, with various salt sizes. This is not
-# an exhautive test (obviously), but from this, and a careful reading of
-# emsa4.cpp, it looks like Botan's EMSA4 will accept any valid EMSA4 message
-# representative.
-
-# Format for verification: e:n:message:signature
-[RSAVA/EMSA4(SHA-1)]
-# No salt
-10001:\
-AABBFB1E4E6F15D4D59E50C25998870956ED9E822D3DD899CAB0FA597B4D1C0E\
-61997501FD1C6E9D756BDCBE9BF49C7FA32926F3FDB387D83296BE35EF360872\
-350AE98C934D760BE7A933CFE85DFB99621D32105AC89496C9F001FE9CEAB097\
-C8DD55D6FD3D913496106BB04F265ED12F8ACD5F4B3FD7129809CA8D80E2E1D3:\
-B841D0374D3C86E67B67BDF00B:\
-1060A74E3EF067A9B17754500B16B8C9F6B3B453FB290C71FCAE779DD37A6B9A\
-24A45D1560DF5E4BC31143E6197AB15684236D8FE578E022495897F70451FD90\
-2BFA5703947EDFF0B63BF1140C63AE1C8D369A87B192E8BF6A3D486E909C3979\
-703806010367CA0E0026F8920EA766B7E3759E23954D0EC2F746E6046FC14758
-
-# No salt
-10001:\
-AABBFB1E4E6F15D4D59E50C25998870956ED9E822D3DD899CAB0FA597B4D1C0E\
-61997501FD1C6E9D756BDCBE9BF49C7FA32926F3FDB387D83296BE35EF360872\
-350AE98C934D760BE7A933CFE85DFB99621D32105AC89496C9F001FE9CEAB097\
-C8DD55D6FD3D913496106BB04F265ED12F8ACD5F4B3FD7129809CA8D80E2E1D3:\
-0F1D14F9:\
-7D4F2EE63FF4B46A09EBB8F9E2F58B4634234B890F7270FDF3454CD2EEAF1BAC\
-AC3516BB5D0F678365E5226034032D6AD49069ED9C7B8BE471BFC6D9BBE3327C\
-BA545675212A5552948524E52567FCE84D9D211191AAB864153C08DFC7576703\
-C21FB9315578A0F1C167FF4D2B810578DC98FBC1235A4CD62ED89BD092C31C00
-
-# 1 byte salt
-10001:\
-A7DB819EAAF3E6876B927ED6EEA94B97E20D06753C7555A7440631216FF4E943\
-720DE7BE6364B8DE17E663705549051F04141D8612214BC269CC09FBDF1F561E\
-474A2ECA28ADDE3530CA339015F23CEE63750C508A1416FE5D1AEF5AA09BBA7F\
-36CFC02874B15DCA913E35B52B281D32B1CEBD22EAF3C629123988FE78FD0561:\
-AEAD5A03023E17D894226CB2C7C77D5D4341E8BF7F1453140D58B427B40B0B18A9:\
-27ABB6E27D9DBA0F9E5DB3607BF04E20112150A779EAF67D4AA76D50A6060F70\
-03BB33BE5A580789E567C3768AF938BDBADE712F7344B72655118636095EA8D6\
-97888B9382BF3030D56A685079980A992A9BED3AF0DC81AE4316AF31681A3BDD\
-78CC4E83FD3C227A9984C261ADF36D201AA417243A28BA47488BD81CB1DA63A4
-
-# 2 byte salt
-10001:\
-AABBFB1E4E6F15D4D59E50C25998870956ED9E822D3DD899CAB0FA597B4D1C0E\
-61997501FD1C6E9D756BDCBE9BF49C7FA32926F3FDB387D83296BE35EF360872\
-350AE98C934D760BE7A933CFE85DFB99621D32105AC89496C9F001FE9CEAB097\
-C8DD55D6FD3D913496106BB04F265ED12F8ACD5F4B3FD7129809CA8D80E2E1D3:\
-6A4BAEE539612920ECB3075EF6C31BD7EEA01F43:\
-36F7211C290577ED0CF54007551BA65943C388BF2AE58F12E8BF7B6E7339348F\
-2534E7515232D0AD72AD8F6EA173FA3D21DE13D392DE10C457DDA7C569AAAE17\
-0C8806A3ACA457461EFBAA7EC870947ABE2D5A91821B9254EA34A74E95E7648E\
-D98A7ACD2300D4FC88C8B968E0AE68DF9BFF849E53AF03A2E12965C1453AAFC4
-
-# 3 byte salt
-10001:\
-CB6484FE402A7E96E3E43AC26CBF3FED47FBDF6921D40072FC27FA110CFF8D94\
-EDAC5E119D0801CEC89875BBB6FBD838BD0FB7F7F7FA62FAEA798CC6975F43ED\
-CADA7947BABA41DBDEB321E273C870973A9E741791380886B4B131165EDDFCF4\
-F162E17AD36E8D7A763502920527DFA9CDFF0D1046914195D2924D4075DEA235:\
-0F50:\
-707E1B680D4D7E2CD102ED7AF2B63AE63CAD9266476418F330FB739FD052A777\
-4A0182624E81C3AD14C12BA5BA1D99315217D84EA1FAABF4A90E7CFF19875351\
-46D4944AE27E2C84F313E5E5A22C5B86A88333DBBC4D17425F180C6B0F4BFD3E\
-9F03DE21B422EC125DA6FF2835A93CEBED8C1283568E04BB634CAC410D144B91
-
-# 4 byte salt
-10001:\
-A7DB819EAAF3E6876B927ED6EEA94B97E20D06753C7555A7440631216FF4E943\
-720DE7BE6364B8DE17E663705549051F04141D8612214BC269CC09FBDF1F561E\
-474A2ECA28ADDE3530CA339015F23CEE63750C508A1416FE5D1AEF5AA09BBA7F\
-36CFC02874B15DCA913E35B52B281D32B1CEBD22EAF3C629123988FE78FD0561:\
-5C3DB99915C8F7EEACB045ECBB7C35C06D4ED5A96AA9025A49093B70D7C2EDD4\
-85930D18DEB57C0282563F2B07FBA63245FDC773CF851985475DFB4F6FA335BE\
-1B4C2C28A294E84E50172AA585B382BE1E1038FBD02F2BD37691D85A18346AD0\
-4CC81948698FF248CFAF33E222EA8B5FCAEC0E5AA8F753521EC47BCB756E05CF\
-95E4365E06A69BB6C99A34A62939B478AC1209FFACC49BA4027749801D4A9F58\
-3395B34340:\
-9705B191BE8BD52D3E6CA1743DACDA5EDC1C7665B6EBC769A5983BB74D2F52C7\
-9F94954DC8CAB9A44FB3B387A0FF2843311CDA640DC39BA975518B511DF87064\
-B17709804D707DA08A315F14D24CF6385310A62D7F6C47689B66C4A12F449FC9\
-5796F1821EA6838DE2941D0725B55EC860CB553B36878C2BA3994DCD0A8992FF
-
-# 5 byte salt
-10001:\
-CB6484FE402A7E96E3E43AC26CBF3FED47FBDF6921D40072FC27FA110CFF8D94\
-EDAC5E119D0801CEC89875BBB6FBD838BD0FB7F7F7FA62FAEA798CC6975F43ED\
-CADA7947BABA41DBDEB321E273C870973A9E741791380886B4B131165EDDFCF4\
-F162E17AD36E8D7A763502920527DFA9CDFF0D1046914195D2924D4075DEA235:\
-F1FE75913B7A152626C287B1287B6ED4A04EB546950C0414B2D7AAF82DF8F255\
-E08E20A2CACD2399C4304FD9F77B9CF8B2A244C15ABC25DCFE1B144F2B125AF7\
-91B05877E11BEAF3ECC75FC9:\
-87337D2D71F36C4452216459D55586634D755C84D9D8F80D058E029A1CB61A6D\
-4819E3993B623AF90FF915AC585AE6088DF7565A2A205D6282252EA0863A7F12\
-F07A06189F2E2C4EC6B27EBDF3955ADC7C85B803C612D44B9EA5D5FC0B7F15D8\
-AC704D83DEC3D8F84808C2AA5F984FD06D1456B4EF875C33A7346051514DCECC
-
-# 6 byte salt
-10001:\
-CB6484FE402A7E96E3E43AC26CBF3FED47FBDF6921D40072FC27FA110CFF8D94\
-EDAC5E119D0801CEC89875BBB6FBD838BD0FB7F7F7FA62FAEA798CC6975F43ED\
-CADA7947BABA41DBDEB321E273C870973A9E741791380886B4B131165EDDFCF4\
-F162E17AD36E8D7A763502920527DFA9CDFF0D1046914195D2924D4075DEA235:\
-04F7B2C9BEEE7F00FD42C651A3492E6F61816AB3B0903477CFB49B2DDE8AB64D\
-898019C6C937FE653A92C1BD992A3304F357:\
-14949A71A7AF9EC4364DDF90E5A7C4283F8FEF7DD3A544FFA4B1BCEC5FEA6C21\
-4FE7C9105393E72D308CA0994F6F900479219439B8FDC850E15404C024AB757B\
-F7DDF35B0CEC668AEAAAB5039EC81F739C160DD57B26ACDECE905F608AB0396F\
-9DE8F99A53F765D37FB625C8E90C68B4E5B32AEF48C0FDA39B7314FCE942A9E9
-
-# 7 byte salt
-10001:\
-A7DB819EAAF3E6876B927ED6EEA94B97E20D06753C7555A7440631216FF4E943\
-720DE7BE6364B8DE17E663705549051F04141D8612214BC269CC09FBDF1F561E\
-474A2ECA28ADDE3530CA339015F23CEE63750C508A1416FE5D1AEF5AA09BBA7F\
-36CFC02874B15DCA913E35B52B281D32B1CEBD22EAF3C629123988FE78FD0561:\
-71D2C0843ACA68C291953E66:\
-4C22BC81446B062A561D9A922E959036E7763B0803DD84168C48AC51DBE79A12\
-9D017E22BF9DA19996C09BE7369C4F0808ACC2E708DFF48AA2AD41EF78F5F97B\
-914FFE079BE9F9D30E67049BA28BEE714FE622A18A3524FC7E58ED7C451714F1\
-4718F4475814B6D9A6590845D9CF6FEA2DCD313CFD580B47D5BEF6960CB0E463
-
-# 9 byte salt
-10001:\
-A8802DFF63A68E53D5B4AEFDF9BFBDDC2F3FF809D248CBC4AA250AE710830671\
-4ECD4BA4C465298C7E7EFAAD9ED969BDD23D851D31BAD61FA942B24A60D34469\
-F2774133D488E82E66B01FE4C7C8CDF95CB194D721FBE3B98FFC61D31F07D8CE\
-E32318EFF73E374755CBCB3785D93772A414DA3C25B240B16F40C83723448861:\
-9D5116B54CBA7970742B66BE6924D122A1D7E570F037DA06B29A2B34175C8F94\
-28D1E8E908EF492892AFD6B08019EED0123F32B74D04324DDB98171ADE66347C\
-1FFB56BD1B05E1CECE2ADD838BD95CDEB74E36A51B69F2602322593462182437\
-AF357BB63EF748F45CDDB66BE5357E9701C8B21C6613857432CB99C91CDFCB72\
-54D087B361CCF05E77AF961F023E83416D9FF539A572A5C89117FE1506AF6633\
-5321A0CB7BF096DA0590D2E79FA60DD7A38B9DF2D352673F5A31A873111E3C8D:\
-A73BC3BD89ADF92FF2B8EE3B5430849301C322074696BD58FCA3D0C113BC9CD7\
-9D6D822FCE31ABF1C276C1272D045E5FD92BAE9FBC07EE54742D3342A2B03E85\
-47B1DC94E86C5D08A13708780952498CE3EF3B07710E5777683C9630821248A9\
-D38BEC8AB7C77DF1CA6E695F0289443C13A8A4834D97CE6DCBB6782A70F866B1
-
-# 10 byte salt
-10001:\
-A7DB819EAAF3E6876B927ED6EEA94B97E20D06753C7555A7440631216FF4E943\
-720DE7BE6364B8DE17E663705549051F04141D8612214BC269CC09FBDF1F561E\
-474A2ECA28ADDE3530CA339015F23CEE63750C508A1416FE5D1AEF5AA09BBA7F\
-36CFC02874B15DCA913E35B52B281D32B1CEBD22EAF3C629123988FE78FD0561:\
-75352B85B47E73B18E8CD9608354ACCA4DF8E2B73313C681A8119D6578CAF8F9\
-A52EB4710B97D334D2CD49C365BC0E0BB89D63CEBE3EC62055E7948C9DF696B4\
-06EAB60881B0371F5AE092D0A43ED9AD307D026B2CB6477AF5ACC32919D470C3\
-9C9BAA71B0FA78F8687BF762C399407BB39C59727AF3B61DF3EA486E473D4CC8\
-D67805E8810F:\
-7F51B49FA57C4EC7AC72A90C9EBB51F6E21E3B6EE67E6DE32119AC9FCF97FB19\
-09F74491CDE182ECBED994B66EEC44AC817A8F620444BB6520A3A223BE4AFA78\
-B50F11C057FA4F4835D55283157F5C8AE60A2A46D0CB9D4BE3411FD3505F0FAC\
-5202ED1C0629575B59001488B30E9F12E738F2B388C7EF8A82684CBA43115010
-
-# 11 byte salt
-10001:\
-A7DB819EAAF3E6876B927ED6EEA94B97E20D06753C7555A7440631216FF4E943\
-720DE7BE6364B8DE17E663705549051F04141D8612214BC269CC09FBDF1F561E\
-474A2ECA28ADDE3530CA339015F23CEE63750C508A1416FE5D1AEF5AA09BBA7F\
-36CFC02874B15DCA913E35B52B281D32B1CEBD22EAF3C629123988FE78FD0561:\
-DA40B3B401DEED4DBCC3848CC729C8B5FD169A140914C40FEB752E2D3F2F7EFA\
-A97CE26BABE4099BDBBAA522BB09DB37A1D06CB53A3BF7D621:\
-328E325D4F95D0013019B97F5936EBB347F1E5B01A559560518C1C47DC044343\
-92BD2168DA08668E4EEA9A06A5CED7C9076BF7CAC667503FE6B7903953958BAB\
-B31EE9B29E356274F7136F35F5224A1BF50F3663D002B6220C3EA8572C1368D1\
-1D3C6DD6E1F3D700811257EF8B46246C2A6A975C08DEA782003F5CD45703FD22
-
-# 16 byte salt
-10001:\
-AABBFB1E4E6F15D4D59E50C25998870956ED9E822D3DD899CAB0FA597B4D1C0E\
-61997501FD1C6E9D756BDCBE9BF49C7FA32926F3FDB387D83296BE35EF360872\
-350AE98C934D760BE7A933CFE85DFB99621D32105AC89496C9F001FE9CEAB097\
-C8DD55D6FD3D913496106BB04F265ED12F8ACD5F4B3FD7129809CA8D80E2E1D3:\
-1C79CF64CCAA6C913ABAA5A555558BC251:\
-0C9485139F787BB6EFBF23783CEC74A53DFF16937FA6E76BF120D15ACF87D848\
-0B7EACED7B44ACD2A87C92A3F5AB185B81664AE248C7557C2766656C05A5D206\
-DD110E0E97F4F63364BB396F8431ECA2352FF84B4DB5F54FFAB155768624489F\
-D6E7C40282D1F9D85674D21E01571FD24423461F3D04D9595C43BFEB8EC586E3
-
-# 19 byte salt
-10001:\
-A7DB819EAAF3E6876B927ED6EEA94B97E20D06753C7555A7440631216FF4E943\
-720DE7BE6364B8DE17E663705549051F04141D8612214BC269CC09FBDF1F561E\
-474A2ECA28ADDE3530CA339015F23CEE63750C508A1416FE5D1AEF5AA09BBA7F\
-36CFC02874B15DCA913E35B52B281D32B1CEBD22EAF3C629123988FE78FD0561:\
-3096922A62DABF6B98A4480D2F86629D1992FFE1545869DCE5E69F810EB793C5\
-ABFFAEE2EEB846644C8BE8E31942BA16FE51B7988F355999CFFBA28CFB9DDB1B\
-5F4919790B7E63E37F00289C6CD42F56F7520A2DDA73AEA4BCB2D10053AB9720\
-B201D52AAE450BF22AF2C4E3AC:\
-43F583905ED6D2D53045C60E472FC1FED12EBD88C190EE810F9576E262F3881F\
-BF006211DD5943A48BAC7FF21C4317BC28E4968C98FF6E0F94C055FB104555C1\
-E7B533F9DDC49D200CAA8C2F62C5EDC6A9E9E76290DDEBF38BAEC88EEF8B32B3\
-DE804FF19627C04B13261CE2EF2101619CA1D6BDF3C5C7DEDCF21E18726081CE
-
-# Format: KEY:message:signature
-# These tests are copies of a couple above. The only reason they exist
-# is to test parsing of RSA public keys in X.509 format.
-[RSAVA_X509/EMSA4(SHA-1)]
------BEGIN PUBLIC KEY-----\
-MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCqu/seTm8V1NWeUMJZmIcJVu2e\
-gi092JnKsPpZe00cDmGZdQH9HG6ddWvcvpv0nH+jKSbz/bOH2DKWvjXvNghyNQrp\
-jJNNdgvnqTPP6F37mWIdMhBayJSWyfAB/pzqsJfI3VXW/T2RNJYQa7BPJl7RL4rN\
-X0s/1xKYCcqNgOLh0wIDAQAB\
------END PUBLIC KEY-----:\
-B841D0374D3C86E67B67BDF00B:\
-1060A74E3EF067A9B17754500B16B8C9F6B3B453FB290C71FCAE779DD37A6B9A\
-24A45D1560DF5E4BC31143E6197AB15684236D8FE578E022495897F70451FD90\
-2BFA5703947EDFF0B63BF1140C63AE1C8D369A87B192E8BF6A3D486E909C3979\
-703806010367CA0E0026F8920EA766B7E3759E23954D0EC2F746E6046FC14758
-
------BEGIN PUBLIC KEY-----\
-MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCn24GeqvPmh2uSftbuqUuX4g0G\
-dTx1VadEBjEhb/TpQ3IN575jZLjeF+ZjcFVJBR8EFB2GEiFLwmnMCfvfH1YeR0ou\
-yiit3jUwyjOQFfI87mN1DFCKFBb+XRrvWqCbun82z8AodLFdypE+NbUrKB0ysc69\
-IurzxikSOYj+eP0FYQIDAQAB\
------END PUBLIC KEY-----:\
-5C3DB99915C8F7EEACB045ECBB7C35C06D4ED5A96AA9025A49093B70D7C2EDD4\
-85930D18DEB57C0282563F2B07FBA63245FDC773CF851985475DFB4F6FA335BE\
-1B4C2C28A294E84E50172AA585B382BE1E1038FBD02F2BD37691D85A18346AD0\
-4CC81948698FF248CFAF33E222EA8B5FCAEC0E5AA8F753521EC47BCB756E05CF\
-95E4365E06A69BB6C99A34A62939B478AC1209FFACC49BA4027749801D4A9F58\
-3395B34340:\
-9705B191BE8BD52D3E6CA1743DACDA5EDC1C7665B6EBC769A5983BB74D2F52C7\
-9F94954DC8CAB9A44FB3B387A0FF2843311CDA640DC39BA975518B511DF87064\
-B17709804D707DA08A315F14D24CF6385310A62D7F6C47689B66C4A12F449FC9\
-5796F1821EA6838DE2941D0725B55EC860CB553B36878C2BA3994DCD0A8992FF
-
-# RW Format: exponent:p:q:message:nonce:output
-[RW/EMSA2(SHA-1)]
-2:\
-F21624A28732743BBE9B1A2B320CA31EF4A127456547ACDF5C523995E25A990B:\
-BC6EDE730E7CEC8993A6E6296EA8DFBBC7D46615122F23F635FF988E284E31CF:\
-5075752E::\
-44CB3C6CD992A656AC2D8C92E044FCCC60FAA1B47FE153E7BA4B647136DA4A42\
-88BD50FB0935E3B9180AF477F8B88E1EA1106569CCAB8D354E0A7E3AC92D70B3
-
-2:\
-F2E5CDF6CA7387C132242CE031CEC8FE2CEAFA8530EC9795F16605B1CBD97BCB:\
-DA330E4440FE5CD00A37A738DDFBDD5623A31FAE273AD98E41DA0D3DB937CEBF:\
-4C6F7665207375636B732E20556E7265717569746564206C6F7665207375636B\
-73206D6F72652E::\
-5AB035B8E6415D691951DBCEACC6A61987599000A590A414363BF52FB95C5BAB\
-C12812152C5BCBC6A443C68B971EE0AA5E864C9FF9ABE0A85BB86FA544239958
-
-2:\
-13CE5CDF6CA7387C132242CE031CEC8FE2CEAFA8530EC9795F16605B1CBD978A3:\
-14FE360AA550965F93CE76E4B01F55FBFDD7A049B2761817505CB6959A73A4C07:\
-4C6F7665207375636B732E20556E7265717569746564206C6F7665207375636B7\
-3206D6F72652E::\
-0085AC363AEA57F36E348936599A77167BAF17194D250787F347C710019558A9F\
-773DDC25A2216DA694D38E03CAA4F7423BDF03DB0E75161221906222FC9E0F23D
-
-2:\
-1947A060ECFEFA3F8DDED8AE580D45B02D82DE108496AFC322FFD14EA02B7BFE3:\
-1E1384A66A21500DEE4DC2B36F43EF398B1C50BDEE7600CD4340B663471F0F16F:\
-4A65737369652048616E68616D20697320612064616D6E2063757465206769726C::\
-00BE5B2A5EE3CB613ABE4548C856F6C8F8B4B9EAD3795675E59E4DDC4A015D019\
-2F29B6352CDD913C289961BE57F84005F0BBD3AE7E2BBE73DABC50B2201923CC0
-
-2:\
-1AA83F51426F2BDA398221C48E8D322EF66D59098D0418E0C2B06DE6EA2F97D33:\
-1E4C7924C9E6D7ABDB372B112601D4C091FAE6C8FEB518595DF436FE9B354E26F:\
-492077616E742061206472696E6B2E204E6F772E::\
-010E8838216B05B4C2739B65AB2A7ABC114A046E3CD37CF1E97815ECA53750B1B\
-F486A9BA684B9FE2D983BBA5F9D97565F0DCF6A5176C169EC67B6BB6C9616CEA6
-
-2:\
-22C9D42C6803B9AC87F641E9465D300DE8898694427D138761C4A5B121B0632DB:\
-25DA5C05701C99EDDF0FBAA61DCDBA404C05D860DD539E06B0AECA7E56354DEA7:\
-54657374696E6720766172696F7573206B657973697A657320666F72205257207\
-369676E6174757265733A2035313220746F203531392C20616E642031303234::\
-0191F1BA45BC571445612D8C1A7818B52DFF78566E6CCFF7AB55B2F35FA21210C\
-951F171E27A2921032718AE01BB4F209164BA0B21A5842D1925B35D09C7538050
-
-2:\
-388F732F05B06F5BA10816242E8F75A000E235C97174F57931E8D845442147F8B:\
-2F3758EBE44182841FB1743D3BA6AEEC0AEC5758660E1DB37C818199B90A1A307:\
-54657374696E6720766172696F7573206B657973697A657320666F72205257207\
-369676E6174757265733A2035313220746F203531392C20616E642031303234::\
-046C31E4EA320DF130FE1F361184DDC03713BBAC169E08266B91655B42A01F39E\
-1E3FF781B04B2F44B2504F37ACC9688C1ADD7EB94A998779EFCDFBEB9FAFFC82D
-
-2:\
-4AE4F716610D77E35A6FA2FEAAAC3E92706B996414C012EF72BCBE86E3F1A97BB:\
-5145D9E08DA9021E87080C437BE1835B06E5C9ECCDA8E7CF7E30F682D0CB1A9F7:\
-54657374696E6720766172696F7573206B657973697A657320666F72205257207\
-369676E6174757265733A2035313220746F203531392C20616E642031303234::\
-01BF0E20BF646E5E427B8D28CBAF696D7AA6B6DE878BB91C295D5559B1FA9A94F\
-114FF61C11C0BC97066C2FC919815B0FD150CE70F63D696CEA4D5D1D7BDEDC035
-
-2:\
-6AA3DB8710567A30D7E9E61956962D4E4D50BC0510C2238D9136A93CC5DC3A73B:\
-6CAC9FF49F1035D179668B399927A610608788A8C884B76A94A6DDBCA94A52327:\
-57414E5445443A2043757465204A6170616E657365206769726C667269656E64::\
-1695A91578EBC67ED86C20EC4886B2E3895E11A7647D22FFB41091E1C7A3CA0DC\
-E091A1FCBACB859C4A5C8B3B841C0F0F7039BEFEA790A423114F35F9D809DBCD2
-
-2:\
-9EADA4F7D1BEC405BC2BFB4F836E19A488E079030F8C09DE76810B9E63FB41873:\
-AD5DEBCF83372200B106812A6A7CF3A702C35BAF4FC095617794314EBCAC4DE47:\
-476F6C642073747564733F213F204576656E20746865204D544120756E6465727\
-374616E647320746865206E65656420666F722074686520424C494E472D424C494E4721::\
-203FCE80570CA0DA3C2D50634A33BAACEA6D397618F36620EE10DE4E6A51018C0\
-BADE98DF220E47DBA140AEAE910A28F3177D4349740EC05A5EB7BA280D7BF8F34
-
-2:\
-E39815FB87BACBCCF779BC66EA0AE9784FC95E0DA094E9BEDE99FB45F73E2078\
-3038AE0488539A2CE982B4F180FC71858F2E5759E61E2C5A5FAFA435BA3A62A3:\
-CDC7D5FE3805572EA3FF554C086C7DD4020A3CE48DF5A09A5CEB75E6AABCD338\
-F800F362448E87CE7E1A55331ADF2BBF3A22B3E6134035FDA52D9578FD3F72F7:\
-57687920696E20746865206E616D65206F6620616C6C20746861742069732067\
-6F6F6420616E6420686F6C792061726520796F752072656164696E6720746869\
-733F213F21::\
-05BDC911B3F19F2201EDF6CCC792A68BCEC40506F00112A6DCAEEAA2D7A62192\
-931D8968F7312EBFE7F7646CED6A8948E58327862527EFD960F15CD8EC74D1DF\
-1FDC37F369A4A844D15DB7ACC6DB5ADA884B119148929439D5305B6916D0A081\
-1D395E6A28042F83D1154FF45DA6A79A3801858031A2C91EA699C02DD6055CC2
-
-2:\
-EF86DD7AF3F32CDE8A9F6564E43A559A0C9F8BAD36CC25330548B347AC158A34\
-5631FA90F7B873C36EFFAE2F7823227A3F580B5DD18304D5932751E743E9281B:\
-F5BB4289C389D9019C36F96C6B81FFFBF20BE0620C6343E2B800AEFB1B55A330\
-8CC1402DA7A2A558579A2A5146B30CB08E3F20B501081248F2F1DE36CDFCE9DF:\
-2CA039854B55688740E3::\
-1AF029CBEC9C692CE5096E73E4E9A52EC9A28D207A5511CCEC7681E5E3D867A4\
-AE2E22DE4909D89196A272F1B50DE6FA3248BCA334D46E0D57171A790B6F4697\
-E7BA7047DB79DECD47BD21995243DEBBF25915DDBC93C45875C14DE953792257\
-C5C6825C905AFF40109C8CC7E793123D47AC1B5B6304A436CFA9BEEC8E0054E7
-
-2:\
-EF86DD7AF3F32CDE8A9F6564E43A559A0C9F8BAD36CC25330548B347AC158A34\
-5631FA90F7B873C36EFFAE2F7823227A3F580B5DD18304D5932751E743E9281B:\
-F5BB4289C389D9019C36F96C6B81FFFBF20BE0620C6343E2B800AEFB1B55A330\
-8CC1402DA7A2A558579A2A5146B30CB08E3F20B501081248F2F1DE36CDFCE9DF:\
-2119A954F1AC0F3DCDB2::\
-60C3CCF4F086B15B7F850B445F384333F7AE5A4B5EDE2820C7233239E1B86D6E\
-4B4FCA4F50B087CE1DF17DA5D62672A17F2CF87A2875BBD9B138CAF6863821D6\
-A4D553E9EB64C9254A8F9A6B960E57E39069D65E3F561AA1FA91643D42FEEFB9\
-270D34AB0861DEA1E234EA587F580503D46A1989D413DAC2FFE0FC4CA663CE68
-
-2:\
-EF86DD7AF3F32CDE8A9F6564E43A559A0C9F8BAD36CC25330548B347AC158A34\
-5631FA90F7B873C36EFFAE2F7823227A3F580B5DD18304D5932751E743E9281B:\
-F5BB4289C389D9019C36F96C6B81FFFBF20BE0620C6343E2B800AEFB1B55A330\
-8CC1402DA7A2A558579A2A5146B30CB08E3F20B501081248F2F1DE36CDFCE9DF:\
-7A4C634DE6F16315BD5F::\
-308A5D65224201BED626CC83FB901EC84874EE03B2E7AB4E752EDBDE024C754E\
-3CC9841CA062100A8843DE9183354B4E0596E8C68F1605828287884F0F9BA696\
-8FC7A9F0CA09418A8485B90465E5D3F96CE4995A5FC7A6E5ABD9CC06BB8A2C3C\
-8109F72EAE67FB4C108852C881CA645B3C5586F27F12FF3028ADE56E32AD9434
-
-02:\
-0BC31C063F43B3ADE2CD633D554913339071D6EBED5FD665FC5DD7D47B80721A\
-976C3B14FBD253F0F988C354725289F2897D7FB62C5C74AF7D597A1E22AAFBA1D3:\
-0F816BF0ADD559AFDA38B008E4087F6A38B575C56FFF453056EAAAB3381C9552\
-0969546F954D458D48E44850938B1DB471CF4B40AFC47E067FB5BCE67BA98BE8D7:\
-EF0F1D56F4E5D587C212::\
-3E544FEBB6623F5D392003B729FE2BFC20E2CB3ECAC22734DFCA55150254E616\
-A41C5E54CE3B50FBC2FE2363EE9AF9B15C70615497B0A458F8AB6D850992EEEB\
-56D65F87EA1BD6E2B4B7E40A0F5E1635C7DDB17110C61039CF712D3524C9C2C1\
-F35D9163BE5C70276F46634514BE16EC09602782E88FE74EAEB2F50CBB0E3B5C4A
-
-02:\
-0BC31C063F43B3ADE2CD633D554913339071D6EBED5FD665FC5DD7D47B80721A\
-976C3B14FBD253F0F988C354725289F2897D7FB62C5C74AF7D597A1E22AAFBA1D3:\
-0F816BF0ADD559AFDA38B008E4087F6A38B575C56FFF453056EAAAB3381C9552\
-0969546F954D458D48E44850938B1DB471CF4B40AFC47E067FB5BCE67BA98BE8D7:\
-EC5CC4228C3C70EE8F35::\
-228BAA85062F10DCC9D99A23D340BC4B9E463D8AB86A6781A6D2143564303E2D\
-C78772BF68449BE1E2711A68D5A15CF04A23573FB3870454308F583BBB5F2467\
-069EF1395431E70F91BD56D846DC8DB2E88AB3D26A9770660B87A76D6C3575DE\
-512BAFA8A0B901AD15B7D8E8BE2F176A182D16A9609F19A4298416245873175805
-
-02:\
-0BC31C063F43B3ADE2CD633D554913339071D6EBED5FD665FC5DD7D47B80721A\
-976C3B14FBD253F0F988C354725289F2897D7FB62C5C74AF7D597A1E22AAFBA1D3:\
-0F816BF0ADD559AFDA38B008E4087F6A38B575C56FFF453056EAAAB3381C9552\
-0969546F954D458D48E44850938B1DB471CF4B40AFC47E067FB5BCE67BA98BE8D7:\
-FEF5EE07C74118DA30B9::\
-2637E16E2599B6EC2F4728C73D3B29F483C2B881F1E1969C426027605EF080E9\
-B17D258D5E1EBC6472A2501E04CF19C144537FCB38A1DA00D948EBD39FA11322\
-D9230B62E2C12AEDB366BD85A2089588A8D52E941FD986D89828A342B83438A9\
-60B6FD87E9AD025AD75A692AA9DFEA873A9467B42D84879E85C5D11EFAB347FBED
-
-02:\
-FA880A456F9C205A26E02C3357536531DEC150BE0EF8747F69EA30D987FF7DD8\
-9E9A1075EBD39F04FA495BD26D8408A8DE69113A9FBB52F20713D1D046A76B47\
-8CF77C46454A7AFDA2EF418F63FAF67C947D898BCA109F3275999E8F2E60E2C0\
-EEC133FF69E71A2D396632670B52D8EA03F7589D8144AB580B1D3E60EFA1280B:\
-BADCC718DD2D761C4893C4831D56ADA30FC5C7C148D473BEDF7615B7E821B92F\
-319676CE278349F1309FB3D264C1A22BDE71B221354C7A4D31117B3EC3C9D480\
-2E0A26BD8EC05D28B6502C65F35C687AF7F8396B963ED029A2C5AE38DD7C5C96\
-2A953C113C0F590957AB19A6E2AFDA6DB84F22C0C31AE243DEBD2920FBE9FBDF:\
-15E7B7B7ED0F176B6799::\
-39FF4B5FA50AE498F3C91A655E6865840D1FC401EE02DBC8460A59DEB8816E66\
-80F712B7BAF8D4DC11A3B54BF906BE698306F0449BB43F3F223B944D930A1A3C\
-718E8A9E2EEDEC5A07AB817C26A80CC2A2EE2846A597EAB8A999D38DB9849016\
-6F2574524038BBDF24B4E4622C843210C6B94987638C6976562EA9727385B152\
-614C18349BD54AD95DE33D5354954B505E5259CCDA47E3CECEF3154F6E5481E5\
-36BAB568146A0BFCB66573714A7BA7ABE0385115720687F33D9C6EF6BB60272F\
-1272CF349990E3A2FBCCE180B730792101089B164AE5A001F5263F7493AF148D\
-6E0953E311AD12E4202D35F96DD30885663B5101F9B05675FCD2FCC4FCC4DDFF
-
-02:\
-FA880A456F9C205A26E02C3357536531DEC150BE0EF8747F69EA30D987FF7DD8\
-9E9A1075EBD39F04FA495BD26D8408A8DE69113A9FBB52F20713D1D046A76B47\
-8CF77C46454A7AFDA2EF418F63FAF67C947D898BCA109F3275999E8F2E60E2C0\
-EEC133FF69E71A2D396632670B52D8EA03F7589D8144AB580B1D3E60EFA1280B:\
-BADCC718DD2D761C4893C4831D56ADA30FC5C7C148D473BEDF7615B7E821B92F\
-319676CE278349F1309FB3D264C1A22BDE71B221354C7A4D31117B3EC3C9D480\
-2E0A26BD8EC05D28B6502C65F35C687AF7F8396B963ED029A2C5AE38DD7C5C96\
-2A953C113C0F590957AB19A6E2AFDA6DB84F22C0C31AE243DEBD2920FBE9FBDF:\
-B36724C92954C38D0288::\
-3C8CD3614555568BBECA99174B7B203D0BC6FABE9E6FFE0C41EB4D9A2C601D23\
-93CA1E01B7D7E99337758AC914C9F151311E5AE6708DAF1D8C825DA471652C6E\
-13A8FE5802D7AE097BFC899A4EC8CA235B5982B9058C53AAD52823ACF692290E\
-B8823C126635AB0BBF101C2B3149AB16183FA2DBB049DDB99C5E83723E4D4693\
-CA3A08588AA868C677D42ABDAA6586EF192391D276C5E5AF0763ACCA6293F062\
-50C51FDC2AD369CD44EB5F654E98761C881DDEC08E795FFB229B20522349B071\
-4059E18B7B23A48875EAB12ED3F0A011D3A985DD7384B0046F39FA6C1A331F3D\
-4C5125100BA58666935C68A7A10849D9C74850BAB82AE15EC950A283F3E7DAD8
-
-# Format: e:n:message:signature
-[RWVA/EMSA2(SHA-1)]
-02:\
-E5EB47BC1F82DB3001FAAEABC5BBE71B7D307B431889AC10255262281EC5F5AF\
-8A790BD7BBEC5EFFFA442CF2C3FD5CA4778763B9D15AEAC0B9B71BDB13DA8272\
-7F4967AC685975F8FF05A763C864D100B7CC1142102AA2DD343EA1A0AB530255\
-195C3A6400ECAB7B27EFF9B01EF6D37381FA6FB5401347F195354396772E8285:\
-2A51DF4AF88613D91A37:\
-6FF18F4471E1A8F850C910A181A9F28E69AACD8E8126969605E000A853197541\
-AF9047E5D17315BF062B9CD8DF91196F0343285D9E31D5C72560C156782B6D0E\
-5AF8F06D7DCDD8CABEC01B2438C168C40C21F6A8794648361BD2AEE13573A49E\
-CA07A7EED97C0B9C5B1E508869E4CFD5FE1771924B1CF5A4BFF7D4379E5CD59F
-
-02:\
-E5EB47BC1F82DB3001FAAEABC5BBE71B7D307B431889AC10255262281EC5F5AF\
-8A790BD7BBEC5EFFFA442CF2C3FD5CA4778763B9D15AEAC0B9B71BDB13DA8272\
-7F4967AC685975F8FF05A763C864D100B7CC1142102AA2DD343EA1A0AB530255\
-195C3A6400ECAB7B27EFF9B01EF6D37381FA6FB5401347F195354396772E8285:\
-1CF8DDD95D780A89D7CF:\
-539C266B0313E0E256ED98EEF13E6AE64CED90C160A4999B3D47CBDA5285DAB0\
-E0678C0E079CE9B8EB23E10EDFACFC19A80EEBB8F38ED5B5D6C8A988AB8CEC40\
-A5A5BA102F75586167EAB6D5BF0CE8FF30C656895800F6F1B37D69FBBAF9055F\
-7505DBEB537C0F986A1B5F0270DC12A640FFCB626F9763FDCFEFA1208C104003
-
-02:\
-E5EB47BC1F82DB3001FAAEABC5BBE71B7D307B431889AC10255262281EC5F5AF\
-8A790BD7BBEC5EFFFA442CF2C3FD5CA4778763B9D15AEAC0B9B71BDB13DA8272\
-7F4967AC685975F8FF05A763C864D100B7CC1142102AA2DD343EA1A0AB530255\
-195C3A6400ECAB7B27EFF9B01EF6D37381FA6FB5401347F195354396772E8285:\
-F6959926E6D9D37D8BC0:\
-249E1066542618CE0D236A7174708F801E7AB257931E9967A65C483ED66FB585\
-98F99B6664AF0EAE221E2A6B271D7D17875ED02BF7FE35AA0786023858521CB7\
-9FEE0D134D9DDA609B0270FC9804BB6BF74AD90AE11EB339353533DC0D5A69E6\
-B8758212B86024ED563767EA5D9B59655E0B8CC21244F720BA4ED663BF668E3A
-
-02:\
-B660EB18786256C993EBC6DCB5892EAC342F6D91229B73DC5D04F1AFB9BB0DD4\
-EB0B48895F514B4C9AFEAF86E91226F2299126D37528CE374E89CC312C06F47C\
-81112BF5CA60FFC33B98318E04A17627269F1AF461B6CB40F3BE03B0113FB2D8\
-404E154C7191306B36FD3EFA73C784AD9189115D0BB1BD82B850D000E7CC8D2035:\
-2C9EA313EACF2C5DA43A:\
-1FEFF88814BB53E447E1E955AC8F1AF597C15C3866033E337AFBAB8627306F2E\
-C1276621FF2176C89323CE32EA20F6AEC2CC271F1ED749408B2A3E43A23A44D6\
-A3F38DCDDCAB696B239110AA7ECF12C6681B0E97E6FFF1B72F4F6D796BF82B94\
-50AB8B3D28CA9D220BDF84ACCEA1DA5EDA0B470C3A82BBDD77B4C2723297608BD4
-
-02:\
-B660EB18786256C993EBC6DCB5892EAC342F6D91229B73DC5D04F1AFB9BB0DD4\
-EB0B48895F514B4C9AFEAF86E91226F2299126D37528CE374E89CC312C06F47C\
-81112BF5CA60FFC33B98318E04A17627269F1AF461B6CB40F3BE03B0113FB2D8\
-404E154C7191306B36FD3EFA73C784AD9189115D0BB1BD82B850D000E7CC8D2035:\
-0B9554FFE4F6ADAB2C76:\
-095952F24D9FBEF3A93A932865F4BDBB522CF24EBE153CE4BBB24CF301A1C7B5\
-1FE47B94F8F8B211CBC5A926FF6BAF9A6BBF7E15975D2DCCB95EF01AB7E64168\
-7870B0D01FC18B6B16FE17D3FC82931FBBCD4FD18C7F9588CEE8491876D72F98\
-F2E7EEA90C12907210D6859053ADC7178B87BF8B4826954D6986FE761E71E1B7EA
-
-02:\
-B6DEE7375BF4385043B3CC2AC5CACBC14AD11A17574738DD2BD84D2D1E6C74E1\
-6066C2A5C35BC3B87839858AFB5EE5E8ABFAB408F38772866F6F833F39FAB248\
-3A2C34ED55AD7098F9F63D4EC70B7950F02DAAAAB10781A0008F993C4027E381\
-6BFD45C52F59452A7B28873513DCE415A84FC8BC06601567F91EC41647DA2304\
-5B6E01E24516724ACC02947AD5AA2DBA4D952BC4F49D18ADA0B0F7CC5D488814\
-B921C0BC2B33D8828D80130DF7D79B0992CEC40D3BC7217D4A4DFF3699345E44\
-DAC968575194845AA7B60DCF3C712D9B0A384824C3579B40DBA265457D50F69F\
-02A140884D89B7FDEE9F0A787E76A37C58C92CF2D3818C72097D41B3FAA7AA95:\
-00AA5515CDAE5CD0F0DC:\
-30EECA6B48D796552F5A6A3C11F28D730FA077422CAAB34FDEB879AE0F71DF21\
-330E2F3BE5BF3A8CA372EBCD3DFA7C81B3398C31B0972D0B857926CB39732351\
-AACEB8276D52B9D82F9C245FA0F1CF49E785A2BC00FF27FBCF777F84D05BEF17\
-FCC0505820B029AC8F0CE17D2469372CE47E1428BB941004FE170EF87163E072\
-98EFFCC1BFA7E7CB1F572C340CAA075A5962A15B69CE937BC7EFB492F501FC88\
-CBF0119C351C8498782091EF6EFB19120195E5FF51DF86F90E90FAEB225AA2EE\
-43AB4E8358101C0348C7E3859B9DEBA19464C74B74AC48A0B73FC8D2E7F8033E\
-86208F0792B6E5B6DE36C99DEF604949811D1671EF6B0A4781B4E7A0A72AD855
-
-02:\
-B6DEE7375BF4385043B3CC2AC5CACBC14AD11A17574738DD2BD84D2D1E6C74E1\
-6066C2A5C35BC3B87839858AFB5EE5E8ABFAB408F38772866F6F833F39FAB248\
-3A2C34ED55AD7098F9F63D4EC70B7950F02DAAAAB10781A0008F993C4027E381\
-6BFD45C52F59452A7B28873513DCE415A84FC8BC06601567F91EC41647DA2304\
-5B6E01E24516724ACC02947AD5AA2DBA4D952BC4F49D18ADA0B0F7CC5D488814\
-B921C0BC2B33D8828D80130DF7D79B0992CEC40D3BC7217D4A4DFF3699345E44\
-DAC968575194845AA7B60DCF3C712D9B0A384824C3579B40DBA265457D50F69F\
-02A140884D89B7FDEE9F0A787E76A37C58C92CF2D3818C72097D41B3FAA7AA95:\
-B8E2FB9EAE22FB2C0021:\
-416D33F8C213CF81F805F54FC1D4E7C6A588A0965F1C9CAEEA1D41452E20935A\
-AF2D30F957584B56621035430212A428E27A2F687CA9DBB596C19864AE692EF7\
-BBA730F3D70CC2DDE15AB71E1E350C0C316EFA1A831ACD1441598B112482487D\
-F72F58ED318182C7CD0906FE39C5655BF1313F29A15D60A6178CBF600C7FBFF8\
-994840ED649C3C4026A463B3EA39C692B7D112B128BE49E1E32D4A7FF8D45132\
-83D8DCD9CCB8FB7300BE0BDD4C44DAA2F7049B3AD83437093E623442AC69B489\
-11CDA21E95E0775041F67F6E6AE01DCE646AEC20908E7C1B693600FE41ABA85A\
-C0C778641E46C419083E41773C749DB3E1BD8FD764E271860D2D7F8E11BD6AB3
-
-02:\
-B6DEE7375BF4385043B3CC2AC5CACBC14AD11A17574738DD2BD84D2D1E6C74E1\
-6066C2A5C35BC3B87839858AFB5EE5E8ABFAB408F38772866F6F833F39FAB248\
-3A2C34ED55AD7098F9F63D4EC70B7950F02DAAAAB10781A0008F993C4027E381\
-6BFD45C52F59452A7B28873513DCE415A84FC8BC06601567F91EC41647DA2304\
-5B6E01E24516724ACC02947AD5AA2DBA4D952BC4F49D18ADA0B0F7CC5D488814\
-B921C0BC2B33D8828D80130DF7D79B0992CEC40D3BC7217D4A4DFF3699345E44\
-DAC968575194845AA7B60DCF3C712D9B0A384824C3579B40DBA265457D50F69F\
-02A140884D89B7FDEE9F0A787E76A37C58C92CF2D3818C72097D41B3FAA7AA95:\
-8C8C306A629373BAE647:\
-0E9A00045FFD399D9DA9D0D7E543CF9FFD098BC23E72DD7763A64F22C7F0479C\
-E866E31438B8F7DE31A18F35AF419BED6C67BE1540614D3310DD24F019E14FCC\
-3AF73743F4C143D4B79CDF35C752A300F0A8251CCFF4AAF18785C533A7DF1A20\
-AFE6770DEBD1B8BA2C83B2E345A04F833CD173E998FF9840C2F8A370FFDCFF5F\
-D95CBD71B25FC9972192470FD145975344F64C2F6D68CB3513F48F9FC070021B\
-EE8F6A4282D098C44DF655CE415E89B97994AE3ABE85986C7EE0AC348EF2A4F5\
-2D102EA80836E77E81AD3678803E53C83CF2F30D2D4950FB6B038CCB3F2690A9\
-381EB34D6C09E88C090AB05E28047DC490EB8A1282FEB38E82FB0B18309284C4
-
-02:\
-B6DEE7375BF4385043B3CC2AC5CACBC14AD11A17574738DD2BD84D2D1E6C74E1\
-6066C2A5C35BC3B87839858AFB5EE5E8ABFAB408F38772866F6F833F39FAB248\
-3A2C34ED55AD7098F9F63D4EC70B7950F02DAAAAB10781A0008F993C4027E381\
-6BFD45C52F59452A7B28873513DCE415A84FC8BC06601567F91EC41647DA2304\
-5B6E01E24516724ACC02947AD5AA2DBA4D952BC4F49D18ADA0B0F7CC5D488814\
-B921C0BC2B33D8828D80130DF7D79B0992CEC40D3BC7217D4A4DFF3699345E44\
-DAC968575194845AA7B60DCF3C712D9B0A384824C3579B40DBA265457D50F69F\
-02A140884D89B7FDEE9F0A787E76A37C58C92CF2D3818C72097D41B3FAA7AA95:\
-FA95400C2B14E064F76A:\
-3F67F9DBEB88E6AD057BEDC3D97030555A908867EC578A6CA572137CB61C2103\
-6AADE6DDC5592EC7CCB6B263E51B4C886A51904C858040E493D64B9ACE5BAA50\
-C4A66D04ACCDFE0039D8541C4363DEFFCF93BDF5F5CC1FB64855D956B5EFD42D\
-4C9B96B9CBAA97A32F02AAB307674E53404E6836DB5C96B59572ADBFD1113B87\
-608ACE6D0898CB02E35575CC28D38A9FF8C1C4AD36BAA991DEFAB533F0A6C9C2\
-F0F0815F1D659ED576E5DB18494A54B6817D9E34A134F3B9A0F1E8C77FC204B6\
-EE087C0445A7036C935117E338D092F6E1FF4DF7605525C409456A5195233A17\
-6B29B2FD8FB2808D0412FCA0541B2BB6800BD8BB9DC9DC25230166071E8D961E
-
-# Format: KEY:message:k:sig:passphrase
-[DSA/EMSA1(SHA-1)]
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBGDBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQIKioqKioqKioCAggA\
-AgEYMBQGCCqGSIb3DQMHBAgqKioqKioqKgSB0C1Q0dDyQ+/aB6Rid4iU+Kytf/dl\
-y0cmCXyXGWwZhoc0fqq9FwUyoxDFkZgpdYCgInJvW52O5kkgAAYYZdBSziQU4E7n\
-I6KUeZDYDqJU6VgkK9V1k4JoBKS13L68NwLawvXS+iDcSUoV3C591ynOVMeGsMgv\
-FLhGimZW7KaqaUVnqfcHuKp8UfboW6aqrjknltDeHixpTOduOsTzJUrxGMM/o/iV\
-BKSYqmkNrJmNIq0kqOyYBvxgwsfYO3cBPkB5gVBK1qtlg/gwsAA/sDOqyLU=\
------END ENCRYPTED PRIVATE KEY-----:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E:\
-868788898A8B8C8D8E8F9091929394959697989A:\
-19F24178D7369B619E566C5256C49EA648B68CC22C1999EFC24BD22471563EC1\
-5435356577466CAD:lrbbmq
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBmTBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQIhoeIiYqLjI0CAggA\
-AgEYMBQGCCqGSIb3DQMHBAiOj5CRkpOUlQSCAVCe8zFeu43ErHj8bV0SwfCflqCh\
-WsKecYnHronPutGoumfIOc3vAOsm+H7MdBv7RI8VYcoSd7ccVKCrbrxT7sYpHw7H\
-2gxq4I3IUDjDRr/IcuDCzztP5fm5dcuIgs5qDZdqphYo4L1BNs4XLphK4E1RqW6T\
-UfNHUzrY1Rh26x8HRgd1Zr7O+J1A2ZvlopHIpwT6Byb1SQBiwvI2S3P63yPeqDZy\
-s8wDfcL8+xbpKu8qVN4/D33vQh4F6Ptmdv0xXJuQUij820h+LcFhj+0xRmUae9PB\
-dp8ykyAS5QB+29j2R5YXR93ANtH9q6uAWeRPv08XryEl9WBQy2h6vPOM2NNJJAhw\
-V5rx1HHa+NLJHPaSsTtgiXEC4/9HeMRNIRpwm/aaYyUtx8Y8zamXNf5sfs/RIp5Z\
-n2XIqLzaahgk+xm5C+pqqMAclBkLhT4iX4GvcE0=\
------END ENCRYPTED PRIVATE KEY-----:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E:\
-DBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEF:\
-4B4471C82B030F2C2115B65309DF23A8B6AE1EEAE0C4AF91DAD7CFA7D3DFC6B2\
-5D5FE99E7FE4BF62:cdarzowkkyhid
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBmTBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQI29zd3t/g4eICAggA\
-AgEYMBQGCCqGSIb3DQMHBAjj5OXm5+jp6gSCAVA3igMQIZIcNy49pBMJeSd/a6q0\
-oICNlYtfNlACbx6K23do+QjlwjgUzUkhpBWzVVNzSxNI7mUgqcFOF7OrBNQWldl3\
-F940k5OrNU0GZCPhZLIT3cIpkiyXSN+DGpMTH5pis+g5f2IG2TKgTz+fVyZ39qUC\
-Be+9sbTVElrF5eYjpMsGzgZW8t33hHH5hvpiXjCqKl49IApI/56EoATwYV/JHJRI\
-sC4m4M+8zYyXHJRiUMnLFgEZK+8M9S8jQf/tXtmT7Ua4ddc3XAhhSJ5zeRupLSI1\
-KEyKjq9T0uf3snhslzw7Vk6XRiUQS9I+QGnfXfW2ZLLji2gA54K/C+yC+UaM2yrV\
-HipE6cWA7f/uWQH/Hn9Al5vjWnY/Vb0WHx54lYVps9Mlaga5vIQcFsxrTS1ZQvHw\
-bygjEqFWhZNCSDQjvvFnelOqKOoq6cYcWmfwSeQ=\
------END ENCRYPTED PRIVATE KEY-----:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E:\
-A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B8:\
-76EC77EFBCE0F6B01C1AA676ADC3AC6409950FB79EC0DD25E6A76CE85447715F\
-91AB563454FE3242:scdxrj
-
------BEGIN PRIVATE KEY-----\
-MIIBSwIBADCCASsGByqGSM44BAEwggEeAoGBAP795cm2680csLqzJLxt8vzriDGR\
-5cPejI7Sa3BtZNF9JkBLExBeClf891HGVhmc59HI7CSkVwKycD/HXXmNE6VCm4Ju\
-FmT5ENfw3OERv7Wac7sI9PenVT8qc3vfVi0lRcSvx9vXlfqNEEJBWIPV+s03NZLv\
-AAOKv0WQF0B6TtIRAhUA1wYYSyBGcR6bjdb2mt7KjxgCNtMCgYBO9ZCSK5GnL8Lo\
-Mz2/fQnl+/Gtu8REi6ZiwPDrMhjS/7DsLq9eL8OFzZAh85q0rGzVe0d2tow0bm6d\
-DYINiLcmiuH1TwRqYYvOecg2Ek3K/+w76b4An8IY/vtvg/9nx1izTuhyEhG7RZr3\
-yV9bc6caqfPjcIppb6FZ5ikOeTBR0wQXAhUAwi5MTj9OW+mLNUQQUTiUFOy+ZMs=\
------END PRIVATE KEY-----:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E:\
-A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B9:\
-22E16319CB7FCC90CA03D66B1550FBEB6121AB426E1AE3618A3F8A65C0457A91\
-E1E80D6EB35C8277:
-
------BEGIN PRIVATE KEY-----\
-MIIBSwIBADCCASwGByqGSM44BAEwggEfAoGBANsWdaItyazuSLhac0WrnmYSEKcO\
-ydCRzbSxSvp/QNn46SVucs4UdyCm+YqGchYVdL4MGLNu4H/VXW4D5vU/206YEPm5\
-sqLj0zba9/hohpwb+vHTg9Ak/EX/E+mr8z28TeHkg3LRX18EclzHjKe/zl7r0WlS\
-MbOz27LP4f5uKBUTAhUAyr5cJPSqLKo/EFDJsuzXb1KFgg0CgYEAxY953m2fa6IF\
-vcOJtSpk8KLe/8ZsGbugnFHBaHz+QWt+2sJauf/eTh2hyi48wEmWsAmyI2Jz64u5\
-WrXdJG6Y0DhcwJhbKts5wbztDIL3NAWxuppyGd89dJubaWElqyat81bQtIf7IuLB\
-KgXoL1Ci6BznryfA7cuv3ZPe5aefsgoEFgIUM6rqDcBQGunu3douZ54MG5I7Ve0=\
------END PRIVATE KEY-----:\
-426C696E672D426C696E672E2053686F75746F75747320746F20744F332D6833\
-723320616E64206C306E2E20416E64207468652052656E64657A766F75732E:\
-9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB1:\
-033A7684B382E2D2DE424111A110A7A326BA2158AED4BAC034815B8D3CDE92B2\
-D71A5CE03092079C:
-
------BEGIN PRIVATE KEY-----\
-MIIBOQIBADCCARoGByqGSM44BAEwggENAnkAwD9dAnTwxHobWWmnm8IVsVZuKY8w\
-cjg4YwWmib0iv+wvwhiKon2XNhbtErdg9uqnTPXJJ5dYAVf1cq11jKidgW37g0P+\
-J046VzuAdGjtWaxqcP8KuqBPIu72NK8c6Q2q59LYYS023XY/pvEf5JRSkmk38bgY\
-CK0pAhUAsPZ+YCHrRD4mQrzJXv3dtmWJumcCeQCwP26D/4ElPV4uQ9QilY5wcprT\
-ZzTGSzXTb8WAFHTT89dJjlwqQpAdIiBKrJmyKfWTEpqWtVMr8ugcGhdA1HjOzYTD\
-hsD2kOIYFfuKXmP68902Mpak+WbjsnLaJF4KfC9PrzUL/6ZGF+YSFexN0KvP1rCo\
-eno7RrEEFgIUHmzIejm5tPDB8oEZD9WD+5zm7Hs=\
------END PRIVATE KEY-----:\
-49206F6674656E20646F207468696E6773204920656E6A6F7920617420746865\
-2074696D652C20627574206C61746572206665656C2064697367757374656420\
-77697468206D7973656C6620666F7220656E6A6F79696E67:\
-8788898A8B8C8D8E8F909192939495969798999B:\
-4AF54C9F782C3B4B1D5000985F684B64D5EF030F7952FEEFA06475487BAA979D\
-AF382E53BE6C4D5A:rcby
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBiTBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQIh4iJiouMjY4CAggA\
-AgEYMBQGCCqGSIb3DQMHBAiPkJGSk5SVlgSCAUC8VXV4fX+c+kMB1JpVinAEo/XN\
-U9LzjtAS6C4hUUV5VZQHKNKp8HiOdc65BWrpLOPc72kuNAgb+KjYunVWSCD6k7pX\
-Tm1XHIhbm54dsLynwY/F5jiNcSVKP0115E+WuJ5A4ps6sO0mk/UMzmH6IMmmNeK/\
-pmqK+Gcw63tYchYNXoY6gYAlEHlxF0QijPw2mV93Jl+pxWEwFvkttGmtPCBwCXLx\
-AdNRy9B4RSeaNaAMcALM0X/IrEx3owhoV9LAs8fUViJlVlI3BuVNofXCXeMU2vxv\
-Ax8d3H+CECKAMbtyGL8tBmVE0HKd5ubpjGQpHBW9egaagwSNvQFiXJKAUm9ST1uA\
-4iZgRW0sOEOyNNgWUbxUoI+OYmcDiMbGBzv2JeO/yVFQolmgzflqlE6L3JJ6yqc6\
-y6wZBPcO7I4uLnzuIQ==\
------END ENCRYPTED PRIVATE KEY-----:\
-49206F6674656E20646F207468696E6773204920656E6A6F7920617420746865\
-2074696D652C20627574206C61746572206665656C2064697367757374656420\
-77697468206D7973656C6620666F7220656E6A6F79696E67:\
-9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B2:\
-00F04C3A7E9D31CC7C76BAA9246F5A0BFC3B552BC3593C856C5AF7E7E7B2224C\
-05445802A7D726C6:cdyg
-
------BEGIN PRIVATE KEY-----\
-MIIBOQIBADCCARkGByqGSM44BAEwggEMAnkAtqJA6Mv/8I9ZVRd/288VFQUCcTPA\
-qkAfIn9ZP0aUqDJfRuchnUFrOWkzp0QUTA0eFVMwt3T+R2iL7Rp7HwFbAXLictS1\
-SzGX2CSCgOS4xGDYb8H7s6n/U4twEdQQfRsqKu4Z+gSdpfZStfFKZ0dYA9skEhI8\
-m7NPAhUAnoE2PuOpzxxrKPJtMLBvcW3m46cCeB6j1vT7dpPk4RV8L79QL7S5aJsn\
-5uK9HR3mIdntB2OXTm67qD+pHbVZuYfhrtrM97e72jopd/diGOlwZ0h0iL9xklxq\
-NvSlcuvRWCrlXk4NsJnUGm+fY6YUnWWuyhVVW/rLdD8xwkqP/us3TBdzN6Hhwk1J\
-oB9JKAQXAhUAlmo1ft2RX6ivJhmvitzUcFwvvOQ=\
------END PRIVATE KEY-----:\
-49206F6674656E20646F207468696E6773204920656E6A6F7920617420746865\
-2074696D652C20627574206C61746572206665656C2064697367757374656420\
-77697468206D7973656C6620666F7220656E6A6F79696E67:\
-838485868788898A8B8C8D8E8F90919293949597:\
-01224EAC2D585D92840280C76FB57306222E42800075D2AB872F08A8709651A2\
-219B1E7FAF242103:
-
-# Format: KEY:message:DER_sig
-[DSA_VA/EMSA1(SHA-1)]
------BEGIN PUBLIC KEY-----\
-MIHwMIGoBgcqhkjOOAQBMIGcAkEAp7fQiSIN41Jmp5D6sTiK5uZqM+NRrtZHVPwP\
-gicmBY7jLGKeSK7CNlaPTVkgKeQ04p7YCyLfMWk33vMYiAndOwIVAOoV8IwGiIXb\
-Rcm44dWRfdsOJI8BAkBUtk78F7Kf8X7/5eapEczOy4i8h8F0QkYQp7CZVONaPi3T\
-i2HA64tp3zM/z1WEEmO6wC4I5UrY9a84ckwLIwp8A0MAAkAS1f/NjG3z1z7Fhx7x\
-koG5Oitf7m9ER3YzYJEe/vQ1mtDcgiNnAV33SOCz02jfaFr7+H3AdI5KzDXTB8HB\
-2sQw\
------END PUBLIC KEY-----:\
-00BF86875B7DE45A29680AD78B41CF13BA70DA1DFB8500:\
-302C02147FF68E7723C6D6718D4B5BFD04069D4F86F48A1402147E78482F2BF0\
-37283BDE610C957E75CCFB5E1785
-
------BEGIN PUBLIC KEY-----\
-MIIBUTCB6AYHKoZIzjgEATCB3AJhANh0wGx4pOKnBg64l80gNBxTm0ql7BlotR9A\
-jFdGqVBK9BZTU7sqGRSgQx4WLiLvJZB9VRmYo0pBWd7/YKS/yufwytojoirhXhz/\
-IG5KkKbUZI+uWnFUFD+8YBiJo7hYtwIVANVZFYUPbGdHhTuhnGII8o33i3yHAmAr\
-nFyiH8nbC3hVOFq/ba0ftJ1HD/gRIKIhdjJP+BmDb9epR/45W8dgvPwZr8NCix4G\
-iJhaDt3B5ozEsFVtG2Wguk9tONZocCQByx48+tP0ELWhfHvsSv+gMrd+AeVzg34D\
-ZAACYQCmvNmEahHpA348XBaXHK9qVJIm7JIS9v1Zx7w10UUSe9fha2BKH+DCirfL\
-HVD5L1Ll3mJVJH/j+uO1PMZu5Sbuw7SDN/fNSMnpU/0krR8eZ65B3Strd3tM/vQ3\
-fS083Gc=\
------END PUBLIC KEY-----:\
-E58DEDE156818EFCDDC72022EEB5D457CF25032BC6:\
-302E0215009BB427CCD68D7269D3692A29489026F9AFA71745021500AAC0B52E\
-5C8BDEFD0E7B3F81189C50CA8C46A3E1
-
------BEGIN PUBLIC KEY-----\
-MIIBtjCCASsGByqGSM44BAEwggEeAoGBAMtC1tIjltuwKtWprTwYrEpO5ClbyUvd\
-BTIvUuYLrAaai7mGCSXbGRBXAHPS4hLQjUPZ7JuWYiLA2/WEttUP0Ai8P+oGsMKX\
-DIP31KifdwNHa3jckrPS1mMgA2xVDm/nIM07HxquQ3mXuM3YJ8Di47yqvlAoOeZP\
-e8fgPLe76zPJAhUAwy/14/bLpyDtp3898V+kSbHKb+ECgYBHUenqYLWd/ZNUXWCo\
-hihbT2FmS8kxCjiVsqhAd1YfXe+KyPKR+N5r2qfwoN87L/7jNO6Mm90T+OxEsfKu\
-HZMBAwwOXN54eGBjiJhQYAAryMQuwFV8KICbgOG8FyJDUjo9P6qaqmezV1ibqqsr\
-SVqHE6BjEgqU7T7ee6JbhdHWyQOBhAACgYAJDkq1oVGgIE+HdMGjj1LPclk51Euk\
-Fd1GMt+RLxB7Yt6Ism0txDoBE/aTbIi/b2bNCShn0y+Sr8+KT/6kYElwIfN9y1ZZ\
-mFlp+idxV25J7VpcMnSwlkaFuP+gmPkesXImQafs1NAgMvbLtAqmARO8OX3bO3o6\
-fz7eifelYX+8dQ==\
------END PUBLIC KEY-----:\
-EAD985D13D2A1217AD620068A2CF985F031F37BD22:\
-302D02144CEAA8139F1A477CB91B77B9B20CD66F13291B0402150082191AD5BC\
-88067D833F7DB0629527B1A19EF36F
-
-# The reason for these tests it to make sure that EMSA1 shifts the hash over
-# properly (because the 192-bit Tiger hash is bigger than the smaller q).
-[DSA/EMSA1(Tiger)]
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBCDBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQIg4SFhoeIiYoCAggA\
-AgEYMBQGCCqGSIb3DQMHBAiLjI2Oj5CRkgSBwErzYywRqfwW9IxzqzsovFjnZK0Z\
-KNpUiGOk4CJxENZd0/qt6ap3AaspM9u9xsfhO6WOK5eDimQDpN+lBsqhrKbmErWK\
-9ngRAE3/vj6DlO5RHn01E57fr+aQE1kigjhHaNPwAYZXEKlBqS1SxSYd26LlwcjT\
-JrRqblCY4cBjCBGtzvVJK3escwTELNTZGgTr4X0A3sX4jCs/b/+MRt67cfb1SYOI\
-hmojiK/EqJ978yCZu8YPtQFo68Vq/RTuaHvUEA==\
------END ENCRYPTED PRIVATE KEY-----:\
-54686973206973206D6F73746C792061207465737420666F7220454D5341312028736563\
-6F6E64207465737429:C40DA376ACBB379890ACDFB021E02A:\
-041A7C1033F50A295DA0C4D436BD612466FB65ECE1357D4770BF93413F2F:\
-lorellnmpapq
-
------BEGIN ENCRYPTED PRIVATE KEY-----\
-MIIBEDBDBgkqhkiG9w0BBQ0wNjAeBgkqhkiG9w0BBQwwEQQIxA2jdqy7N5gCAggA\
-AgEYMBQGCCqGSIb3DQMHBAiQrN+wIeAqKgSByLDSSPDO/Ck1yLY91WOlFZzkM+jZ\
-P4jSwPOiJljd7+2i7+zBAe2LCkVyQZ+WMsScjNVvmYvmP9wucmMnj98XdpZuXScd\
-1GLkFurNB6MFJqW/jKUURrHWEwkIZiUlKVObnDyMdAk6PS/xpfRkDdQfqIvCTsyf\
-X5uscHniJlAfqUMAsiMUGUgyunrZj63DVpoP89mj4E6Ep6WuSmjF48QwbAHuYPBs\
-gwCpLRTCgr8EBF0WtZT+V4RzTmAG1qYyYEV0wdpiG0d5Pn7M\
------END ENCRYPTED PRIVATE KEY-----:\
-492077616E7420736F6D65207069652E:8182838485868788898A8B8C8D8E90:\
-6DD27F32F0012698CECB2D8BE550ED662111608A6586A481CC7E2E4C5CB4:\
-khopkmcoqh
-
------BEGIN PRIVATE KEY-----\
-MIG6AgEAMIGhBgcqhkjOOAQBMIGVAkAA8HR2W1fHj8t8G9/BzpO5z1Ea5YnMTwMS\
-/ozvaNrdRuRf+RuNGAEer1deRluO3BrQlknECrK+0BxpzfPT51qPAg8m1F08NAua\
-+OtE3W4FMysCQAC+p3SjytVnkwVRSkxKcdSsbBv9NbW+TGQrxWE6KqfRoxN/Tov8\
-+iZbtXywoSMLpPjP+oi/LQQtJTV7B07mRwQEEQIPJIiuAFmX4/IH2oOwMoAZ\
------END PRIVATE KEY-----:\
-54686973206973206D6F73746C792061207465737420666F7220454D534131:\
-25ECC0ED4CE7118A72D133704D002A:\
-14593FBF63EAC64976987524044D8B11AB9A95B4B75A760FE22C45A3EFD6:
-
-# NR Format: p:q:g:y:x:message:k:output
-[NR/EMSA1(SHA-1)]
-# Trickiness: in some of these, we put a leading 0 digit on the nonce (k). This
-# is to work around iteractions between the way we generate the random numbers
-# inside the particular algorithms, the way that we 'fix' the RNG so it
-# produces the output we want, and the sizes of some of the numbers (usually
-# off bit sizes, eg not a multiple of 8).  It's a horrible hack. I wish I could
-# figure out a better way of doing this...
-FCA682CE8E12CABA26EFCCF7110E526DB078B05EDECBCD1EB4A208F3AE1617AE\
-01F35B91A47E6DF63413C5E12ED0899BCD132ACD50D99151BDC43EE737592E17:\
-962EDDCC369CBA8EBB260EE6B6A126D9346E38C5:\
-DE0B54EFABF297087EE623D5CA5588C64828EF4FDE4FFBAE1ECD2006776B05B1\
-1B81EA3CDE9BC3964C1687C5325BF43D7CCEFA0D0A86BE5DFFDDD0D1143DCD75:\
-D057B29DA96809BDC761F3210E467BBA5931B3C406581B268121FA5625C2F850\
-8B95ABC87CB061A8C32FA04E67397762F69A23ED42ABE051BD761DED4BD61582:\
-78E2D47D180E4EADD866235F5CFE0E487E862226:\
-FCABA2CF434AC8DCFCEC:\
-91F1D3A9C129D91120EA3F6486A079AA695AB632:\
-44EC399FAA3853B7F7313FCCB3A30B82B20A18C45E53188FC58B0E3C141A0851\
-BAEA0A7723C71A94
-
-DC523995E25A96ABE93502691F3411D3A6C19AAC218404B476913794A81EA8E7\
-8C3F8A60E6A05C151C61430743C19B4F1BA140EAAFB0235F93E83CF2995FF0F3:\
-BC1624A28732743BBE9B1A2B320CA31EF4A127456547ACFF:\
-829D8EE7A7221DC83F22F85FB5FC955E4D1E30563151D87AA82F1466E379A991\
-3351026B996C05413B01AB6E1AA83A8B3A30F0BFF50E118F0806A59209B3DB91:\
-8F8340D8E87FCFDE0BA81B45003DA97B7FDD21B4C1F256463507E56CA0F0FD25\
-FBA142C93E23AACAA89289379B953FA55B3E143164A035E470104A9A984B083A:\
-4CCBC8427B955CE5D0263D682AC2B8BF7861ED6226B848F8:\
-5075752E:A876034938F576056B00569E4706963C8B28D23E03AEABE2:\
-3097CCDF824E2BB33089DAA042551335625D9802A2BDE54C10810881157C8DC3\
-7E2ADC8195251FBE040B919D56512F57
-
-19A61288F2865F83256E77DBD8D651E6481A3DBFFD5F76777ACFC8C7F7F67BBF\
-112ABE08CF39A751295EAE6D388DA7D469CD312DA63C024304948A6C6AEC9732D:\
-1ACDF5C523995E25A96ABE93502691F3411D3A6CB:\
-50438F2395561269EE8DB64D7AB5602F3BA1544BB997A33CC5090B24B0911872\
-377669726D11BFCA63922CC669DB9D4B87D031079D10990012FFCFC54BBC8068:\
-DF49BE748682A13BC2EDB80D5E4C793E429F6F5F1F042A18ED8515529AB2F1B2\
-1E0F9E824C3F6C65FA04DB99E3D8C6A1DE6E052EEBFDF98F5655A58680A964F7:\
-16226B848F79E4E38E49D072AEEAE3AF4C3E1CF6B:\
-5075752E:019E4706963C8B28D23E03AEABE27C7B294EEC2337:\
-006AAA75DD2B3A7AE867D2DA3581D04AE2AAA5905C0074F8C1507136682A93A2\
-3A89504DC0FEA5603946
-
-2AC218404B476913794A81EA8E78C3F8A60E6A05B71066EDE730E7CEC8993A6E\
-6296EA8DFBBC7D46615122FB2F836005517F32C1DF25ABCE53CAC404E95E72675:\
-1ACDF5C523995E25A96ABE93502691F3411D3A6CB:\
-65052FC9728732E830ABDDC1AF7F1DAFB410BF1FB02A5414D718DDF0A867B8F1\
-C22EF2654B66C4EC538F34A4BAEE73981F86D07366EB672D2EEECFC347EA4674:\
-29F696C36E3BDF9B3945A031481EA7CF153ACAB0B689CAB7B799FFA9B5042929\
-234AE9C64D72690FDA8932E7C9AA808ED242E5E06AC68279544CA0B0BDC21F7F:\
-120FEB207F73754A9A42CD019FD2AC263476AF3CE:\
-5075752E:019540EEBCCFFBC202BB81AD78F1E046F4D4597F53:\
-013D9A09041BA0E9DD2ECE20C5042F5442DD14C8F00113A3C080CB2B8FCC156D\
-33E7FB8966032FE1570D
-
-C7ACDF5C523995E25A96ABE93502691F3411D3A6C19AAC218404B476913794A8\
-1EA8E78C3F8A60E6A05B71066EDE730E7CEC8993A6E6296EA8DFBBC7D4661512\
-2F23F635FF988E284E3018C2C5347734940F7A0B045A5C9A61288F2865F83256\
-E77DBD8D651E6481A3DC0CE0373D9A1EC8FC785D39DBF228112FB58056F7B0E9:\
-C1624A28732743BBE9B1A2B320CA31EF4A127459D:\
-92EC521C2E2C415DF4DE9675A934648149CB0DB1BDC2B11A59D276B1408DA81E\
-D2070E5A311EFD6D7A01B1D327331A7D5C830B781B9CC08D385EAB22AECFC558\
-3052C387ADD3F5FBEC04C1240BD3F48CC2482334F58606C0EC62DEAEEBFF0AC3\
-BC4ED688EA0E27DCE1FCA166CF67741D1FC0EBD7F19E10554C5218C0A5FA7BB0:\
-C0F8288391AC019CC4CFD7DEB3D85ECBCEE4386A4655E9FE68AB66B30098C7B4\
-8601B106B3EEA4F5D71995BB0FDFA27870B83ECF6F7EE4842B2C623367AF864E\
-0439A3D1125D7E697B085ED98AB85981D4C72BF10B2E2DDE9FD6D53D29D68AB2\
-DD87122F58EB8C8E9C52E2C1E346A192F12CCB472CD54DAF600E0E93EE06DA19:\
-64E6970384247DDE2C94701DEE2BD4255785BCA10:\
-5075752E:0AF20FE4162B721067160E55F9BC980AAC8A51BFCC:\
-05B325CB3BAC1A189B132F8F88DB1389958604305104AB71A2C77D8A9C902655\
-9C2E1765D44A81A1178B
-
-1ACDF5C523995E25A96ABE93502691F3411D3A6C19AAC218404B476913794A81E\
-A8E78C3F8A60E6A05B71066EDE730E7CEC8993A6E6296EA8DFBBC7D46615122F2\
-3F635FF988E284E3018C2C5347734940F7A0B045A5C9A61288F2865F83256E77D\
-BD8D651E6481A3DBFFEC15AEB9410B3CB207A15FB0737509DFACD160A39DC3:\
-C1624A28732743BBE9B1A2B320CA31EF4A127459D:\
-9C78F55BBBF7C3B8AC9EE5F94F3DD9A20A521F933FB57A035CF27659EC01BC859\
-D1DE6F187791E92DD4F6F547707B7DB7586678E7DCC58F08897E3E552F2BB2ECC\
-61F4F06F4685F382DB34EB23ED93BF22FC7FC2E9C0A4151344CD22AD014B0ABFD\
-C715A199E4EE599F09967E07282624F6F520FE79752B94FD6B32A1BEA8D6D:\
-4C9421E17B605A89976C7274DA20BD5BB94DEAEBF07CB926B4D33C9B9C1E5939E\
-4BC1DB1BDA3CD1CD7828F17456666D243CB05DF5C02B430B25D41EB5E6CC466E6\
-7A5AC7D89EE3830690E3590588EA0CAD1883E299D2B9984B9234C6A49194BE1BA\
-31D5CD8F744177064622E696318B4C15AC1C94854F63473F695F2F517807F:\
-69E4706963C8B28D23E03AEABE27C7B294EEC2338:\
-47656E6B696B656E67617220466C61726521:\
-0A9A8513912E5A2AA2375A50A53E505C0F8D4D0A7F:\
-082B6655BB32ED12D90CA95B8DDCBE36DA1DF3C96F009F88917FCB93F04D6198D\
-438A1EF1FB732914332
-
-3ACDF5C523995E25A96ABE93502691F3411D3A6C19AAC218404B476913794A81EA\
-8E78C3F8A60E6A05B71066EDE730E7CEC8993A6E6296EA8DFBBC7D46615122F23F\
-635FF988E284E3018C2C5347734940F7A0B045A5C9A61288F2865F83256E77DBD8\
-D651E6481A3DC0091CB01E4ECF2CE88F83F8CE4E39290A544519A92FAFF:\
-3C1624A28732743BBE9B1A2B320CA31EF4A1274569:\
-1CC1C87EDAF647CBD7356D6B162BC027C549063734D50446C9FD5DF04EE59547BC\
-B4022D7BD4784DDD0C890B3D17357E1C679BF2BF5688B647982816D63E1CE6254D\
-551211B03D7547B72D734152499257C0E8D45C33B192B62280D365B921881E644A\
-A31C11888EBAAF02791415F433C5635AF09A8FAC366797F40D18365576B:\
-E43E4F1FDD4D7C26D80916ED6A8E5748A4F900B2F6042E1FD2A42B55240258BEAC\
-FD494DFD669CEACD659F8DBBC7649ECBBF1B2DECDD1BE41142BC8A420E05F7A92E\
-3E23DCF021E8363E7027A0B896A456FE087A4CF5AFEBF5702FC8E64B82AE9369CF\
-BEBB174A7080F6911D4D03677671A7011DFB18B1E2B807FF1ECDACE6B9:\
-169E4706963C8B28D23E03AEABE27C7B294EEC2338:\
-47656E6B696B656E67617220466C61726521:\
-2A9A8513912E5A2AA2375A50A53E505C0F8D4D0A7F:\
-34CD8EEF38DE00C87C2281ADEA5A597E85AFB8BDB42F59C80618D6EDB7361EF766\
-74C0D535B31BDA3A9A
-
-7ACDF5C523995E25A96ABE93502691F3411D3A6C19AAC218404B476913794A81EA\
-8E78C3F8A60E6A05B71066EDE730E7CEC8993A6E6296EA8DFBBC7D46615122F23F\
-635FF988E284E3018C2C5347734940F7A0B045A5C9A61288F2865F83256E77DBD8\
-D651E6481A3DC00A927480187FDEA61E094D4DBCCD2A60F4B5E9F613829:\
-3C1624A28732743BBE9B1A2B320CA31EF4A1274569:\
-74C4E94AFFBFD290B2F15EF802B81F51A1F4C872687FE373BC410C9CAC231F8AE6\
-9F0D48921AB3497334E5D692E6DCF5F8A7A64C571E1DFFE0D4361CD3EE6B74FED9\
-5AFF2C67C616B1D6C9A072973B33510D86CD64080388D757ECE5DF8BAD1D4DA42F\
-021A35C5A7225591470AC32F8699772AE9562FDAD76F811F3131FAF9259:\
-3C9A8741FBBF7AC5A245F138922CD64EE798B62AA99931D050A71650D12B3FFBEF\
-E1AA95450A6DCFD526D9BE866089BD400FD2D6F4921533F5BB10FDC559C67FAEE8\
-4C75A8A611A57D83E69E26991E2B3F9B1224B61BECAB77D249F5F83DF42B284E3C\
-89565EB5D875573A61066275D3A8D2C90897CDA7DC4D02CA0AFF4A14DB5:\
-169E4706963C8B28D23E03AEABE27C7B294EEC2338:\
-47656E6B696B656E67617220466C61726521:\
-2A9A8513912E5A2AA2375A50A53E505C0F8D4D0A7F:\
-3255F933B90A659F32A2CEBDAD6C3465A494A87D350255D303139C95B0B60D3258\
-A060B4510B0F26B22A
-
-C537448C630CDBA7C285B31E420F2BEA827EC72309E3D707251350BAFA3DB9FAAA\
-889769A43A2B48A08B46D18842BDA591EE3FDF95A3E3D6A2137BB273E2FB7632C5\
-D7F620122DBED2574A5C9F6F34123132A3A1A6F7C5E105C129375A3733245580C3\
-659A11D4FBA7D50C116FE2D9BA950D6E03A0D20FA083056B38B3A3000C3:\
-2C0094AEAA23065124FC9C8ED04E1006D9403F4BB9:\
-834E982235B6DB4EF6EC52025C56C3A5BB4533BBB83F99C2BD12A200A0FCEC8840\
-94075F74F9D7BD5E4C1F4FA719E082EAC7F4C8A7AC5799F9F614C974E4C84A0487\
-AACA50CB2D7ED3A1FDE75D5147D8EA9654BB2E0D19C807188A64A5B4FAF05A52DD\
-AE1EAFA74146E28A1BC61B8C57192CC404D139F760DD3943E94B547930C:\
-470421750B0C8EF53949D4474F8DE8ADE8CCBF57FB1BB29238968074D9D703286A\
-E7BB845F8BAF54C865FCBF89AC0668F7941A2EEF751D9E477543133CB5BA4FEAE1\
-59A877ADC3D590ED0AD0EBA0D0AC1134B7B1BBCCCAE4B26E1452C0A9308B476DAC\
-D13B3BBAF3B7764BE5C2D9805DBD0640CF2D82FAABB58A4C4F1322E11D9:\
-2B9C9338848ACEB05F7C4F412F401C769616D48324:\
-49276D206A757374206C656164696E67206D79206C696665206F66207175696574\
-206465737065726174696F6E2E:\
-2B51BC665CF466B2CEC3DCA92F6D8F0F02F6A4F05E:\
-26DA0260F10D5C283D85A29399B341384B295B01EE2B2BF011377942FE9DA24B07\
-1B87D83E4167B0B5C8
-
-1E9FFA630130BC80BC709C3FCA6F819848DA96CC300AE868236F4AE5F93ED150B3\
-7FF1DF910C28996364F2E737E574811F85DCEC79AFF30B76C4415E742A2519D596\
-ED1227EF561CEBCE6BC029A10B71BE3C88DA1486774B985F5AE5CA97B3ABF3CBDE\
-F7C35402BE0029AC89BEEB2E3BAA596D913B046168E38F02291023BAE525:\
-2BE48B895976B2E8C34B129EB01DD76697C0C16829:\
-C4AB3CB5A673050E19379A28C6A044AD1E85FB66C4D52DFB640B1ACC103D31242D\
-68B19E11F0058F6507E9582094393B43160EF231CF73588CB6B02C4884898EA886\
-DC2EBF9C85E0FA567464D649C17562A15E5CA5A6E8E2F93CC30454AB3DA0D5DEAF\
-833F78B734ED3374AB5FFB9A110DA42C27AD87762EFEB112EBC88B103E3:\
-14707CF4838E01CD359472ACDA71737D51D0BEBC61D0F825275265E42EACA744D4\
-587249D54F901C0BD4F64B0879D4035EC9EDB40C222A15C7113701F8096D6E5CAA\
-3288CA411C7C8DB6B923E933CB297760ECE68EAD0A9CF22CCA855448717399A8E5\
-94DA9925D0CE334BC8434C32CAA225026F03443FD0B74499F3D82127E830:\
-1902ECD8813827AE27FA8033C1DE6A65093BBA1469:\
-49276D206A757374206C656164696E67206D79206C696665206F66207175696574\
-206465737065726174696F6E2E:\
-260FE1BF1BC190EB4014A860AD06DAACF0E62B5C2D:\
-073B5E19E15868A062940B6904BC19083869FECF5E0FAA319A9FD3D414F405D16F\
-11D8EC0EE01B489277
-
-33752A90D9CB3CE0672B72DDC545B97314D990EA3B6B86BB493F1256737CC3EEE6\
-1B1390F29E5E6A733998ED28B04527E05A19EE0994795318587ADDD8FC45C6A0E3\
-B8D83FE78BBDDE6C8BF74BF1A11A1785CB13F894B99E536AB152F5CC6DDBE4DF0A\
-E0B3323085AD6C851D18AC2C6C7A5D9F6F5F6297049C9943F9A9C050DD4B:\
-3B67337DCC5D5318D237B3CC48D05E60B7CFBA17CB:\
-4085148908A5902F01579635FE4BA536F3C5FA00B458A178A2A487D8ADDB0BB4F0\
-6DB1D740975F937FDF4D368444F85E210FD2576242DD0FCA58B3EE0595AA85BBB3\
-73D72B5E03C2C26B6C9AAB1C2D29669AE586347649A011F7428E05F727DB6AF5F2\
-5DF9338D668866E48014F0AE18B84675DB2A1BC9358D1613EB1DBFE2263:\
-24C4791E394B5A015AF827BB0638ED99C394AE67A913A21A04EDD2DEC49166BE7D\
-15CB82DBC0A64AF31C0EDA89B1E7FCEA26F421931AC663215B71516E406EB2677B\
-A4C48C759EC28623833ECE3B2836EBE4FD2405A93695C6C15D8D87ADC8F34162BE\
-B0C2030D59417C8B7275076C1DD64B278051A4813DCF815CFF3325D0BC5A:\
-15DFFDB80E7F4698D43771C5F4ADE8C9CD4DFA9832:\
-49276D206A757374206C656164696E67206D79206C696665206F66207175696574\
-206465737065726174696F6E2E:\
-2C6C5DDC20577082E4711D5F1327B0A8EEAA166617:\
-2AB302E2CFF9D76ADF6B8B348621D5E9A3D8D68F982DF65DFC1E84A31C40C1501C\
-367752E42743FD967A
-
-6A4F538DD1BDFB47B448BB75B0B01837973251C2F2CE4D0C9075685333998DA6A2\
-07B9E5F6624B3F80009877842D334A8D23422AF7D74465A98608BF34390B66C1ED\
-36C83D3EB047DEFCBC62679BBE7D966CB9801CEA54BCA7D88D8511CC4B16A2BF4C\
-9724AA861AD69737FC86ACBAD6D7B3CA756C2C3BD07001741071F60C367F:\
-380DC2F4A7A781B34B0182939CCFAA95F837AAE5FD:\
-4EF29DC07DAEB84A86C077853672D2B37BC8B068923861685ABD55A95BAF109443\
-EFF1B8B14A3B8713E095DB5CCEB6BB52D90EB136699CD017A98F77DB536410B447\
-C70CA8AF4B940D957E68EC0BBE3415C496CB70DD95CBF1F4E63C789EB06DB4548F\
-0B073C95DFFABAE82FDBFDB740D188FC94298857D2EEA9BE482ECF228C51:\
-339533E7F3414DE16F4F01A63E2E8705956A63921433B6D01CBF87D2CB7FE174FE\
-AC1C11856344B017BD123642CFC91EF3B7403F79E88F1CA8EE5B4CCE4C6FD18F89\
-03849C722407D7B864AFC6D81D04A40A9578D004D3E9E4A8BC0DAE6D7BA15EA57D\
-60F486AEBC187343F299DB3CCD1602D70291EE1836C08D28723B9F0AF472:\
-13ABB2B93794CB0F4058A4FDB9B266E5AC74681017:\
-44616D6E20697420776F6D616E21204D616B65206D6520612070696521:\
-23AEAF18FB8F0D808218A587F86C16B16AA5DFA48E:\
-07D6C64CF9FF00D7B8D9191C160ABF50D61E3B90281C06D436B4CBDB6CB380E84A\
-0D0AAB183A11E527BD
-
-# ElGamal format: p:g:x:y:message:nonce:ciphertext
-[ElGamal/Raw]
-C2742F0AB4664BDDE65B66471C32BBD5A383491C1C8FE71A7525B5C301B1CAE7\
-A48317D2ABE8C078CEE424899FEC4D876891BCF3E401E4BF339E27C1ACB97E39\
-83ECFB81E1C74093E8206CC794DD180E5B646EB1D195455092859F981FDB3C39\
-47B179FD9DA4C96A1F716570149B0E5E91AFE7168F4B5B92797B1E374AED6097:\
-D:3571A939ADCC0E0A61F8FE6720372DA9FB130C33757B101BED87CF677B77F94:\
-380BF24E9D162C61E95E2E84EDC0F9E56EADF564F5BE33D7A46BC4E0BBCF9151\
-5129E2A547583E576154A216AC035C11523111F877A4B56EE4C459ED645C63DC\
-52D4131D865DD4BA8D057F9FC1EB77352A13037CA23BC2BDE49794B3AB5A611F\
-D106ADC74D9F48FEC91DB1EC77AE70EC9408EA0E750D1CA4B2E437E4233F3E32:\
-02AD1D776D591520E4D8BEF8B21CC2F54FB4EB788E52ECEBE13564435DA66284\
-D51A6A6696E615EF599786CE4CBEFAFF066E0A1CD8868454EB5CE0CA99241B29\
-E1D1492CF2712C2C101B3F3779034683AD8271098C2E3FBAA83901A97D9645FA\
-5815AF79F4F638ECBE09020003F434D708914899C668F34830E70F4CAF0803:\
-0A5842A8D0C1B07E5DE6FD3E0C6B1108523D4D35417F:\
-5B99F58B48F3D473327075F2FF4EEA3C8C1FEB0B241F042864610D6FC512A81F\
-431A965724195DB71C3B84B6B9F1DFAE0DAE60E7CDA957703D10FCCDA45CDD0E\
-F8C8F76AA4F51F3EDAD8E5085B97D69523A3EAC89D67CDFDDCF0A30491A98BE2\
-FD6C5E69C3A2C95300B9DB4EDF2111E7613EF7B2CA430D0CFFBDECF6A7BE592A\
-853B404B6910C48A0204ED3430691E766FBAF21A428B9F833C5932C053C616EE\
-B59850150A22331A8FB5AF2065B595E4F08881B1DB7CB85A28A33F4449890739\
-679CCAA431A9205210995BEA68759B475BE4183A975C9D042FBBEDF589AB6AF0\
-17D7523B2CC90CD63526BC584F1E9EF42ABAAA9238987D7F73B94E323C6AADFD
-
-FE25EB971E3488A92A4BE75E51050B0824E69B18AC433B5AE7DE98EBCCE8AAA6\
-301237489ABD17A52EA9759AEC87D0E90F7766D64096A49CA99EFBEC82049898\
-06F5C49479FCB6CE8B881BC28F19732F0325786E7DAC54F8C216B6C84562C88F:\
-5:CC4D3B878DB91C340CEBA8495CB5F703ED90AB24BD793E4470125CC:\
-4B722A9E2DC991CEEA1D596586D245EB9B8129515AD66688CEFDBF84FDFF8C19\
-4A2D2BCB2AA82C47CA9FBB3FFB86BFC5CB4676B4DC4A2FF006AC3D578010C9FA\
-E140822DBF9DC26CCCE1701B8CF08740ADEBA1CB94056FB33FA2E88DE84CD477:\
-02C1ED6A171875F055809F12BC61829961CC740935C6DCC468FA663E8D1A7DE9\
-E0555E3EA99476436743FC5C76D3E041055FAEB7641907F8E2F1F94061B22E72\
-B7CD39EDD7A6367828CCDC000301CEA7D91CB1E8A3E20DC85FAA23EF6D08E6:\
-F42F854C10C9DD14A6712594A31326A1FD2CF5:\
-9E47FB001BDDB12F2D8E0FA5501A7EAC1B185FDFC7D2FF3E4461B0D75D626F51\
-56DEDD4D25F13C6C1F5F9A1F916058045705F5E82F748E9B6F0DC95D572B8DC2\
-770159092EECA13946F0522FE2A859705009B615818A1B4F98E8DD38CF00DE74\
-6ABD5F3852D93F8D9299DE18EB763F11E41A8B9660C5F056538EED431BB8E219\
-9D9012F50C7FBEF5AAD35ECCD7F141CD9AC6553315A2699D6718F50EBDCEAE62\
-A11ACC466E8533EDBAF13C15B5532B323EBF283B108F892DBFCEA21231DFD548
-
-FCA682CE8E12CABA26EFCCF7110E526DB078B05EDECBCD1EB4A208F3AE1617AE\
-01F35B91A47E6DF63413C5E12ED0899BCD132ACD50D99151BDC43EE737592E17:\
-DE0B54EFABF297087EE623D5CA5588C64828EF4FDE4FFBAE1ECD2006776B05B1\
-1B81EA3CDE9BC3964C1687C5325BF43D7CCEFA0D0A86BE5DFFDDD0D1143DCD75:\
-841CBF70BC6E95C7E5ABAE60DC6538EE:\
-12C0A0D25B072D8698FD929B8EA219874E4EB6A7FB7D7EB5857A246235D70F6C\
-950118914598E62ACC2EE8E061B560A1FE272B9CA163A7C134E1D6767910ECD:\
-47E586A7E7D98C116A6F553F652E57BF:\
-BEF5E7EFAA76C52A8ECEE604EDAFD31B:\
-CD70DE085B0C586B4E64097EA3AB4CE0B60A71B0F640FE4468F4F940412EDBD\
-D9035EEC602530CFF81B2CDC35805264A866E4689DDBADC3438575B6337118B\
-B23A5AB7710F85F2A4E1E0DBEC5652FEF73C868747ECB7043BA08241A0879A2\
-DC588D3EC14ED552E62B1B111646FF4DFA9050754240A46A840EA5EB1D97712F2BB
-
-FCA682CE8E12CABA26EFCCF7110E526DB078B05EDECBCD1EB4A208F3AE1617AE\
-01F35B91A47E6DF63413C5E12ED0899BCD132ACD50D99151BDC43EE737592E17:\
-DE0B54EFABF297087EE623D5CA5588C64828EF4FDE4FFBAE1ECD2006776B05B1\
-1B81EA3CDE9BC3964C1687C5325BF43D7CCEFA0D0A86BE5DFFDDD0D1143DCD75:\
-AA3837AF7A7ECF6DB7E0B702A054363C:\
-74349C465B92635C1692BB6F2932E06C1BDF3FC81E78DEBD661BB1DBF1FAC1DC\
-C24EA052A119CFD272CCA2BE1E6BDF4579A7D69C739E8A412D4AACDDFE9EDFB5:\
-74BC8D009250F4CD2E08BC556EE01449:\
-A2951BE393736E39E9D209FE978C7546:\
-6D6ED1C6E519C628CACC7981A5BBE487F6E013B26448D711911698CEEAA4F746\
-182A716602183A746FC35B022BD7B27EF079F7164309653D148D0CE91907FF6C\
-4A9001A0CCA2A0A163F3F93200C2E40A957919CB84AC35B928E026F1827E6D4A\
-9B986B592BE39861538414D5EA6980248FD3C3C0CDEE372F392D5AC46DB8EEFB
-
-FCA682CE8E12CABA26EFCCF7110E526DB078B05EDECBCD1EB4A208F3AE1617AE\
-01F35B91A47E6DF63413C5E12ED0899BCD132ACD50D99151BDC43EE737592E17:\
-DE0B54EFABF297087EE623D5CA5588C64828EF4FDE4FFBAE1ECD2006776B05B1\
-1B81EA3CDE9BC3964C1687C5325BF43D7CCEFA0D0A86BE5DFFDDD0D1143DCD75:\
-8FAF3D43EA4C7EEEFB9C08807D90B160:\
-F9AD56F050A9FBF969A0A7D2A56BE409BA0EFCF23CCED06980E5A8965EBC6C30\
-08858AA845370F56C1BAB31177C2BB76DBFA9E04FE89DCCEA67BCED6C55ADD8F:\
-01AFE1A93EDB9CD3E3715523C952478D:\
-9500DDCD404618F64A2063BC19941A6E:\
-0636C3F1C63C54CAB4B48B6EF0ECBFF00BA6AB70DF4DB6266D0785351B37279D\
-41D957D16CAB48C64035DCB2A1CD75BAC298C8ECAE8057D87071EADAA5DA6E2B\
-69B5F353B5753F7E24DA81ABAD40059CD73CFA6E78CAB1C7DA418D55E5DBD42F\
-A4F2B876A25B4AF63588C80E0DB11E8BAB1531960E951C08C1A68C8FAE0DA87C
-
-E9E642599D355F37C97FFD3567120B8E25C9CD43E927B3A9670FBEC5D8901419\
-22D2C3B3AD2480093799869D1E846AAB49FAB0AD26D2CE6A22219D470BCE7D77\
-7D4A21FBE9C270B57F607002F3CEF8393694CF45EE3688C11A8C56AB127A3DAF:\
-DEEE9EF5ED1516CE7E695E672B8CEE45E6CD7B36E0E6385F894BA86163F6F3E6\
-C6D4E8A81146D4017DEFDD71CBD90FA0247659B88B7CC1C894F48269FD4F1AAC\
-0A30538DFF6B3FC76CFB131C9E7965B58858AB0A43B557335912A8AA547F9568:\
-FF4FD921EDD9618570ADA5C59C2A01ABBB9A51:\
-BDF5D785E7621256CAEB307A92AED0BCBC34B6ABCC568C200D413585AEF1E686\
-9C60E87001A664A8FF8645C3F79E1667BC2769D82605C3B1AB1A0DC2734AE831\
-32652544275F5C59CCA355BAA02D9DB3796A6B6CCECC14BD85B02A2C18EC7EC8:\
-58E72BD0F04B11:\
-EF07721FF6B28A8A3B4EBC95C16B13A83649B7:\
-C7B6ACADBBCFD3A34EDA31CE9CA7F7889FBB2DF5C6C25793EB974591BF0EDE93\
-637B6A95E8075BDB2A987039D92487665465C98AAD0C123FA00BB9736170E780\
-69AA32DFBEB07099A0B7D439AA807A2D3D6F9F913EBC673F9F8CD5D3C0E9DD0D\
-988EAC4D8204928C2DA8ECD1FA3A598FCBFFEF5017DB8542D123CF69E8C92EB9\
-56F10DC995AE6B6564967D5C12A07BA35607C54CC3F10A36FF3603DD7CC14906\
-64610002977CE8C4A4EFFBD1421C902D4D8DFF81D014E1AB55F239E0F2FD28AB
-
-E9E642599D355F37C97FFD3567120B8E25C9CD43E927B3A9670FBEC5D8901419\
-22D2C3B3AD2480093799869D1E846AAB49FAB0AD26D2CE6A22219D470BCE7D77\
-7D4A21FBE9C270B57F607002F3CEF8393694CF45EE3688C11A8C56AB127A3DAF:\
-DEEE9EF5ED1516CE7E695E672B8CEE45E6CD7B36E0E6385F894BA86163F6F3E6\
-C6D4E8A81146D4017DEFDD71CBD90FA0247659B88B7CC1C894F48269FD4F1AAC\
-0A30538DFF6B3FC76CFB131C9E7965B58858AB0A43B557335912A8AA547F9568:\
-B3BF90978FB3EF96E40F2AE8260F42B908EE1E:\
-578C33240691D5351BCDF2C727BEDF8C4B956EB32520ED93DB034D00EF69C44E\
-523639DCE55E09631D8EB6C6D6760CE10C510AA68847B7CEED43A3749F653B5B\
-2BAE4B07F95F85DA8F058F8DA2A0D07A2F0C5B009E63C06B638FA1B43CE7F7A9:\
-C37AA41207A357DBCCFBE93DC45C5BD91D29FD29CBA29B26AC437A9B560C3BEA:\
-A36338E4D7815E6A4B178E951BEF073C6D5A7F:\
-D824C94623313298600CC20203F8A40006CAFCFC8F883C99AC09DBAE4B95E6DB\
-9FB5737E24D9D7E39B603893076BC81A2BC0C0D608B32B353972B57066535DAA\
-C49E3F7F2A0E243618EEE01C5AB3AFAE1D55E3A1DB33CF713E5187AD51D55144\
-B1A108354ECA651E55F85F253FE73C1C15FA5EDDDA47467BD0425F09E3C41565\
-48E71896659C618B84FD72BA176E2DEEECD8B15F2C05F870697EA464B8827374\
-2BD6ECBA5164424F34EBB9E13E31683A16712901818C7E5F502720FBCB075EA1
-
-E9E642599D355F37C97FFD3567120B8E25C9CD43E927B3A9670FBEC5D8901419\
-22D2C3B3AD2480093799869D1E846AAB49FAB0AD26D2CE6A22219D470BCE7D77\
-7D4A21FBE9C270B57F607002F3CEF8393694CF45EE3688C11A8C56AB127A3DAF:\
-DEEE9EF5ED1516CE7E695E672B8CEE45E6CD7B36E0E6385F894BA86163F6F3E6\
-C6D4E8A81146D4017DEFDD71CBD90FA0247659B88B7CC1C894F48269FD4F1AAC\
-0A30538DFF6B3FC76CFB131C9E7965B58858AB0A43B557335912A8AA547F9568:\
-EE639A2B80F4FBBB96B82A0DA6ACF23124A1A1:\
-5D13E05491C00E0FAE1245BFE0E374F2753CBF1926352FB4180F11D740A2F6BC\
-8486C0E0F52D2990773ACFE01CD4AE6F428D55092FF33144C2D9F37692BC1230\
-89D9E77ED393C495ACBEAE7A9E927F4AF1D0E845D2EE93E733BCD0D50268A47:\
-36FDC0501B44AF:\
-832BC01DB63F958D47B6962AEAA74C0831A6AB:\
-62E46CDF100BADF4419215256BEC8427DD0388D1B60B5A8675532C0934351BA0\
-036AF58032AB6C4DB829F1A0C8217FBF2CB9C10A5C60FF285919BCAF238E89FB\
-AA4771CAD13D4A69AB2C1FFF0A44D2F9287F1E70D58210AE859074B3969EE800\
-A9D1507BA48582BD1E03CC234B0CB11408BE0932763EDC99CA4BEC6E496A4522\
-37F920972C629714EA2F1FF212460C23B66DB56BC73E94743D32D2CD3536A17A\
-136F56D7F7C24E3B8F102F48BBB21633279D3E584E71DC37B436104CA69A6BB3
-
-FD7F53811D75122952DF4A9C2EECE4E7F611B7523CEF4400C31E3F80B6512669\
-455D402251FB593D8D58FABFC5F5BA30F6CB9B556CD7813B801D346FF26660B7\
-6B9950A5A49F9FE8047B1022C24FBBA9D7FEB7C61BF83B57E7C6A8A6150F04FB\
-83F6D3C51EC3023554135A169132F675F3AE2B61D72AEFF22203199DD14801C7:\
-469603512E30278CD3947595DB22EEC9826A6322ADC97344F41D740C325724C8\
-F9EFBAA7D4D803FF8C609DCD100EBC5BDFCFAD7C6A425FAEA786EA2050EBE983\
-51EA1FDA1FDF24D6947AA6B9AA23766953802F4D7D4A8ECBA06D19768A2491FF\
-B16D0EF9C43A99B5F71672FF6F0A24B444D0736D04D38A1A1322DAF6CDD88C9D:\
-A0A2CF6E5C2C3157078FE232D88778DD7A864507FEF:\
-23020176F56436414B28AA4246433075433AC50C81C803275AB4BFB132D8A42A\
-27B69E40D9A219F36546801348E0191E7CEA23AA70B7EDBD52A44D0FA48946F9\
-0211186E58DAD6C7D2E9207379F31FEF083224FDE665576AC0A1EF193CE23FE0\
-8DB42715CE27A6E00DE4F373F92A221759C1E318161302ADC3CE9F1229290D46:\
-DF72B687F62AFEA3A51195EE876E4C87708F7ABB8D2D5DD72B68256DAC6D:\
-0B333C9C486C5F3A96F37D00133ADD18113376C9BE76:\
-4156CF437A39C415B212AAA34C9AACAFA3F3113F53BB75E0BD3D759089E21754\
-EF89B4BA1A8B37E5EDA13F8A2F87D16F03F3B6FE19A5CF799B17D83F7B5E9A22\
-5F324AAD7D46E80A1DAFCA337A3F500930A7831D1F3785763EB9A6994063CED0\
-33177E1CA2770B751B3053C1445ADFEAED790E49E4685A05B9563D1EF32BD321\
-971D541B525D648EA7C8741D8FA7E46293D46A0F4345BE73EA4FAF1E4C16BCBE\
-11C53BA0FCBA2975BD37F11FE5ADA8731CAED3C403EA6E43AE47ADAA7E284334\
-04AD3ADE6AA8E12BFC374BADAAFB167F3AAF91DC6F8398003E5F8528E8D4773F\
-800D48C8EDDAEDD72A3870E97679F946CE27FB692BC11677757A28F3899A3DA8
-
-FD7F53811D75122952DF4A9C2EECE4E7F611B7523CEF4400C31E3F80B6512669\
-455D402251FB593D8D58FABFC5F5BA30F6CB9B556CD7813B801D346FF26660B7\
-6B9950A5A49F9FE8047B1022C24FBBA9D7FEB7C61BF83B57E7C6A8A6150F04FB\
-83F6D3C51EC3023554135A169132F675F3AE2B61D72AEFF22203199DD14801C7:\
-469603512E30278CD3947595DB22EEC9826A6322ADC97344F41D740C325724C8\
-F9EFBAA7D4D803FF8C609DCD100EBC5BDFCFAD7C6A425FAEA786EA2050EBE983\
-51EA1FDA1FDF24D6947AA6B9AA23766953802F4D7D4A8ECBA06D19768A2491FF\
-B16D0EF9C43A99B5F71672FF6F0A24B444D0736D04D38A1A1322DAF6CDD88C9D:\
-B81133CD81461728FBE2D40682850CBC1176BBF24D9:\
-650BDDC18070CC54F0DC4DFBBF4B3144749D7D219E4122E27092FB005F82612D\
-39B652486DFF5B628FBE626B54D70FC5F3C11E5E4C7CCB5CBC78E528AC70E740\
-302FA043581A55A93EBB7143E807C056748702353A65715E39A86F3F1F90FD00\
-FBBB817D7C48A465A1DBC8DE5D8CDCE259D129D02EB673A4181B9CC88B7636A6:\
-F73BB7E5C8A5619380:\
-0AD9527B09EAD1E59B4A1CAF58C861B69A856AB8AA80:\
-C9881464A37749949D66D75CD9B7A8ACAD33DD1FAC7561F684E9CB5343D2ED15\
-969D7EDB4135518B50F0FEC9A9559C1D5E44DAB42C14BBDE2D2711EA4D02D7F2\
-7D1A9BCFEC9E8B73FA64BA3C54707FDDE7D5BE695E17FB9D259FB576FD4E57D6\
-6C8F727DC236E2A6E9FD01709D34B8D09F7DD3890F003EBE616042B4E0A8A00F\
-6C3F34DE7E002FE72A84AF8D014D64E8CD08B9B56CC3A6BBE6F966B92105A92C\
-5ABF4F2BF735670622F6213FE9739FAD65692E1C0EBF708A47E18600A22972A5\
-A3DA0F22D11C581D46F734151A083FF757E961351EB183B467A859FBB9ED1DAC\
-396FA405701FD6E3A62EB126E93648C3C6DFA9C4DBF3C005880F4799F66B310E
-
 # DH format: p:g:privkey:pubkey:finalkey:keylen
 # where privkey is our private key, pubkey is the other users public key, and
 # keylen is the output size we want (often this is ignored; if it's not there,
@@ -3723,84 +1036,3 @@ 5A70601B0668BA303F8FBFC90FBA82B9D589BD58
 487A91EE6B221D29DD30D17FF0C35B55C3CA435BE482EED716A60D266D350A7:\
 5A70601B0668BA303F8FBFC90FBA82B9D589BD586C576B414A6AF17F9B386C7020:33
 
-# DLIES format is p:g:priv1:priv2:message:ciphertext
-
-# p and g are DH parameters
-# priv1 is the private key of the party encrypting the message
-# priv2 is the private key of the party decrypting the message
-
-# The underlying SVDP is Diffie-Hellman
-[DLIES/KDF2(SHA-1)/HMAC(SHA-1)/16]
-FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74\
-020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437\
-4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\
-EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF:2:\
-A6963780ACB9D2C5C410D502AE60F027A807AB5BBE5:\
-88EF9E0354C67E9EB781A8BE95DD281A215CA1DCFD3:\
-AB5BBE0D:\
-538F9C9CAC3EEB460B6D40B4AC331EBD3E2F3065E515177F47A083D1AC71533B\
-F3B2931F52D71A99CA0804A633E1948F3B286453EA6CF0DD83C6DD1D2BD93B20\
-F4942D9679CFDE5856DD81E152E1E5ADD023324B945CE68425B025AE5D0CF86C\
-0D33244A60AF6045BD57018FFE5F84A9BF82193242FF32A64691586AAA298FE5\
-31CF06A56412DFEC3AD1F50FF8CD296310E5BB4D06E15AB0
-
-FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74\
-020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437\
-4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\
-EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF:2:\
-C2D89AA7566998A9E90E22F9244C84F68B55473594C:\
-AF719F4ACF99CD35BB3B71F0DCBF27F6A4268D91264:\
-C43BB390:\
-C04F6BD6D1BFBDE74E775FB391A29B2D6FB7EE84C13D2061291DBA8708E406B0\
-A6788F69F7DFEBE4CA35B31917EACD7D36CDBEBDCC51567ADF3F287F57592A0F\
-73E1C990B807E0A67ACAE3F07361DF123C59E0A95CFCA9DEB3C7CCDC47C925F9\
-75AF0948B3DE9EC1E34EED30391FD4080D77DD07F091E3D5D89BC158A96485B2\
-8477AA95D62EFB9FA1D2B44A38A698F81C9518355BAE8B74
-
-FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74\
-020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437\
-4FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF:2:\
-B8BBACE15066DF21FC2ADF8F2FB47776D98716F5:\
-EB2EDB317A29CE6BD580D1BBDBDA5585450D9B7B:\
-3B06E0705DC9DBA971AA624393984D5B:\
-2AB9B180CEF08E761EDB4D7B7C538FBA0FD37BACE9416789A0DD6551F2DDC602\
-5C76A663F1AAD5000EC03418A6220ABA6D3DC5EA82D7340E2FFCB5665AD3A222\
-3CDFF9C39889CBE31E44CD31BCFDCEFCF2A9916FD39E2720A7B826F7E6998F73\
-4F251C71DC970AF3FB12949C14AA759966733BFC976CAD0BE71FC5DBE285200E\
-75647C62
-
-FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74\
-020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437\
-4FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF:2:\
-B2A1040661E071F702CB2190ACAF3CC532FE1DC2:\
-8A9B563FD9A12356EC7851943CF453AF7236A596:\
-DD92A05E19BBAD4A33CEFFA0FA2727E9:\
-3F0300C53C0BB02A3EF2EFCC751EE5D98AE991730C1C2FE39D11A74D32D892AD\
-63A9EECA09BBBE606FB426E03BBD480FD224E09712BB85FE649D543CBC23113A\
-39F9102C65D31DF330ADF233735C1D60D1BCDE22744392D2D9DE50393984F276\
-A33DD85F763ED1226B88DF1662554AD27820F66A995FE1481189A2B8C3071D0C\
-32EE9960
-
-FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74\
-020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437\
-4FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF:2:\
-C56BAF8FAC2AB023B2995F5958D5E929C7501555:\
-9F48260F8B6FF09E0F71B97EFA50E2469F316C3D:\
-174E756AF8FFB51990BF3C69688D3A7F0B388F2BCE62A095BC12CD6DA2C2AD65:\
-B99BBBC64F6320060200E6FFE7D1FE6E5EEA79DF142111AF88D377037BD91863\
-41B7A7A27F2AE8BB77282B8EA13D821DD77186412CA3B9B5E1650A0D20687B1C\
-8D556FD7D547D475F71BBD7D6417311F535A9A6D95CEA8AFD1146B1A1741828E\
-8AD46B058507A67111CB62132350EEAC1212D90535677855E17B1DA9DC4CE790\
-C4B917B1359123226FE62DCCE5475721F09CEA23
-
-FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74\
-020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437\
-4FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF:2:\
-F54BB009FFFFD728677F76CFF2B1BDF05F24226C:\
-F6F5DFFCEA9F09A784C15BEACBDE88C0F58D19F7:\
-75DAD921764736E389C4224DAF7B278EC291E682044742E2E9C7A025B54DD62F:\
-C591E27A2C12742A959652F5F341F558CA0C7DAF2E6B5ACE32DCAAF459553BA2\
-3EF0235EAFD86A7F2D70587239D858484E5CD36122C2B9F6E410C7A9C307B2A2\
-A084BB1B634A15AC9F09E38EAF421D14C5A07B6EB5EDE6915E8DE9D3D9D01DBD\
-8822FBD79BA7FF3DF921B5451BBD9A12AB41FD4DAB829599BC2736B23753063C\
-0C5FFCBA7DB06DE26D3C441D126FC1A46531F593
============================================================
--- checks/validate.cpp	c8f8cd4ed6867ae6fd8bbe7c8af0f5c04f847664
+++ checks/validate.cpp	c89a9eccea28a5e9e0a6623051344d1adb82d85e
@@ -36,15 +36,17 @@ u32bit random_word(u32bit max)
 #endif
    }
 
-Botan::Filter* lookup(const std::string&, const std::vector<std::string>&,
+Botan::Filter::SharedFilterPtr  lookup(const std::string&,const std::vector<std::string>&,
                       const std::string& = "All");
 
 bool failed_test(const std::string&, std::vector<std::string>, bool, bool,
                  const std::string&, std::string&);
 
 std::vector<std::string> parse(const std::string&);
+void strip_newlines_windows(std::string&);
 void strip(std::string&);
 Botan::SecureVector<byte> decode_hex(const std::string&);
+std::string hex_encode(const byte in[], u32bit len);
 
 u32bit do_validation_tests(const std::string& filename, bool should_pass)
    {
@@ -63,12 +65,17 @@ u32bit do_validation_tests(const std::st
 
    while(!test_data.eof())
       {
+	   if (errors>0)
+	   {
+		   return errors;
+	   }
       if(test_data.bad() || test_data.fail())
          throw Botan::Stream_IO_Error("File I/O error reading from " +
                                       filename);
 
       std::string line;
       std::getline(test_data, line);
+      strip_newlines_windows(line);
 
       const std::string MARK = "# MARKER: ";
 
@@ -82,18 +89,18 @@ u32bit do_validation_tests(const std::st
          section = line;
          section.replace(section.find(MARK), MARK.size(), "");
          if(should_pass)
-            std::cout << "Testing " << section << ": ";
+            std::cout << "[VALIDATE] Testing " << section << ": ";
          }
 
       strip(line);
       if(line.size() == 0) continue;
-
       // Do line continuation
       while(line[line.size()-1] == '\\' && !test_data.eof())
          {
          line.replace(line.size()-1, 1, "");
          std::string nextline;
          std::getline(test_data, nextline);
+         strip_newlines_windows(nextline);
          strip(nextline);
          if(nextline.size() == 0) continue;
          line += nextline;
@@ -113,9 +120,9 @@ u32bit do_validation_tests(const std::st
 
 #if DEBUG
          if(should_pass)
-            std::cout << "Testing " << algorithm << "..." << std::endl;
+            std::cout << "[VALIDATE] Testing " << algorithm << "..." << std::endl;
          else
-            std::cout << "Testing (expecing failure) "
+            std::cout << "[VALIDATE] Testing (expecting failure) "
                       << algorithm << "..." << std::endl;
 #endif
          alg_count = 0;
@@ -140,14 +147,14 @@ u32bit do_validation_tests(const std::st
 
       if(failed && should_pass)
          {
-         std::cout << "ERROR: \"" << algorithm << "\" failed test #"
+         std::cout << "[VALIDATE] ERROR: \"" << algorithm << "\" failed test #"
                    << alg_count << std::endl;
          errors++;
          }
 
       if(!failed && !should_pass)
          {
-         std::cout << "ERROR: \"" << algorithm << "\" passed test #"
+         std::cout << "[VALIDATE] ERROR: \"" << algorithm << "\" passed test #"
                    << alg_count << " (unexpected pass)" << std::endl;
          errors++;
          }
@@ -165,7 +172,7 @@ bool failed_test(const std::string& algo
                  std::string& last_missing)
    {
 #if DEBUG
-   std::cout << "Testing: " << algo;
+   std::cout << "[VALIDATE] Testing: " << algo;
    if(!exp_pass)
       std::cout << " (expecting failure)";
    std::cout << std::endl;
@@ -177,22 +184,23 @@ bool failed_test(const std::string& algo
 
    const std::string in = params[0];
    const std::string expected = params[1];
+   const std::string key = params[2];
 
    params.erase(params.begin());
    params.erase(params.begin());
 
    if(in.size() % 2 == 1)
       {
-      std::cout << "Can't have an odd sized hex string!" << std::endl;
+      std::cout << "[VALIDATE] Can't have an odd sized hex string!" << std::endl;
       return true;
       }
 
    Botan::Pipe pipe;
-
    try {
-      Botan::Filter* test = lookup(algo, params, section);
-      if(test == 0 && is_extension) return !exp_pass;
-      if(test == 0)
+     Botan::Filter::SharedFilterPtr test = lookup(algo, params, section);
+
+      if(test.get() == 0 && is_extension) return !exp_pass;
+      if(test.get() == 0)
          {
          if(algo != last_missing)
             {
@@ -202,10 +210,9 @@ bool failed_test(const std::string& algo
             }
          return 0;
          }
-
       pipe.reset();
       pipe.append(test);
-      pipe.append(new Botan::Hex_Encoder);
+      pipe.append(Botan::create_shared_ptr<Botan::Hex_Encoder>());
 
       Botan::SecureVector<byte> data = decode_hex(in);
       const byte* data_ptr = data;
@@ -269,22 +276,23 @@ bool failed_test(const std::string& algo
       if(!OK)
          throw Botan::Self_Test_Failure("Peek testing failed in validate.cpp");
       }
+//   std::cout << "alg: >" << algo << "<" << std::endl;
+//   std::cout << "output: >" << output << "<" << std::endl;
 
    if(output == expected && !exp_pass)
       {
-      std::cout << "FAILED: " << expected << " == " << std::endl
+      std::cout << "[VALIDATE] FAILED: " << expected << " == " << std::endl
                 << "        " << output << std::endl;
       return false;
       }
 
    if(output != expected && exp_pass)
       {
-      std::cout << "\nFAILED: " << expected << " != " << std::endl
-                << "        " << output << std::endl;
+      std::cout << "\n[VALIDATE] FAILED: " << in << " (input) => "<< expected << " (expected) != " << std::endl
+                << "        " << output << " (result) with " << key << " (key)"<< std::endl;
       return true;
       }
 
    if(output != expected && !exp_pass) return true;
-
    return false;
    }
============================================================
--- checks/validate.dat	a6793c15f2ca6d78b6f4e52b6b25746678773190
+++ checks/validate.dat	1fdb5360f945b438b4b04beecda2df4a49aee40b
@@ -30479,6 +30479,11 @@ 8395ABC1B17BA7BF947145EB1DF1A2050C8E78C3
 105C88:\
 8395ABC1B17BA7BF947145EB1DF1A2050C8E78C3
 
+[SHA-224]
+:D14A028C2A3A2BC9476102BB288234C415A2B01F828EA62AC5B3E42F
+
+61:ABD37534C7D9A2EFB9465DE931CD7055FFDB8879563AE98078D6D6D5
+
 [SHA-256]
 :E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855
 
============================================================
--- checks/x509.cpp	afef80cdf42af5416cf83a64023d10451314c8f9
+++ checks/x509.cpp	d388b50234616164f3bf4db3647f377d736f3437
@@ -5,58 +5,79 @@
 #include <botan/x509_ca.h>
 #include <botan/pkcs10.h>
 #include <botan/rsa.h>
-#include <botan/dsa.h>
+//#include <botan/dsa.h>
 using namespace Botan;
 
 #include <iostream>
-#include <memory>
+#include<botan/tr1_mem_includer.h>
+//#include <tr1/memory>
 
 X509_Cert_Options ca_opts();
 X509_Cert_Options req_opts1();
 X509_Cert_Options req_opts2();
 
-u64bit key_id(const Public_Key* key)
-   {
-   std::auto_ptr<X509_Encoder> encoder(key->x509_encoder());
-   if(!encoder.get())
-      throw Internal_Error("Public_Key:key_id: No encoder found");
+u64bit key_id(std::auto_ptr<X509_Encoder>& encoder, std::string& algo_name)
+    {
+    if (!encoder.get())
+	throw Internal_Error("Public_Key:key_id: No encoder found");
 
-   Pipe pipe(new Hash_Filter("SHA-1", 8));
-   pipe.start_msg();
-   pipe.write(key->algo_name());
-   pipe.write(encoder->alg_id().parameters);
-   pipe.write(encoder->key_bits());
-   pipe.end_msg();
+    Pipe pipe(Botan::create_shared_ptr<Hash_Filter>("SHA-1", 8));
+    pipe.start_msg();
+    pipe.write(algo_name);
+    pipe.write(encoder->alg_id().parameters);
+    pipe.write(encoder->key_bits());
+    pipe.end_msg();
 
-   SecureVector<byte> output = pipe.read_all();
+    SecureVector<byte> output = pipe.read_all();
 
-   if(output.size() != 8)
-      throw Internal_Error("Public_Key::key_id: Incorrect output size");
+    if (output.size() != 8)
+	throw Internal_Error("Public_Key::key_id: Incorrect output size");
 
-   u64bit id = 0;
-   for(u32bit j = 0; j != 8; ++j)
-      id = (id << 8) | output[j];
-   return id;
+    u64bit id = 0;
+    for (u32bit j = 0; j != 8; ++j)
+	id = (id << 8) | output[j];
+    return id;
+    }
+
+u64bit key_id(std::auto_ptr<Public_Key>& key)
+   {
+   std::auto_ptr<X509_Encoder> encoder(key->x509_encoder());
+   std::string algo_name = key->algo_name();
+     
+   return key_id(encoder, algo_name);
    }
 
+u64bit key_id(std::auto_ptr<Private_Key>& key)
+   {
+   std::auto_ptr<X509_Encoder> encoder(key->x509_encoder());
+   std::string algo_name = key->algo_name();
+     
+   return key_id(encoder, algo_name);
+   }
+
+u64bit key_id(const Public_Key* key)
+   {
+   std::auto_ptr<X509_Encoder> encoder(key->x509_encoder());
+   std::string algo_name = key->algo_name();
+   
+   return key_id(encoder, algo_name);
+   }
+
+
 u32bit check_against_copy(const Private_Key& orig)
    {
-   Private_Key* copy_priv = PKCS8::copy_key(orig);
-   Public_Key* copy_pub = X509::copy_key(orig);
+   std::auto_ptr<Private_Key> copy_priv = PKCS8::copy_key(orig);
+   std::auto_ptr<Public_Key> copy_pub = X509::copy_key(orig);
 
    const std::string passphrase= "I need work! -Mr. T"; // Me too...
-   DataSource_Memory enc_source(PKCS8::PEM_encode(orig, passphrase));
-   Private_Key* copy_priv_enc = PKCS8::load_key(enc_source, passphrase);
+   std::tr1::shared_ptr<DataSource> enc_source(new DataSource_Memory(PKCS8::PEM_encode(orig, passphrase)));
+   std::auto_ptr<Private_Key> copy_priv_enc = PKCS8::load_key(enc_source, passphrase);
 
    u64bit orig_id = key_id(&orig);
    u64bit pub_id = key_id(copy_pub);
    u64bit priv_id = key_id(copy_priv);
    u64bit priv_enc_id = key_id(copy_priv_enc);
 
-   delete copy_pub;
-   delete copy_priv;
-   delete copy_priv_enc;
-
    if(orig_id != pub_id || orig_id != priv_id || orig_id != priv_enc_id)
       {
       std::cout << "Failed copy check\n";
@@ -78,10 +99,16 @@ void do_x509_tests()
    std::cout << '.' << std::flush;
 
    /* Create user #1's key and cert request */
+	/*
    std::cout << '.' << std::flush;
    DSA_PrivateKey user1_key(DL_Group("dsa/jce/1024"));
    std::cout << '.' << std::flush;
    PKCS10_Request user1_req = X509::create_cert_req(req_opts1(), user1_key);
+	*/
+   std::cout << '.' << std::flush;
+   RSA_PrivateKey user1_key(768);
+   std::cout << '.' << std::flush;
+   PKCS10_Request user1_req = X509::create_cert_req(req_opts1(), user1_key);
 
    /* Create user #2's key and cert request */
    std::cout << '.' << std::flush;
@@ -101,6 +128,7 @@ void do_x509_tests()
    X509_Certificate user2_cert = ca.sign_request(user2_req);
    std::cout << '.' << std::flush;
 
+
    X509_CRL crl1 = ca.new_crl();
 
    /* Verify the certs */
============================================================
--- doc/license.txt	902feeccfae30f0eb980e0f50b222cdd2c2df694
+++ doc/license.txt	fb89e0d65f5f53a62910a4ed7d0422d6a868a12e
@@ -1,3 +1,6 @@
+Copyrigth (C) 2007-2008 
+	FlexSecure GmbH (http://www.flexsecure.de)
+	Technische Universitt Darmstadt
 Copyright (C) 1999-2007 The Botan Project. All rights reserved.
 
 Redistribution and use in source and binary forms, for any use, with or without
============================================================
--- include/adler32.h	035da7f16ef799ccbfc2d01e2628ecad25c815f8
+++ include/adler32.h	540ca183d1300ff6e78074124f84ca7fce58a4ee
@@ -18,7 +18,7 @@ class Adler32 : public HashFunction
    public:
       void clear() throw() { S1 = 1; S2 = 0; }
       std::string name() const { return "Adler32"; }
-      HashFunction* clone() const { return new Adler32; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new Adler32); }
       Adler32() : HashFunction(4) { clear(); }
       ~Adler32() { clear(); }
    private:
============================================================
--- include/aes.h	7d6c1cb25b5ff83e2eaf84904242047ea4b4bf4e
+++ include/aes.h	31a5dc11f1e83567b5f6428be5eb14bd604f69b2
@@ -18,7 +18,7 @@ class AES : public BlockCipher
    public:
       void clear() throw();
       std::string name() const { return "AES"; }
-      BlockCipher* clone() const { return new AES; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new AES); }
       AES() : BlockCipher(16, 16, 32, 8) { ROUNDS = 14; }
       AES(u32bit);
    private:
@@ -40,7 +40,7 @@ class AES_128 : public AES
    {
    public:
       std::string name() const { return "AES-128"; }
-      BlockCipher* clone() const { return new AES_128; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new AES_128); }
       AES_128() : AES(16) {}
    };
 
@@ -51,7 +51,7 @@ class AES_192 : public AES
    {
    public:
       std::string name() const { return "AES-192"; }
-      BlockCipher* clone() const { return new AES_192; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new AES_192); }
       AES_192() : AES(24) {}
    };
 
@@ -62,7 +62,7 @@ class AES_256 : public AES
    {
    public:
       std::string name() const { return "AES-256"; }
-      BlockCipher* clone() const { return new AES_256; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new AES_256); }
       AES_256() : AES(32) {}
    };
 
============================================================
--- include/allocate.h	532035d3cdec5a2c8fd3250f87a78fa7f3d77eb4
+++ include/allocate.h	4a68cbaaadf1ef256013c97958af195fd821e08b
@@ -8,6 +8,7 @@
 
 #include <botan/types.h>
 #include <string>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -17,7 +18,7 @@ class Allocator
 class Allocator
    {
    public:
-      static Allocator* get(bool);
+      static std::tr1::shared_ptr<Allocator> get(bool);
 
       virtual void* allocate(u32bit) = 0;
       virtual void deallocate(void*, u32bit) = 0;
============================================================
--- include/asn1_int.h	e019f2b543443ca344094d8f0156b5eea11f2533
+++ include/asn1_int.h	c6ba65e0f28e1dc78f77191169ce3e66d5259db7
@@ -9,6 +9,8 @@
 #include <botan/secmem.h>
 #include <botan/enums.h>
 #include <botan/exceptn.h>
+#include <botan/tr1_mem_includer.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
@@ -44,7 +46,7 @@ std::string to_string(const BER_Object&)
 
 SecureVector<byte> put_in_sequence(const MemoryRegion<byte>&);
 std::string to_string(const BER_Object&);
-bool maybe_BER(DataSource&);
+bool maybe_BER(SharedPtrConverter<DataSource>);
 
 }
 
============================================================
--- include/asn1_obj.h	dfbdbae68301d279de67562d713133df1258084c
+++ include/asn1_obj.h	ed5025ca6776410d8bf2f4743d84bcc82abe700a
@@ -12,31 +12,33 @@
 #include <vector>
 #include <map>
 
-namespace Botan {
+namespace Botan
+  {
 
-/*************************************************
-* Attribute                                      *
-*************************************************/
-class Attribute : public ASN1_Object
-   {
-   public:
+  /*************************************************
+  * Attribute                                      *
+  *************************************************/
+  class Attribute : public ASN1_Object
+    {
+    public:
       void encode_into(class DER_Encoder&) const;
       void decode_from(class BER_Decoder&);
 
       OID oid;
       MemoryVector<byte> parameters;
 
-      Attribute() {}
+      Attribute()
+      {}
       Attribute(const OID&, const MemoryRegion<byte>&);
       Attribute(const std::string&, const MemoryRegion<byte>&);
-   };
+    };
 
-/*************************************************
-* X.509 Time                                     *
-*************************************************/
-class X509_Time : public ASN1_Object
-   {
-   public:
+  /*************************************************
+  * X.509 Time                                     *
+  *************************************************/
+  class X509_Time : public ASN1_Object
+    {
+    public:
       void encode_into(class DER_Encoder&) const;
       void decode_from(class BER_Decoder&);
 
@@ -52,42 +54,138 @@ class X509_Time : public ASN1_Object
       X509_Time(u64bit);
       X509_Time(const std::string& = "");
       X509_Time(const std::string&, ASN1_Tag);
-   private:
+    private:
       bool passes_sanity_check() const;
       u32bit year, month, day, hour, minute, second;
       ASN1_Tag tag;
-   };
+    };
 
-/*************************************************
-* Simple String                                  *
-*************************************************/
-class ASN1_String : public ASN1_Object
-   {
-   public:
+  /*************************************************
+  * CVC EAC Time                                     *
+  *************************************************/
+  class EAC_Time : public ASN1_Object
+    {
+    public:
       void encode_into(class DER_Encoder&) const;
       void decode_from(class BER_Decoder&);
 
+      std::string as_string() const;
+      std::string readable_string() const;
+      bool time_is_set() const;
+
+      s32bit cmp(const EAC_Time&) const;
+
+      void set_to(const std::string&);
+      //void set_to(const std::string&, ASN1_Tag);
+      void add_years(u32bit years);
+      void add_months(u32bit months);
+
+      u32bit get_year() const;
+      u32bit get_month() const;
+      u32bit get_day() const;
+
+      EAC_Time(u64bit, ASN1_Tag t = ASN1_Tag(0));
+      //EAC_Time(const std::string& = "");
+      EAC_Time(const std::string&, ASN1_Tag = ASN1_Tag(0));
+      EAC_Time(u32bit year, u32bit month, u32bit day, ASN1_Tag = ASN1_Tag(0));
+      virtual ~EAC_Time(){};
+    private:
+      SecureVector<byte> encoded_eac_time() const;
+      bool passes_sanity_check() const;
+      u32bit year, month, day;
+      ASN1_Tag tag;
+    };
+
+    class ASN1_Ced : public EAC_Time
+    {
+        // function definitions in asn_eac_tm.cpp
+        public:
+            ASN1_Ced(std::string const& str="");
+            ASN1_Ced(u64bit);
+            ASN1_Ced(EAC_Time const& other);
+            //ASN1_Ced(ASN1_Cex const& cex);
+    };
+
+    class ASN1_Cex : public EAC_Time
+    {
+        // function definitions in asn_eac_tm.cpp
+        public:
+            ASN1_Cex(std::string const& str="");
+            ASN1_Cex(u64bit);
+            ASN1_Cex(EAC_Time const& other);
+            //ASN1_Cex(ASN1_Ced const& ced);
+    };
+  /*************************************************
+  * Simple String                                  *
+  *************************************************/
+  class ASN1_String : public ASN1_Object
+    {
+    public:
+      void encode_into(class DER_Encoder&) const;
+      void decode_from(class BER_Decoder&);
+
       std::string value() const;
-      std::string iso_8859() const;
+      std::string iso_8859() const; // actually returns iso 8859-1 (latin1)
 
       ASN1_Tag tagging() const;
 
       ASN1_String(const std::string& = "");
       ASN1_String(const std::string&, ASN1_Tag);
-   private:
+    private:
       std::string iso_8859_str;
       ASN1_Tag tag;
-   };
+    };
 
-/*************************************************
-* Distinguished Name                             *
-*************************************************/
-class X509_DN : public ASN1_Object
-   {
-   public:
+
+  /*************************************************
+  * String for car/chr of cv certificates          *
+  *************************************************/
+  class ASN1_EAC_String: public ASN1_Object
+    {
+    public:
       void encode_into(class DER_Encoder&) const;
       void decode_from(class BER_Decoder&);
 
+      std::string value() const;
+      std::string iso_8859() const;
+
+      ASN1_Tag tagging() const;
+      ASN1_EAC_String(const std::string& str, ASN1_Tag the_tag);
+      virtual ~ASN1_EAC_String()
+      {}
+
+    protected:
+        bool sanity_check() const;
+    private:
+      std::string iso_8859_str;
+      ASN1_Tag tag;
+    };
+
+  class ASN1_Car : public ASN1_EAC_String
+    {
+
+      // function definitions in asn1_eac_str.cpp
+    public:
+      ASN1_Car(std::string const& str = "");
+    };
+
+  class ASN1_Chr : public ASN1_EAC_String
+    {
+      // function definitions in asn1_eac_str.cpp
+    public:
+      ASN1_Chr(std::string const& str = "");
+    };
+
+
+  /*************************************************
+  * Distinguished Name                             *
+  *************************************************/
+  class X509_DN : public ASN1_Object
+    {
+    public:
+      void encode_into(class DER_Encoder&) const;
+      void decode_from(class BER_Decoder&);
+
       std::multimap<OID, std::string> get_attributes() const;
       std::vector<std::string> get_attribute(const std::string&) const;
 
@@ -104,17 +202,17 @@ class X509_DN : public ASN1_Object
       X509_DN();
       X509_DN(const std::multimap<OID, std::string>&);
       X509_DN(const std::multimap<std::string, std::string>&);
-   private:
+    private:
       std::multimap<OID, ASN1_String> dn_info;
       MemoryVector<byte> dn_bits;
-   };
+    };
 
-/*************************************************
-* Alternative Name                               *
-*************************************************/
-class AlternativeName : public ASN1_Object
-   {
-   public:
+  /*************************************************
+  * Alternative Name                               *
+  *************************************************/
+  class AlternativeName : public ASN1_Object
+    {
+    public:
       void encode_into(class DER_Encoder&) const;
       void decode_from(class BER_Decoder&);
 
@@ -130,33 +228,45 @@ class AlternativeName : public ASN1_Obje
 
       AlternativeName(const std::string& = "", const std::string& = "",
                       const std::string& = "");
-   private:
+    private:
       std::multimap<std::string, std::string> alt_info;
       std::multimap<OID, ASN1_String> othernames;
-   };
+    };
 
-/*************************************************
-* Comparison Operations                          *
-*************************************************/
-bool operator==(const AlgorithmIdentifier&, const AlgorithmIdentifier&);
-bool operator!=(const AlgorithmIdentifier&, const AlgorithmIdentifier&);
+  /*************************************************
+  * Comparison Operations                          *
+  *************************************************/
+  bool operator==(const AlgorithmIdentifier&, const AlgorithmIdentifier&);
+  bool operator!=(const AlgorithmIdentifier&, const AlgorithmIdentifier&);
 
-bool operator==(const X509_Time&, const X509_Time&);
-bool operator!=(const X509_Time&, const X509_Time&);
-bool operator<=(const X509_Time&, const X509_Time&);
-bool operator>=(const X509_Time&, const X509_Time&);
+  bool operator==(const X509_Time&, const X509_Time&);
+  bool operator!=(const X509_Time&, const X509_Time&);
+  bool operator<=(const X509_Time&, const X509_Time&);
+  bool operator>=(const X509_Time&, const X509_Time&);
 
-bool operator==(const X509_DN&, const X509_DN&);
-bool operator!=(const X509_DN&, const X509_DN&);
-bool operator<(const X509_DN&, const X509_DN&);
+  bool operator==(const EAC_Time&, const EAC_Time&);
+  bool operator!=(const EAC_Time&, const EAC_Time&);
+  bool operator<=(const EAC_Time&, const EAC_Time&);
+  bool operator>=(const EAC_Time&, const EAC_Time&);
+  bool operator>(const EAC_Time&, const EAC_Time&);
+  bool operator<(const EAC_Time&, const EAC_Time&);
 
-/*************************************************
-* Helper Functions                               *
-*************************************************/
-s32bit validity_check(const X509_Time&, const X509_Time&, u64bit);
+  bool operator==(const X509_DN&, const X509_DN&);
+  bool operator!=(const X509_DN&, const X509_DN&);
+  bool operator<(const X509_DN&, const X509_DN&);
 
-bool is_string_type(ASN1_Tag);
+  bool operator==(const ASN1_EAC_String&, const ASN1_EAC_String&);
+  inline bool operator!=(const ASN1_EAC_String& lhs, const ASN1_EAC_String& rhs)
+  {
+   return !(lhs == rhs);
+  }
+  /*************************************************
+  * Helper Functions                               *
+  *************************************************/
+  s32bit validity_check(const X509_Time&, const X509_Time&, u64bit);
 
+  bool is_string_type(ASN1_Tag);
+
 }
 
 #endif
============================================================
--- include/base.h	022214feafcc2f0dcf38edc423be11e907088448
+++ include/base.h	70a9036f274330e92ebcec561e140abf3d0092a7
@@ -8,6 +8,7 @@
 
 #include <botan/exceptn.h>
 #include <botan/symkey.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -41,6 +42,8 @@ class BlockCipher : public SymmetricAlgo
 class BlockCipher : public SymmetricAlgorithm
    {
    public:
+      typedef std::auto_ptr<BlockCipher> AutoBlockCipherPtr;
+
       const u32bit BLOCK_SIZE;
 
       void encrypt(const byte in[], byte out[]) const { enc(in, out); }
@@ -48,7 +51,7 @@ class BlockCipher : public SymmetricAlgo
       void encrypt(byte block[]) const { enc(block, block); }
       void decrypt(byte block[]) const { dec(block, block); }
 
-      virtual BlockCipher* clone() const = 0;
+      virtual AutoBlockCipherPtr clone() const = 0;
       virtual void clear() throw() {};
 
       BlockCipher(u32bit, u32bit, u32bit = 0, u32bit = 1);
@@ -64,6 +67,8 @@ class StreamCipher : public SymmetricAlg
 class StreamCipher : public SymmetricAlgorithm
    {
    public:
+      typedef std::auto_ptr<StreamCipher> AutoStreamCipherPtr;
+
       const u32bit IV_LENGTH;
       void encrypt(const byte i[], byte o[], u32bit len) { cipher(i, o, len); }
       void decrypt(const byte i[], byte o[], u32bit len) { cipher(i, o, len); }
@@ -73,7 +78,7 @@ class StreamCipher : public SymmetricAlg
       virtual void resync(const byte[], u32bit);
       virtual void seek(u32bit);
 
-      virtual StreamCipher* clone() const = 0;
+      virtual AutoStreamCipherPtr clone() const = 0;
       virtual void clear() throw() {};
 
       StreamCipher(u32bit, u32bit = 0, u32bit = 1, u32bit = 0);
@@ -111,9 +116,12 @@ class HashFunction : public BufferedComp
 class HashFunction : public BufferedComputation
    {
    public:
+      typedef std::auto_ptr<HashFunction> AutoHashFunctionPtr;
+      typedef std::tr1::shared_ptr<HashFunction> SharedHashFunctionPtr;
+
       const u32bit HASH_BLOCK_SIZE;
 
-      virtual HashFunction* clone() const = 0;
+      virtual AutoHashFunctionPtr clone() const = 0;
       virtual std::string name() const = 0;
       virtual void clear() throw() {};
 
@@ -128,9 +136,11 @@ class MessageAuthenticationCode : public
                                   public SymmetricAlgorithm
    {
    public:
+      typedef std::auto_ptr<MessageAuthenticationCode> AutoMACPtr;
+
       virtual bool verify_mac(const byte[], u32bit);
 
-      virtual MessageAuthenticationCode* clone() const = 0;
+      virtual AutoMACPtr clone() const = 0;
       virtual std::string name() const = 0;
       virtual void clear() throw() {};
 
============================================================
--- include/basefilt.h	7e88a84f573ac07ff44bdbdcf6747e3534d75975
+++ include/basefilt.h	ed92137b63c8fbc22fe34fcb85a0ba20de0cc0e0
@@ -16,10 +16,38 @@ class Chain : public Fanout_Filter
 class Chain : public Fanout_Filter
    {
    public:
+     typedef Filter::SharedFilterPtrConverter SharedFilterPtrConverter;
+     typedef Filter::SharedFilterPtr SharedFilterPtr;
+
+   private:
+      template<typename ConstIter>
+      void init(ConstIter begin, ConstIter end)
+         {
+         for( ; begin != end; ++begin)
+            {
+            if(*begin)
+               {
+               this->attach(*begin);
+               this->incr_owns();
+               }
+            }
+         }
+
+   public:
       void write(const byte input[], u32bit length) { send(input, length); }
 
-      Chain(Filter* = 0, Filter* = 0, Filter* = 0, Filter* = 0);
-      Chain(Filter*[], u32bit);
+      Chain(SharedFilterPtrConverter const&,
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter());
+
+      template<typename ConstIter>
+      Chain(ConstIter begin, ConstIter end)
+         : Fanout_Filter()
+         { 
+         this->init(begin, end); 
+         }
+
    };
 
 /*************************************************
@@ -31,8 +59,17 @@ class Fork : public Fanout_Filter
       void write(const byte input[], u32bit length) { send(input, length); }
       void set_port(u32bit n) { Fanout_Filter::set_port(n); }
 
-      Fork(Filter*, Filter*, Filter* = 0, Filter* = 0);
-      Fork(Filter*[], u32bit);
+      Fork(SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter());
+      template<typename ConstIter>
+      Fork(ConstIter begin, ConstIter end)
+         : Fanout_Filter()
+         { 
+         this->set_next(begin, end); 
+         }
+
    };
 
 /*************************************************
@@ -45,9 +82,9 @@ class Keyed_Filter : public Filter
       virtual void set_iv(const InitializationVector&) {}
       virtual bool valid_keylength(u32bit) const;
 
-      Keyed_Filter() { base_ptr = 0; }
+      Keyed_Filter() : base_ptr() { }
    protected:
-      SymmetricAlgorithm* base_ptr;
+	   std::tr1::shared_ptr<SymmetricAlgorithm> base_ptr;
    };
 
 }
============================================================
--- include/ber_dec.h	9a3931c832c8e5bb00fa2a493532759637bc0201
+++ include/ber_dec.h	da5a1952e517851536e63a368da18a496ffa612c
@@ -8,15 +8,18 @@
 
 #include <botan/asn1_oid.h>
 #include <botan/data_src.h>
+#include <botan/math/bigint.h>
+#include <botan/freestore.h>
 
-namespace Botan {
+namespace Botan
+  {
 
-/*************************************************
-* BER Decoding Object                            *
-*************************************************/
-class BER_Decoder
-   {
-   public:
+  /*************************************************
+  * BER Decoding Object                            *
+  *************************************************/
+  class BER_Decoder
+    {
+    public:
       BER_Object get_next_object();
       void push_back(const BER_Object&);
 
@@ -32,12 +35,12 @@ class BER_Decoder
       BER_Decoder& decode_null();
       BER_Decoder& decode(bool&);
       BER_Decoder& decode(u32bit&);
-      BER_Decoder& decode(class BigInt&);
+	  BER_Decoder& decode(class Botan::math::BigInt&);
       BER_Decoder& decode(MemoryRegion<byte>&, ASN1_Tag);
 
       BER_Decoder& decode(bool&, ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
       BER_Decoder& decode(u32bit&, ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
-      BER_Decoder& decode(class BigInt&,
+      BER_Decoder& decode(class Botan::math::BigInt&,
                           ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
       BER_Decoder& decode(MemoryRegion<byte>&, ASN1_Tag,
                           ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
@@ -47,82 +50,95 @@ class BER_Decoder
       template<typename T>
       BER_Decoder& decode_optional(T&, ASN1_Tag, ASN1_Tag, const T& = T());
 
+      /**
+       * specialization for MemoryRegion\<byte\>
+       */
+      BER_Decoder& decode_optional(MemoryRegion<byte>& out,
+                                               ASN1_Tag real_type,
+              ASN1_Tag type_tag,
+              ASN1_Tag class_tag,
+              const MemoryRegion<byte>& default_value);
+
       template<typename T>
       BER_Decoder& decode_list(std::vector<T>&, bool = true);
 
       BER_Decoder& decode_optional_string(MemoryRegion<byte>&,
                                           ASN1_Tag, u16bit);
 
-      BER_Decoder(DataSource&);
+      BER_Decoder(const SharedPtrConverter<DataSource>&);
       BER_Decoder(const byte[], u32bit);
       BER_Decoder(const MemoryRegion<byte>&);
       BER_Decoder(const BER_Decoder&);
       ~BER_Decoder();
-   private:
-      BER_Decoder& operator=(const BER_Decoder&) { return (*this); }
+    private:
+      BER_Decoder& operator=(const BER_Decoder&)
+      {
+        return (*this);
+      }
 
-      BER_Decoder* parent;
-      DataSource* source;
+      BER_Decoder* parent; // objects are not created with new, so no smart_ptr necessary
+      std::tr1::shared_ptr<DataSource> source;
       BER_Object pushed;
       mutable bool owns;
-   };
+    };
 
-/*************************************************
-* Decode an OPTIONAL or DEFAULT element          *
-*************************************************/
-template<typename T>
-BER_Decoder& BER_Decoder::decode_optional(T& out,
-                                          ASN1_Tag type_tag,
-                                          ASN1_Tag class_tag,
-                                          const T& default_value)
-   {
-   BER_Object obj = get_next_object();
+  /*************************************************
+  * Decode an OPTIONAL or DEFAULT element          *
+  *************************************************/
+  template<typename T>
+  BER_Decoder& BER_Decoder::decode_optional(T& out,
+      ASN1_Tag type_tag,
+      ASN1_Tag class_tag,
+      const T& default_value)
+  {
+    BER_Object obj = get_next_object();
 
-   if(obj.type_tag == type_tag && obj.class_tag == class_tag)
+    if(obj.type_tag == type_tag && obj.class_tag == class_tag)
       {
-      if(class_tag & CONSTRUCTED)
-         BER_Decoder(obj.value).decode(out).verify_end();
-      else
-         {
-         push_back(obj);
-         decode(out, type_tag, class_tag);
-         }
+        if(class_tag & CONSTRUCTED)
+          BER_Decoder(obj.value).decode(out).verify_end();
+        else
+          {
+            push_back(obj);
+            decode(out, type_tag, class_tag);
+          }
       }
-   else
+    else
       {
-      out = default_value;
-      push_back(obj);
+        out = default_value;
+        push_back(obj);
       }
 
-   return (*this);
-   }
+    return (*this);
+  }
 
-/*************************************************
-* Decode a list of homogenously typed values     *
-*************************************************/
-template<typename T>
-BER_Decoder& BER_Decoder::decode_list(std::vector<T>& vec, bool clear_it)
-   {
-   if(clear_it)
+  /*************************************************
+  * Decode a list of homogenously typed values     *
+  *************************************************/
+  template<typename T>
+  BER_Decoder& BER_Decoder::decode_list(std::vector<T>& vec, bool clear_it)
+  {
+    if(clear_it)
       vec.clear();
 
-   while(more_items())
+    while(more_items())
       {
-      T value;
-      decode(value);
-      vec.push_back(value);
+        T value;
+        decode(value);
+        vec.push_back(value);
       }
-   return (*this);
-   }
+    return (*this);
+  }
 
-/*************************************************
-* BER Decoding Functions                         *
-*************************************************/
-namespace BER {
+  /*************************************************
+  * BER Decoding Functions                         *
+  *************************************************/
+  namespace BER
+    {
 
-void decode(BER_Decoder&, Key_Constraints&);
+    void decode(BER_Decoder&, Key_Constraints&);
 
-}
+  }
 
 }
 
============================================================
--- include/bigint.h	f81e5621041cfc85cafbe2a72f9ce5fb7145ec58
+++ include/bigint.h	4471d0008ca4005efdc2204f4d1f27a707d86021
@@ -1,113 +1,440 @@
 /*************************************************
 * BigInt Header File                             *
-* (C) 1999-2007 The Botan Project                *
+* (C) 2007 FlexSecure                            *
 *************************************************/
 
-#ifndef BOTAN_BIGINT_H__
-#define BOTAN_BIGINT_H__
+#ifndef BOTAN_MATH_BIGINT_H__
+#define BOTAN_MATH_BIGINT_H__
 
 #include <botan/base.h>
-#include <botan/mp_types.h>
+#include <botan/math/mp_types.h>
 #include <iosfwd>
 
 namespace Botan {
+namespace math {
 
-/*************************************************
-* BigInt                                         *
-*************************************************/
+
+/**
+ * Big Integer representation.
+ * This class defines an integer type, that can be very big. Additionly some helper functions are defined to work more comfortly.
+ *
+ */
 class BigInt
    {
+	friend class Modular_Reducer;
+    friend void montg_mult(BigInt& result, BigInt& a_bar, BigInt& b_bar, const BigInt& m, const BigInt& m_dash, const BigInt r);
+
    public:
+      /**
+       * Base-Enumerator (currently 8,10,16 and 256 are defined)
+       */
       enum Base { Octal = 8, Decimal = 10, Hexadecimal = 16, Binary = 256 };
+
+      /**
+       * Sign symbol definitions for positive and negative numbers
+       */
       enum Sign { Negative = 0, Positive = 1 };
+
+      /**
+       * Number types (Ramdon and power of two)
+       */
       enum NumberType { Random, Power2 };
 
+      /**
+       * DevideByZero-Exception
+       */
       struct DivideByZero : public Exception
          { DivideByZero() : Exception("BigInt divide by zero") {} };
 
-      BigInt& operator+=(const BigInt&);
-      BigInt& operator-=(const BigInt&);
+	  /*************
+	  * operators  *
+	  *************/
+      /**
+       * += Operator
+       * @param y the BigInt to add to the local value
+       */
+      BigInt& operator+=(const BigInt& y);
 
-      BigInt& operator*=(const BigInt&);
-      BigInt& operator/=(const BigInt&);
-      BigInt& operator%=(const BigInt&);
-      word    operator%=(word);
-      BigInt& operator<<=(u32bit);
-      BigInt& operator>>=(u32bit);
+      /**
+       * -= Operator
+       * @param y the BigInt to subtract from the local value
+       */
+      BigInt& operator-=(const BigInt& y);
 
+      /**
+       * *= Operator
+       * @param y the BigInt to multiply with the local value
+       */
+      BigInt& operator*=(const BigInt& y);
+
+      /**
+       * /= Operator
+       * @param y the BigInt to divide the local value by
+       */
+      BigInt& operator/=(const BigInt& y);
+
+      /**
+       * %= Operator, modulo operator.
+       * @param y the modulus to reduce the local value by
+       */
+      BigInt& operator%=(const BigInt& y);
+
+      /**
+       * %= Operator
+       * @param y the modulus (word) to reduce the local value by
+       */
+      word    operator%=(word y);
+
+      /**
+       * <<= Operator
+       * @param y the amount of bits to shift the local value left
+       */
+      BigInt& operator<<=(u32bit y);
+
+      /**
+       * >>= Operator
+       * @param y the amount of bits to shift the local value right
+       */
+      BigInt& operator>>=(u32bit y);
+
+      /**
+       * ++ Operator
+       */
       BigInt& operator++() { return (*this += 1); }
+
+      /**
+       * -- Operator
+       */
       BigInt& operator--() { return (*this -= 1); }
+
+      /**
+       * ++ Operator (postfix)
+       */
       BigInt  operator++(int) { BigInt x = (*this); ++(*this); return x; }
+
+      /**
+       * -- Operator (postfix)
+       */
       BigInt  operator--(int) { BigInt x = (*this); --(*this); return x; }
 
+      /**
+       * - Operator
+       */
       BigInt operator-() const;
+
+      /**
+       * ! Operator
+       */
       bool operator !() const { return (!is_nonzero()); }
 
-      s32bit cmp(const BigInt&, bool = true) const;
+      /**
+       * [] Operator (array access)
+       */
+      word& operator[](u32bit);
+
+      /**
+       * [] Operator (array access)
+       */
+      word operator[](u32bit) const;
+
+
+	/*************
+	 * functions *
+	 ************/
+
+      /**
+       * Compare *this to another BigInt.
+       * @param n the BigInt value to compare to the local value.
+       * @param check_signs Include sign in comparison?
+       * @result if (this<n) return -1, if (this>n) return 1, if both values are identical return 0.
+       */
+      s32bit cmp(const BigInt& n, bool check_signs = true) const;
+
+      /**
+       * Test if the integer has an even value
+       * @result true, if the integer an even value, false otherwise
+       */
       bool is_even() const { return (get_bit(0) == 0); }
+
+      /**
+       * Test if the integer has an odd value
+       * @result true, if the integer an odd value, false otherwise
+       */
       bool is_odd()  const { return (get_bit(0) == 1); }
+
+      /**
+       * Test if the integer is not zero.
+       * @result true, if the integer has a non-zero value, false otherwise
+       */
       bool is_nonzero() const { return (!is_zero()); }
+
+      /**
+       * Test if the integer is zero.
+       * @result true, if the integer has the value zero, false otherwise
+       */
       bool is_zero() const;
 
-      void set_bit(u32bit);
-      void clear_bit(u32bit);
-      void mask_bits(u32bit);
+      /**
+       * Set bit at specified position to specified value
+       * @param n bit position to set
+       * @param t the bit value to set bit at position n
+       */
+      void set_bit(u32bit n,bool t);
 
-      bool get_bit(u32bit) const;
-      u32bit get_substring(u32bit, u32bit) const;
-      byte byte_at(u32bit) const;
+      /**
+       * Clear all but the lowest n bits
+       * @param n amount of bits to keep
+       */
+      void mask_bits(u32bit n);
+
+      /**
+       * Resturn bit value at specified position
+       * @param n the bit offset to test
+       * @result true, if the bit at position n is set, false otherwise
+       */
+      bool get_bit(u32bit n) const;
+
+      /**
+       * Return (a maximum of) 32 bits of the complete value
+       * @param offset the offset to start extracting
+       * @param length amount of bits to extract (starting at offset)
+       * @result the integer extracted from the register starting at offset with specified length
+       */
+      u32bit get_substring(u32bit offset, u32bit length) const;
+
+      /**
+       * Return the word at a specified position of the internal register
+       * @param n position in the register
+       * @return the value at position n
+       */
       word word_at(u32bit n) const
          { return ((n < size()) ? reg[n] : 0); }
 
+      /**
+       * Return the integer as unsigned 32bit-integer-value.
+       * If the value is negative OR to big to be stored in 32bits. This function
+       * will throw an exception.
+       * @result a 32bit-integer
+       */
       u32bit to_u32bit() const;
 
+      /**
+       * Tests if the sign of the integer is negative.
+       * @result true, if the integer has a negative sign,
+       */
       bool is_negative() const { return (sign() == Negative); }
+
+      /**
+       * Tests if the sign of the integer is positive.
+       * @result true, if the integer has a positive sign,
+       */
       bool is_positive() const { return (sign() == Positive); }
-      Sign sign() const { return (signedness); }
-      Sign reverse_sign() const;
-      void flip_sign();
-      void set_sign(Sign);
+
+      /**
+       * Return the sign of the integer
+       * @result the sign of the integer
+       */
+      Sign sign() const        { return (signedness); }
+
+      /**
+       * Return the opposite sign of the represented integer value
+       * @result the opposite sign of the represented integer value
+       */
+      Sign reverse_sign() const
+      {
+    	  if(sign() == Positive)
+    	  {
+    		  return Negative;
+    	  }
+    	  return Positive;
+      }
+
+      /**
+       * Flip (change!) the sign of the integer to its opposite value
+       */
+      void flip_sign()
+      {
+    	  set_sign(reverse_sign());
+      }
+
+      /**
+       * Set sign of the integer
+       * @param sign new Sign to set
+       */
+      void set_sign(Sign sign);
+
+      /**
+       * Give absolute (positive) value of the integer
+       * @result absolute (positive) value of the integer
+       */
       BigInt abs() const;
 
+      /**
+       * Give size of internal register
+       * @result size of internal register in words
+       */
       u32bit size() const { return reg.size(); }
+
+      /**
+       * Give significant words of the represented integer value
+       * @result significant words of the represented integer value
+       */
       u32bit sig_words() const;
+
+      /**
+       * Give byte-length of the integer
+       * @result byte-length of the represented integer value
+       */
       u32bit bytes() const;
+
+      /**
+       * Get the bit-length of the integer.
+       * @result bit-length of the represented integer value
+       */
       u32bit bits() const;
 
+      /**
+       * Return a pointer to the big integer word register.
+       * @result a pointer to the start of the internal register of the integer value
+       */
       const word* data() const { return reg.begin(); }
+
+      /**
+       * return a reference to the internal register containing the integer value.
+       * @result a reference to the word-array (SecureVector<word>) with the internal register value (containing the integer value)
+       */
       SecureVector<word>& get_reg() { return reg; }
-      void grow_reg(u32bit) const;
 
-      word& operator[](u32bit);
-      word operator[](u32bit) const;
-      void clear() { reg.clear(); }
+      /**
+       * Increase internal register buffer by n words
+       * @param n increase by n words
+       */
+      void grow_reg(u32bit n) const;
 
-      void randomize(u32bit = 0);
+      /**
+       * Fill BigInt with a random number with size of bitsize
+       * @param bitsize number of bits the created ramdom value should have
+       */
+      void randomize(u32bit bitsize = 0);
 
-      void binary_encode(byte[]) const;
-      void binary_decode(const byte[], u32bit);
-      void binary_decode(const MemoryRegion<byte>&);
-      u32bit encoded_size(Base = Binary) const;
+      /**
+       * Store BigInt-value in a given byte array
+       * @param buf destination byte array for the integer value
+       */
+      void binary_encode(byte buf[]) const;
 
-      static SecureVector<byte> encode(const BigInt&, Base = Binary);
-      static void encode(byte[], const BigInt&, Base = Binary);
-      static BigInt decode(const byte[], u32bit, Base = Binary);
-      static BigInt decode(const MemoryRegion<byte>&, Base = Binary);
-      static SecureVector<byte> encode_1363(const BigInt&, u32bit);
+      /**
+       * Read integer value from a byte array with given size
+       * @param buf byte array buffer containing the integer
+       * @param length size of buf
+       */
+      void binary_decode(const byte buf[], u32bit length);
 
-      void swap(BigInt&);
+      /**
+       * Read integer value from a byte array (MemoryRegion<byte>)
+       * @param buf the BigInt value to compare to the local value.
+       */
+      void binary_decode(const MemoryRegion<byte>& buf);
 
+      /**
+       * Encode the integer value from a BigInt-object to a SecureVector of bytes
+       * @param n the BigInt to use as integer source
+       * @param base number-base of resulting byte array representation
+       * @result SecureVector of bytes containing the integer with given base
+       */
+      static SecureVector<byte> encode(const BigInt& n, Base base = Binary);
+
+      /**
+       * Encode the integer value from a BigInt-object to a byte array
+       * @param buf destination byte array for the encoded integer value with given base
+       * @param n the BigInt to use as integer source
+       * @param base number-base of resulting byte array representation
+       */
+      static void encode(byte buf[], const BigInt& n, Base base = Binary);
+
+      /**
+       * Create a BigInt-object from an integer in a byte array
+       * @param buf the BigInt value to compare to the local value.
+       * @param length size of buf
+       * @param base number-base of the integer in buf
+       * @result BigInt-representing the given integer read from the byte array
+       */
+      static BigInt decode(const byte buf[], u32bit length, Base base = Binary);
+
+      /**
+       * Encode a Big Integer to a byte array according to IEEE1363.
+       * @param n the Big Integer to encode
+       * @param bytes the length of the resulting SecureVector<byte>
+       * @result a SecureVector<byte> containing the encoded Big Integer
+       */
+      static SecureVector<byte> encode_1363(const BigInt& n, u32bit bytes);
+
+      /**
+       * Swap BigInt-value with given BigInt.
+       * @param bigint the BigInt to swap values with
+       */
+      void swap(BigInt& bigint);
+
+		/**
+		 * constructors
+		 */
+
+      /**
+       * Create empty BigInt-object
+       */
       BigInt() { signedness = Positive; }
-      BigInt(u64bit);
-      BigInt(const BigInt&);
-      BigInt(const std::string&);
-      BigInt(const byte[], u32bit, Base = Binary);
-      BigInt(Sign, u32bit);
-      BigInt(NumberType, u32bit);
-   private:
+
+      /**
+       * Create BigInt-object from 64bit-Integer value
+       * @param n 64bit-integer
+       */
+      BigInt(u64bit n);
+
+      /**
+       * Copy-Constructor: clone given BigInt
+       * @param bigint the BigInt to clone
+       */
+      BigInt(const BigInt& bigint);
+
+      /**
+       * Create BigInt-object from a string.
+       * If the string starts with 0x the rest of the string will be interpreted as hexadecimal digits.
+       * If the string starts with 0 and the second character is NOT an 'x' the string will be interpreted as octal digits.
+       * If the string starts with non-zero digit, it will be interpreted as decimal number.
+       * @param str the string to parse for an integer value
+       */
+      BigInt(const std::string& str);
+
+      /**
+       * Create a BigInt-object from an integer in a byte array
+       * @param buf the BigInt value to compare to the local value.
+       * @param length size of buf
+       * @param base number-base of the integer in buf
+       */
+      BigInt(const byte buf[], u32bit length, Base base = Binary);
+
+      /**
+       * Create BigInt-object from unsigned 32bit-Integer value and an additionly specify the sign of the value
+       * @param n 64bit-integer
+       */
+      BigInt(Sign, u32bit n);
+
+      /**
+       * Create BigInt-object from unsigned 32bit-Integer value and an additionly specify the number type
+       * @param n 32bit-integer
+       */
+      BigInt(NumberType, u32bit n);
+
+      private:
+
+      byte byte_at(u32bit) const; // checked
       void grow_to(u32bit) const;
       SecureVector<word> reg;
       Sign signedness;
+
+      void clear() { reg.clear(); } // checked
+      u32bit encoded_size(Base = Binary) const; // checked
+
    };
 
 /*************************************************
@@ -146,10 +473,5 @@ std::istream& operator>>(std::istream&, 
 
 }
 
-namespace std {
-
-inline void swap(Botan::BigInt& a, Botan::BigInt& b) { a.swap(b); }
-
 }
-
 #endif
============================================================
--- include/blinding.h	5ae0964e91119dc16655961306333f7000008883
+++ include/blinding.h	b3435544d6711ff53fecc7173196d48a66101e67
@@ -6,9 +6,10 @@
 #ifndef BOTAN_BLINDER_H__
 #define BOTAN_BLINDER_H__
 
-#include <botan/bigint.h>
-#include <botan/reducer.h>
+#include <botan/math/bigint.h>
+#include <botan/math/bigint/reducer.h>
 
+
 namespace Botan {
 
 /*************************************************
@@ -17,14 +18,32 @@ class Blinder
 class Blinder
    {
    public:
-      BigInt blind(const BigInt&) const;
-      BigInt unblind(const BigInt&) const;
+      /**
+       * blind a BigInt
+       * @param i the BigInt to blind
+       * @result a blinded BigInt
+       */
+	   Botan::math::BigInt blind(const Botan::math::BigInt& i) const;
 
+      /**
+       * unblind a BigInt
+       * @param i the BigInt to unblind
+       * @result the unblinded BigInt
+       */
+      Botan::math::BigInt unblind(const Botan::math::BigInt& i) const;
+
       Blinder() {}
-      Blinder(const BigInt&, const BigInt&, const BigInt&);
+
+      /**
+       * Blinder constructur
+       * @param e
+       * @param d
+       * @param n
+       */
+      Blinder(const Botan::math::BigInt& e, const Botan::math::BigInt& d, const Botan::math::BigInt& n);
    private:
       Modular_Reducer reducer;
-      mutable BigInt e, d;
+      mutable Botan::math::BigInt e, d;
    };
 
 }
============================================================
--- include/cbc.h	8f29180d6fb4af093a83374d9c6850eeff371530
+++ include/cbc.h	01f6b8c8388096b44cf735111d7c099c41e51b85
@@ -24,7 +24,7 @@ class CBC_Encryption : public BlockCiphe
       std::string name() const;
       void write(const byte[], u32bit);
       void end_msg();
-      const BlockCipherModePaddingMethod* padder;
+      std::tr1::shared_ptr<BlockCipherModePaddingMethod const> padder;
    };
 
 /*************************************************
@@ -40,7 +40,7 @@ class CBC_Decryption : public BlockCiphe
       std::string name() const;
       void write(const byte[], u32bit);
       void end_msg();
-      const BlockCipherModePaddingMethod* padder;
+      std::tr1::shared_ptr<BlockCipherModePaddingMethod const> padder;
       SecureVector<byte> temp;
    };
 
============================================================
--- include/cbc_mac.h	772dfc29deef8cfd49e34c95a24498cbde7defa1
+++ include/cbc_mac.h	00d597f42102f2c1c0a4d3ee3ec1b54c86c0861f
@@ -7,6 +7,7 @@
 #define BOTAN_CBC_MAC__
 
 #include <botan/base.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -18,15 +19,15 @@ class CBC_MAC : public MessageAuthentica
    public:
       void clear() throw();
       std::string name() const;
-      MessageAuthenticationCode* clone() const;
+      AutoMACPtr clone() const;      
       CBC_MAC(const std::string&);
-      ~CBC_MAC();
+      ~CBC_MAC() { };
    private:
       void add_data(const byte[], u32bit);
       void final_result(byte[]);
       void key(const byte[], u32bit);
 
-      BlockCipher* e;
+      std::tr1::shared_ptr<BlockCipher> e;
       SecureVector<byte> state;
       u32bit position;
    };
============================================================
--- include/certstor.h	98d85d143337d3bceef3f19eab26d7a64ce958b0
+++ include/certstor.h	34ea724cb47deb22c4848e8a965acfbc51c26762
@@ -27,7 +27,7 @@ class Certificate_Store
       virtual std::vector<X509_CRL>
          get_crls_for(const X509_Certificate&) const;
 
-      virtual Certificate_Store* clone() const = 0;
+      virtual std::auto_ptr<Certificate_Store> clone() const = 0;
 
       virtual ~Certificate_Store() {}
    };
============================================================
--- include/cmac.h	d69d7e37c0dd9feb3106f5f714851579ce2dadfc
+++ include/cmac.h	615e711ad9ed57e2b536b9f4e1e054116e131c89
@@ -7,6 +7,7 @@
 #define BOTAN_CMAC_H__
 
 #include <botan/base.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -18,15 +19,15 @@ class CMAC : public MessageAuthenticatio
    public:
       void clear() throw();
       std::string name() const;
-      MessageAuthenticationCode* clone() const;
+      AutoMACPtr clone() const;
       CMAC(const std::string&);
-      ~CMAC() { delete e; }
+      ~CMAC() {  } 
    private:
       void add_data(const byte[], u32bit);
       void final_result(byte[]);
       void key(const byte[], u32bit);
 
-      BlockCipher* e;
+      std::tr1::shared_ptr<BlockCipher> e;
       SecureVector<byte> buffer, state, B, P;
       u32bit position;
       byte polynomial;
============================================================
--- include/config.h	38e23953e7b72c4faf77c743cd894fa7c3aea1cf
+++ include/config.h	f4880d3d1e2a381eab9437c96cf927081233a59c
@@ -11,6 +11,7 @@
 #include <string>
 #include <vector>
 #include <map>
+#include <botan/ec_dompar.h>
 
 namespace Botan {
 
@@ -26,7 +27,10 @@ class Config
       bool is_set(const std::string&, const std::string&) const;
       void set(const std::string&, const std::string&,
                const std::string&, bool = true);
-
+        
+      EC_Domain_Params get_ec_dompar(const std::string& oid);
+	  void set_ec_dompar(const std::string& oid,  const std::vector<std::string>& dom_par);
+              
       std::string option(const std::string&) const;
       u32bit option_as_u32bit(const std::string&) const;
       u32bit option_as_time(const std::string&) const;
@@ -44,6 +48,7 @@ class Config
                                     Signature_Format&);
    private:
       std::map<std::string, std::string> settings;
+	  std::map<std::string, std::vector<std::string> > ec_domain_params;
    };
 
 /*************************************************
============================================================
--- include/crc24.h	4e80c4956c3c9841c19728faf8b4ccec95a650eb
+++ include/crc24.h	a8ae6856393498e9f3bc6c37e0001567072f8f3a
@@ -18,7 +18,7 @@ class CRC24 : public HashFunction
    public:
       void clear() throw() { crc = 0xB704CE; }
       std::string name() const { return "CRC24"; }
-      HashFunction* clone() const { return new CRC24; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new CRC24); }
       CRC24() : HashFunction(3) { clear(); }
       ~CRC24() { clear(); }
    private:
============================================================
--- include/crc32.h	f6b49ba25578e41cbe4a7472d79c1ce21cc1a62f
+++ include/crc32.h	ed1f6a52d6e4b65309a8abcbe6ce3f39748bba9b
@@ -18,7 +18,7 @@ class CRC32 : public HashFunction
    public:
       void clear() throw() { crc = 0xFFFFFFFF; }
       std::string name() const { return "CRC32"; }
-      HashFunction* clone() const { return new CRC32; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new CRC32); }
       CRC32() : HashFunction(4) { clear(); }
       ~CRC32() { clear(); }
    private:
============================================================
--- include/data_snk.h	6e50479354754787a7ea8f1c87b4e5d19104d9ce
+++ include/data_snk.h	67cff944ab7cd40c13ecc3d217aa521377c3ceef
@@ -32,12 +32,12 @@ class DataSink_Stream : public DataSink
    {
    public:
       void write(const byte[], u32bit);
-      DataSink_Stream(std::ostream&);
+      DataSink_Stream(const SharedPtrConverter<std::ostream>&);
       DataSink_Stream(const std::string&, bool = false);
       ~DataSink_Stream();
    private:
       const std::string fsname;
-      std::ostream* sink;
+      std::tr1::shared_ptr<std::ostream> sink;
       bool owns;
    };
 
============================================================
--- include/data_src.h	f12df31357e4bb3075136128d77881e23b9ee025
+++ include/data_src.h	e68fe6aa8b77a32277051aef56801ae1bb569c5b
@@ -66,7 +66,7 @@ class DataSource_Stream : public DataSou
       ~DataSource_Stream();
    private:
       const std::string fsname;
-      std::istream* source;
+      std::tr1::shared_ptr<std::istream> source; 
       u32bit total_read;
    };
 
============================================================
--- include/def_powm.h	db2161b9b4c38ff0d80cbf979ba89526632d76d7
+++ include/def_powm.h	f3d275fd20fab639634538ad51d150fe0894cf2c
@@ -6,8 +6,8 @@
 #ifndef BOTAN_DEFAULT_MODEXP_H__
 #define BOTAN_DEFAULT_MODEXP_H__
 
-#include <botan/pow_mod.h>
-#include <botan/reducer.h>
+#include <botan/math/bigint/pow_mod.h>
+#include <botan/math/bigint/reducer.h>
 #include <vector>
 
 namespace Botan {
@@ -18,19 +18,19 @@ class Fixed_Window_Exponentiator : publi
 class Fixed_Window_Exponentiator : public Modular_Exponentiator
    {
    public:
-      void set_exponent(const BigInt&);
-      void set_base(const BigInt&);
-      BigInt execute() const;
+      void set_exponent(const Botan::math::BigInt&);
+      void set_base(const Botan::math::BigInt&);
+	  Botan::math::BigInt execute() const;
 
-      Modular_Exponentiator* copy() const
-         { return new Fixed_Window_Exponentiator(*this); }
+      std::auto_ptr<Modular_Exponentiator> copy() const
+         { return std::auto_ptr<Modular_Exponentiator>(new Fixed_Window_Exponentiator(*this)); }
 
-      Fixed_Window_Exponentiator(const BigInt&, Power_Mod::Usage_Hints);
+      Fixed_Window_Exponentiator(const Botan::math::BigInt&, Power_Mod::Usage_Hints);
    private:
       Modular_Reducer reducer;
-      BigInt exp;
+      Botan::math::BigInt exp;
       u32bit window_bits;
-      std::vector<BigInt> g;
+      std::vector<Botan::math::BigInt> g;
       Power_Mod::Usage_Hints hints;
    };
 
@@ -40,18 +40,18 @@ class Montgomery_Exponentiator : public 
 class Montgomery_Exponentiator : public Modular_Exponentiator
    {
    public:
-      void set_exponent(const BigInt&);
-      void set_base(const BigInt&);
-      BigInt execute() const;
+      void set_exponent(const Botan::math::BigInt&);
+      void set_base(const Botan::math::BigInt&);
+      Botan::math::BigInt execute() const;
 
-      Modular_Exponentiator* copy() const
-         { return new Montgomery_Exponentiator(*this); }
+      std::auto_ptr<Modular_Exponentiator> copy() const
+         { return std::auto_ptr<Modular_Exponentiator>(new Montgomery_Exponentiator(*this)); }
 
-      Montgomery_Exponentiator(const BigInt&, Power_Mod::Usage_Hints);
+      Montgomery_Exponentiator(const Botan::math::BigInt&, Power_Mod::Usage_Hints);
    private:
-      BigInt exp, modulus;
-      BigInt R2, R_mod;
-      std::vector<BigInt> g;
+      Botan::math::BigInt exp, modulus;
+      Botan::math::BigInt R2, R_mod;
+      std::vector<Botan::math::BigInt> g;
       word mod_prime;
       u32bit mod_words, exp_bits, window_bits;
       Power_Mod::Usage_Hints hints;
============================================================
--- include/der_enc.h	2c3f47a1c7d1f360948af20ca6927548dae30090
+++ include/der_enc.h	9317062b086fee5abf7a1c3d70e1b52b989a3898
@@ -9,7 +9,9 @@
 #include <botan/secmem.h>
 #include <botan/enums.h>
 #include <vector>
+#include <botan/math/bigint.h>
 
+
 namespace Botan {
 
 /*************************************************
@@ -32,13 +34,13 @@ class DER_Encoder
       DER_Encoder& encode_null();
       DER_Encoder& encode(bool);
       DER_Encoder& encode(u32bit);
-      DER_Encoder& encode(const class BigInt&);
+      DER_Encoder& encode(const class Botan::math::BigInt&);
       DER_Encoder& encode(const MemoryRegion<byte>&, ASN1_Tag);
       DER_Encoder& encode(const byte[], u32bit, ASN1_Tag);
 
       DER_Encoder& encode(bool, ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
       DER_Encoder& encode(u32bit, ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
-      DER_Encoder& encode(const class BigInt&, ASN1_Tag,
+      DER_Encoder& encode(const class Botan::math::BigInt&, ASN1_Tag,
                           ASN1_Tag = CONTEXT_SPECIFIC);
       DER_Encoder& encode(const MemoryRegion<byte>&, ASN1_Tag,
                           ASN1_Tag, ASN1_Tag = CONTEXT_SPECIFIC);
============================================================
--- include/des.h	6b9b0d2c5317640b063920f56dffaca554a9aeaa
+++ include/des.h	374aca41ea6478b6ed2eda89fcc650ba6be8dfe1
@@ -18,7 +18,7 @@ class DES : public BlockCipher
    public:
       void clear() throw() { round_key.clear(); }
       std::string name() const { return "DES"; }
-      BlockCipher* clone() const { return new DES; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new DES); }
       DES() : BlockCipher(8, 8) {}
    private:
       friend class TripleDES;
@@ -47,7 +47,7 @@ class TripleDES : public BlockCipher
    public:
       void clear() throw() { des1.clear(); des2.clear(); des3.clear(); }
       std::string name() const { return "TripleDES"; }
-      BlockCipher* clone() const { return new TripleDES; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new TripleDES); }
       TripleDES() : BlockCipher(8, 16, 24, 8) {}
    private:
       void enc(const byte[], byte[]) const;
@@ -64,7 +64,7 @@ class DESX : public BlockCipher
    public:
       void clear() throw() { des.clear(); K1.clear(); K2.clear(); }
       std::string name() const { return "DESX"; }
-      BlockCipher* clone() const { return new DESX; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new DESX); }
       DESX() : BlockCipher(8, 24) {}
    private:
       void enc(const byte[], byte[]) const;
============================================================
--- include/dh.h	f3dc596fa2092a4d991746a40e631b45dcde830e
+++ include/dh.h	12dc085eddd7edc38edd94126d2a2000866c2ebb
@@ -25,7 +25,7 @@ class DH_PublicKey : public virtual DL_S
       DL_Group::Format group_format() const { return DL_Group::ANSI_X9_42; }
 
       DH_PublicKey() {}
-      DH_PublicKey(const DL_Group&, const BigInt&);
+	  DH_PublicKey(const DL_Group&, const Botan::math::BigInt&);
    private:
       void X509_load_hook();
    };
@@ -38,15 +38,10 @@ class DH_PrivateKey : public DH_PublicKe
                       public virtual DL_Scheme_PrivateKey
    {
    public:
-      SecureVector<byte> derive_key(const byte[], u32bit) const;
-      SecureVector<byte> derive_key(const DH_PublicKey&) const;
-      SecureVector<byte> derive_key(const BigInt&) const;
-
-      MemoryVector<byte> public_value() const;
-
+      SecureVector<byte> derive_key(const Public_Key&) const;
       DH_PrivateKey() {}
       DH_PrivateKey(const DL_Group&);
-      DH_PrivateKey(const DL_Group&, const BigInt&, const BigInt& = 0);
+      DH_PrivateKey(const DL_Group&, const Botan::math::BigInt&, const Botan::math::BigInt& = 0);
    private:
       void PKCS8_load_hook(bool = false);
       DH_Core core;
============================================================
--- include/dl_algo.h	c635a1d4ce27c0bf2d65dfcc29d27925bb18ebe7
+++ include/dl_algo.h	e243a66cc5c3239fb96dcea986ae2635b7b4ed7c
@@ -21,16 +21,16 @@ class DL_Scheme_PublicKey : public virtu
       bool check_key(bool) const;
 
       const DL_Group& get_domain() const { return group; }
-      const BigInt& get_y() const { return y; }
-      const BigInt& group_p() const { return group.get_p(); }
-      const BigInt& group_q() const { return group.get_q(); }
-      const BigInt& group_g() const { return group.get_g(); }
+	  const Botan::math::BigInt& get_y() const { return y; }
+      const Botan::math::BigInt& group_p() const { return group.get_p(); }
+      const Botan::math::BigInt& group_q() const { return group.get_q(); }
+      const Botan::math::BigInt& group_g() const { return group.get_g(); }
       virtual DL_Group::Format group_format() const = 0;
 
-      X509_Encoder* x509_encoder() const;
-      X509_Decoder* x509_decoder();
+      std::auto_ptr<X509_Encoder> x509_encoder() const;
+      std::auto_ptr<X509_Decoder> x509_decoder();
    protected:
-      BigInt y;
+      Botan::math::BigInt y;
       DL_Group group;
    private:
       virtual void X509_load_hook() {}
@@ -45,12 +45,12 @@ class DL_Scheme_PrivateKey : public virt
    public:
       bool check_key(bool) const;
 
-      const BigInt& get_x() const { return x; }
+      const Botan::math::BigInt& get_x() const { return x; }
 
-      PKCS8_Encoder* pkcs8_encoder() const;
-      PKCS8_Decoder* pkcs8_decoder();
+      std::auto_ptr<PKCS8_Encoder> pkcs8_encoder() const;
+      std::auto_ptr<PKCS8_Decoder> pkcs8_decoder();
    protected:
-      BigInt x;
+      Botan::math::BigInt x;
    private:
       virtual void PKCS8_load_hook(bool = false) {}
    };
============================================================
--- include/dl_group.h	5c9bb309357d9ef7c1a2140496bbcdb535216919
+++ include/dl_group.h	f8006c45dfe68129f9a939a57058f8c6e9706105
@@ -6,8 +6,9 @@
 #ifndef BOTAN_DL_PARAM_H__
 #define BOTAN_DL_PARAM_H__
 
-#include <botan/bigint.h>
+#include <botan/math/bigint.h>
 #include <botan/data_src.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
@@ -17,9 +18,9 @@ class DL_Group
 class DL_Group
    {
    public:
-      const BigInt& get_p() const;
-      const BigInt& get_q() const;
-      const BigInt& get_g() const;
+	  const Botan::math::BigInt& get_p() const;
+      const Botan::math::BigInt& get_q() const;
+      const Botan::math::BigInt& get_g() const;
 
       enum Format { ANSI_X9_42, ANSI_X9_57, PKCS_3 };
       enum PrimeType { Strong, Prime_Subgroup, DSA_Kosherizer };
@@ -28,26 +29,26 @@ class DL_Group
 
       std::string PEM_encode(Format) const;
       SecureVector<byte> DER_encode(Format) const;
-      void BER_decode(DataSource&, Format);
-      void PEM_decode(DataSource&);
+      void BER_decode(SharedPtrConverter<DataSource>, Format);
+      void PEM_decode(SharedPtrConverter<DataSource>);
 
       DL_Group();
       DL_Group(const std::string&);
       DL_Group(PrimeType, u32bit, u32bit = 0);
       DL_Group(const MemoryRegion<byte>&, u32bit = 1024, u32bit = 0);
-      DL_Group(const BigInt&, const BigInt&);
-      DL_Group(const BigInt&, const BigInt&, const BigInt&);
+      DL_Group(const Botan::math::BigInt&, const Botan::math::BigInt&);
+      DL_Group(const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&);
    private:
-      static BigInt make_dsa_generator(const BigInt&, const BigInt&);
-      static SecureVector<byte> generate_dsa_primes(BigInt&, BigInt&,
+      static Botan::math::BigInt make_dsa_generator(const Botan::math::BigInt&, const Botan::math::BigInt&);
+      static SecureVector<byte> generate_dsa_primes(Botan::math::BigInt&, Botan::math::BigInt&,
                                                     u32bit, u32bit);
-      static bool generate_dsa_primes(BigInt&, BigInt&, u32bit, u32bit,
+      static bool generate_dsa_primes(Botan::math::BigInt&, Botan::math::BigInt&, u32bit, u32bit,
                                       const MemoryRegion<byte>&);
 
       void init_check() const;
-      void initialize(const BigInt&, const BigInt&, const BigInt&);
+      void initialize(const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&);
       bool initialized;
-      BigInt p, q, g;
+      Botan::math::BigInt p, q, g;
    };
 
 }
============================================================
--- include/eax.h	8aa3f7f2c01a0ce9f5782cf66461e0c1a72145c3
+++ include/eax.h	745ac56cb63f8eb1dbe64cf25d66ea8a01b76772
@@ -23,15 +23,15 @@ class EAX_Base : public Keyed_Filter
 
       bool valid_keylength(u32bit) const;
 
-      ~EAX_Base() { delete cipher; delete mac; }
+      ~EAX_Base() { }
    protected:
       EAX_Base(const std::string&, u32bit);
       void start_msg();
       void increment_counter();
 
       const u32bit TAG_SIZE, BLOCK_SIZE;
-      BlockCipher* cipher;
-      MessageAuthenticationCode* mac;
+      std::tr1::shared_ptr<BlockCipher> cipher;
+      std::tr1::shared_ptr<MessageAuthenticationCode> mac;
       SecureVector<byte> nonce_mac, header_mac, state, buffer;
       u32bit position;
    };
============================================================
--- include/ecb.h	29ab7f13429e9642e9e3dc22569ab6bfb80d38f2
+++ include/ecb.h	b955fe26fb4fd1864c7703da943e0327c58ee1ae
@@ -19,7 +19,7 @@ class ECB : public BlockCipherMode
    protected:
       ECB(const std::string&, const std::string&);
       std::string name() const;
-      const BlockCipherModePaddingMethod* padder;
+      std::tr1::shared_ptr<BlockCipherModePaddingMethod const> padder;
    private:
       bool valid_iv_size(u32bit) const;
    };
============================================================
--- include/eme.h	b5432503dea9e40ffaf97de602b34ad522c72ecf
+++ include/eme.h	36443990c78ccf80ec77d878f3d87f92dc4b7f06
@@ -7,6 +7,7 @@
 #define BOTAN_EME_H__
 
 #include <botan/pk_util.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -19,13 +20,13 @@ class EME1 : public EME
       u32bit maximum_input_size(u32bit) const;
 
       EME1(const std::string&, const std::string&, const std::string& = "");
-      ~EME1() { delete mgf; }
+      ~EME1() { }
    private:
       SecureVector<byte> pad(const byte[], u32bit, u32bit) const;
       SecureVector<byte> unpad(const byte[], u32bit, u32bit) const;
       const u32bit HASH_LENGTH;
       SecureVector<byte> Phash;
-      MGF* mgf;
+      std::tr1::shared_ptr<MGF> mgf;
    };
 
 /*************************************************
============================================================
--- include/emsa.h	89505a710ac004a0451362593dd7fe4706cee834
+++ include/emsa.h	19a8d52cfdaf9aef12959c60ca0c7b5e9110a21e
@@ -7,6 +7,7 @@
 #define BOTAN_EMSA_H__
 
 #include <botan/pk_util.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -17,30 +18,49 @@ class EMSA1 : public EMSA
    {
    public:
       EMSA1(const std::string&);
-      ~EMSA1() { delete hash; }
+      virtual ~EMSA1() {  }
    private:
-      void update(const byte[], u32bit);
-      SecureVector<byte> encoding_of(const MemoryRegion<byte>&, u32bit);
-      SecureVector<byte> raw_data();
-      bool verify(const MemoryRegion<byte>&, const MemoryRegion<byte>&,
+      virtual void update(const byte[], u32bit);
+      virtual SecureVector<byte> encoding_of(const MemoryRegion<byte>&, u32bit);
+      virtual SecureVector<byte> raw_data();
+      virtual bool verify(const MemoryRegion<byte>&, const MemoryRegion<byte>&,
                   u32bit) throw();
-      HashFunction* hash;
+    protected:
+      std::tr1::shared_ptr<HashFunction> hash;
    };
 
 /*************************************************
+* EMSA1 BSI variant                              *
+*************************************************/
+class EMSA1_BSI : public EMSA1
+   {
+   public:
+      EMSA1_BSI(const std::string&);
+      ~EMSA1_BSI() {  }
+   private:
+      /**
+      * Accepts only hash values which are less or equal than the maximum
+      * key length
+      */
+      SecureVector<byte> encoding_of(const MemoryRegion<byte>&, u32bit);
+   };
+
+
+
+/*************************************************
 * EMSA2                                          *
 *************************************************/
 class EMSA2 : public EMSA
    {
    public:
       EMSA2(const std::string&);
-      ~EMSA2() { delete hash; }
+      ~EMSA2() { }
    private:
       void update(const byte[], u32bit);
       SecureVector<byte> encoding_of(const MemoryRegion<byte>&, u32bit);
       SecureVector<byte> raw_data();
       SecureVector<byte> empty_hash;
-      HashFunction* hash;
+      std::tr1::shared_ptr<HashFunction> hash;
       byte hash_id;
    };
 
@@ -51,12 +71,12 @@ class EMSA3 : public EMSA
    {
    public:
       EMSA3(const std::string&);
-      ~EMSA3() { delete hash; }
+      ~EMSA3() { }
    private:
       void update(const byte[], u32bit);
       SecureVector<byte> encoding_of(const MemoryRegion<byte>&, u32bit);
       SecureVector<byte> raw_data();
-      HashFunction* hash;
+      std::tr1::shared_ptr<HashFunction> hash;
       SecureVector<byte> hash_id;
    };
 
@@ -68,7 +88,7 @@ class EMSA4 : public EMSA
    public:
       EMSA4(const std::string&, const std::string&);
       EMSA4(const std::string&, const std::string&, u32bit);
-      ~EMSA4() { delete hash; delete mgf; }
+      ~EMSA4() {  }
    private:
       void update(const byte[], u32bit);
       SecureVector<byte> encoding_of(const MemoryRegion<byte>&, u32bit);
@@ -76,8 +96,8 @@ class EMSA4 : public EMSA
       bool verify(const MemoryRegion<byte>&, const MemoryRegion<byte>&,
                   u32bit) throw();
       const u32bit SALT_SIZE;
-      HashFunction* hash;
-      const MGF* mgf;
+      std::tr1::shared_ptr<HashFunction> hash;
+      std::tr1::shared_ptr<MGF const> mgf;
    };
 
 /*************************************************
============================================================
--- include/eng_def.h	c8353e6127f95e3aed4fd3bd1b40e583b0354801
+++ include/eng_def.h	a6af42e0c19ce81d3ce0d195f90aad463e34966b
@@ -6,6 +6,8 @@
 #ifndef BOTAN_DEFAULT_ENGINE_H__
 #define BOTAN_DEFAULT_ENGINE_H__
 
+#include <botan/tr1_mem_includer.h>
+
 #include <botan/engine.h>
 
 namespace Botan {
@@ -16,28 +18,46 @@ class Default_Engine : public Engine
 class Default_Engine : public Engine
    {
    public:
-      IF_Operation* if_op(const BigInt&, const BigInt&, const BigInt&,
-                          const BigInt&, const BigInt&, const BigInt&,
-                          const BigInt&, const BigInt&) const;
-      DSA_Operation* dsa_op(const DL_Group&, const BigInt&,
-                            const BigInt&) const;
-      NR_Operation* nr_op(const DL_Group&, const BigInt&, const BigInt&) const;
-      ELG_Operation* elg_op(const DL_Group&, const BigInt&,
-                            const BigInt&) const;
-      DH_Operation* dh_op(const DL_Group&, const BigInt&) const;
+      std::tr1::shared_ptr<IF_Operation>
+		  if_op(const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+               const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+               const Botan::math::BigInt&, const Botan::math::BigInt&) const;
 
-      Modular_Exponentiator* mod_exp(const BigInt&,
-                                     Power_Mod::Usage_Hints) const;
+      std::tr1::shared_ptr<DSA_Operation>
+         dsa_op(const DL_Group&, const Botan::math::BigInt&, const Botan::math::BigInt&) const;
+      
+      std::tr1::shared_ptr<ECDSA_Operation>
+         ecdsa_op(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key) const;
+      
+      std::tr1::shared_ptr<ECKAEG_Operation>
+         eckaeg_op(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key) const;
 
-      Keyed_Filter* get_cipher(const std::string&, Cipher_Dir);
+      std::tr1::shared_ptr<DH_Operation>
+         dh_op(const DL_Group&, const Botan::math::BigInt&) const;
+
+      std::auto_ptr<Modular_Exponentiator>
+         mod_exp(const Botan::math::BigInt&, Power_Mod::Usage_Hints) const;
+
+      std::tr1::shared_ptr<Keyed_Filter>
+         get_cipher(const std::string&, Cipher_Dir);
+
    private:
-      BlockCipher* find_block_cipher(const std::string&) const;
-      StreamCipher* find_stream_cipher(const std::string&) const;
-      HashFunction* find_hash(const std::string&) const;
-      MessageAuthenticationCode* find_mac(const std::string&) const;
+      std::tr1::shared_ptr<BlockCipher>
+         find_block_cipher(const std::string&) const;
 
-      class S2K* find_s2k(const std::string&) const;
-      class BlockCipherModePaddingMethod*
+      std::tr1::shared_ptr<StreamCipher>
+         find_stream_cipher(const std::string&) const;
+      
+      std::tr1::shared_ptr<HashFunction>
+        find_hash(const std::string&) const;
+
+      std::tr1::shared_ptr<MessageAuthenticationCode>
+         find_mac(const std::string&) const;
+
+      std::tr1::shared_ptr<class S2K>
+         find_s2k(const std::string&) const;
+      
+      std::tr1::shared_ptr<class BlockCipherModePaddingMethod>
          find_bc_pad(const std::string&) const;
    };
 
============================================================
--- include/engine.h	20654be095cb727e6e4c850306e286e47fe7699f
+++ include/engine.h	59828f9968ce7bc2e36c86d0fe98183f8eef365d
@@ -9,93 +9,124 @@
 #include <botan/base.h>
 #include <botan/mutex.h>
 #include <botan/pk_ops.h>
-#include <botan/pow_mod.h>
+#include <botan/math/bigint/pow_mod.h>
 #include <botan/basefilt.h>
 #include <botan/enums.h>
 #include <utility>
 #include <map>
+#include <botan/tr1_mem_includer.h>
+#include <iostream>
+#include <botan/ec_dompar.h>
+#include <botan/ecdsa.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
+class S2K;
+class BlockCipherModePaddingMethod;
 /*************************************************
 * Engine Base Class                              *
 *************************************************/
 class Engine
    {
    public:
+      typedef std::tr1::shared_ptr<Keyed_Filter> Keyed_Filter_Ptr;
+
       template<typename T>
       class Algorithm_Cache
          {
          public:
-            virtual T* get(const std::string&) const = 0;
-            virtual void add(T* algo, const std::string& = "") const = 0;
+            virtual std::tr1::shared_ptr<T> get(const std::string&) const = 0;
+            virtual void add(std::tr1::shared_ptr<T> const& algo, const std::string& = "") const = 0;
             virtual ~Algorithm_Cache() {}
          };
 
-      virtual IF_Operation* if_op(const BigInt&, const BigInt&, const BigInt&,
-                                  const BigInt&, const BigInt&, const BigInt&,
-                                  const BigInt&, const BigInt&) const;
-      virtual DSA_Operation* dsa_op(const DL_Group&, const BigInt&,
-                                    const BigInt&) const;
-      virtual NR_Operation* nr_op(const DL_Group&, const BigInt&,
-                                  const BigInt&) const;
-      virtual ELG_Operation* elg_op(const DL_Group&, const BigInt&,
-                                    const BigInt&) const;
-      virtual DH_Operation* dh_op(const DL_Group&, const BigInt&) const;
+      virtual std::tr1::shared_ptr<IF_Operation>
+		  if_op(const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+               const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+               const Botan::math::BigInt&, const Botan::math::BigInt&) const;
 
-      virtual Modular_Exponentiator* mod_exp(const BigInt&,
-                                             Power_Mod::Usage_Hints) const;
+      virtual std::tr1::shared_ptr<DH_Operation>
+         dh_op(const DL_Group&, const Botan::math::BigInt&) const;
+      
+      virtual std::tr1::shared_ptr<ECDSA_Operation>
+		  ecdsa_op(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key) const;
 
-      virtual Keyed_Filter* get_cipher(const std::string&, Cipher_Dir);
+      virtual std::tr1::shared_ptr<ECKAEG_Operation>
+         eckaeg_op(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key) const;
 
-      const BlockCipher* block_cipher(const std::string&) const;
-      const StreamCipher* stream_cipher(const std::string&) const;
-      const HashFunction* hash(const std::string&) const;
-      const MessageAuthenticationCode* mac(const std::string&) const;
-      const class S2K* s2k(const std::string&) const;
-      const class BlockCipherModePaddingMethod*
+      virtual std::auto_ptr<Modular_Exponentiator>
+         mod_exp(const Botan::math::BigInt&, Power_Mod::Usage_Hints) const;
+
+      virtual std::tr1::shared_ptr<Keyed_Filter>
+         get_cipher(const std::string&, Cipher_Dir);
+
+      std::tr1::shared_ptr<BlockCipher const>
+         block_cipher(const std::string&) const;
+
+      std::tr1::shared_ptr<StreamCipher const>
+         stream_cipher(const std::string&) const;
+
+      std::tr1::shared_ptr<HashFunction const>
+         hash(const std::string&) const;
+
+      std::tr1::shared_ptr<MessageAuthenticationCode const>
+         mac(const std::string&) const;
+
+      std::tr1::shared_ptr<S2K const>
+        s2k(const std::string&) const;
+
+      std::tr1::shared_ptr<BlockCipherModePaddingMethod const>
          bc_pad(const std::string&) const;
 
-      void add_algorithm(BlockCipher*) const;
-      void add_algorithm(StreamCipher*) const;
-      void add_algorithm(HashFunction*) const;
-      void add_algorithm(MessageAuthenticationCode*) const;
-      void add_algorithm(class S2K*) const;
-      void add_algorithm(class BlockCipherModePaddingMethod*) const;
+      void add_algorithm_bc(SharedPtrConverter<BlockCipher> const&) const;
+      void add_algorithm_sc(SharedPtrConverter<StreamCipher> const&) const;
+      void add_algorithm_hf(SharedPtrConverter<HashFunction> const&) const;
+      void add_algorithm_mac(SharedPtrConverter<MessageAuthenticationCode> const&) const;
+      void add_algorithm_s2k(SharedPtrConverter<class S2K> const&) const;
+      void add_algorithm_bcmpm(SharedPtrConverter<class BlockCipherModePaddingMethod> const&) const;
 
       Engine();
       virtual ~Engine();
    private:
-      virtual BlockCipher* find_block_cipher(const std::string&) const;
-      virtual StreamCipher* find_stream_cipher(const std::string&) const;
-      virtual HashFunction* find_hash(const std::string&) const;
-      virtual MessageAuthenticationCode* find_mac(const std::string&) const;
-      virtual class S2K* find_s2k(const std::string&) const;
-      virtual class BlockCipherModePaddingMethod*
+      virtual std::tr1::shared_ptr<BlockCipher>
+         find_block_cipher(const std::string&) const;
+
+      virtual std::tr1::shared_ptr<StreamCipher>
+         find_stream_cipher(const std::string&) const;
+
+      virtual std::tr1::shared_ptr<HashFunction>
+         find_hash(const std::string&) const;
+
+      virtual std::tr1::shared_ptr<MessageAuthenticationCode>
+         find_mac(const std::string&) const;
+
+      virtual std::tr1::shared_ptr<S2K>
+         find_s2k(const std::string&) const;
+
+      virtual std::tr1::shared_ptr<BlockCipherModePaddingMethod>
          find_bc_pad(const std::string&) const;
 
       template<typename T>
-      const T* lookup_algo(const Algorithm_Cache<T>* cache,
-                           const std::string& name,
-                           const Engine* engine,
-                           T* (Engine::*find)(const std::string&) const) const
+      std::tr1::shared_ptr<T>
+         lookup_algo(const std::tr1::shared_ptr<Algorithm_Cache<T> >& cache,
+                     const std::string& name,
+                     const Engine* engine,
+                     std::tr1::shared_ptr<T> (Engine::*find)(const std::string& name) const) const
          {
-         T* algo = cache->get(name);
-         if(!algo)
-            {
-            algo = (engine->*find)(name);
-            if(algo)
-               cache->add(algo, name);
-            }
+         std::tr1::shared_ptr<T> algo = cache->get(name);
+         if(!algo.get()) {
+            cache->add(algo = (engine->*find)(name));
+         }
          return algo;
          }
 
-      Algorithm_Cache<BlockCipher>* cache_of_bc;
-      Algorithm_Cache<StreamCipher>* cache_of_sc;
-      Algorithm_Cache<HashFunction>* cache_of_hf;
-      Algorithm_Cache<MessageAuthenticationCode>* cache_of_mac;
-      Algorithm_Cache<BlockCipherModePaddingMethod>* cache_of_bc_pad;
-      Algorithm_Cache<S2K>* cache_of_s2k;
+      std::tr1::shared_ptr<Algorithm_Cache<BlockCipher> > cache_of_bc;
+      std::tr1::shared_ptr<Algorithm_Cache<StreamCipher> > cache_of_sc;
+      std::tr1::shared_ptr<Algorithm_Cache<HashFunction> > cache_of_hf;
+      std::tr1::shared_ptr<Algorithm_Cache<MessageAuthenticationCode> > cache_of_mac;
+      std::tr1::shared_ptr<Algorithm_Cache<BlockCipherModePaddingMethod> > cache_of_bc_pad;
+      std::tr1::shared_ptr<Algorithm_Cache<S2K> > cache_of_s2k;
    };
 
 namespace Engine_Core {
@@ -103,19 +134,16 @@ namespace Engine_Core {
 /*************************************************
 * Get an operation from an Engine                *
 *************************************************/
-Modular_Exponentiator* mod_exp(const BigInt&, Power_Mod::Usage_Hints);
+std::auto_ptr<Modular_Exponentiator> mod_exp(const Botan::math::BigInt&, Power_Mod::Usage_Hints);
 
-IF_Operation* if_op(const BigInt&, const BigInt&, const BigInt&,
-                    const BigInt&, const BigInt&, const BigInt&,
-                    const BigInt&, const BigInt&);
+std::tr1::shared_ptr<IF_Operation> if_op(const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+                    const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+                    const Botan::math::BigInt&, const Botan::math::BigInt&);
 
-DSA_Operation* dsa_op(const DL_Group&, const BigInt&, const BigInt&);
-NR_Operation* nr_op(const DL_Group&, const BigInt&, const BigInt&);
+std::tr1::shared_ptr<DH_Operation> dh_op(const DL_Group&, const Botan::math::BigInt&);
 
-ELG_Operation* elg_op(const DL_Group&, const BigInt&, const BigInt&);
-
-DH_Operation* dh_op(const DL_Group&, const BigInt&);
-
+std::tr1::shared_ptr<ECDSA_Operation> ecdsa_op(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key);
+std::tr1::shared_ptr<ECKAEG_Operation> eckaeg_op(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key);
 }
 
 }
============================================================
--- include/enums.h	06237002097d2faaca50f83ab28eb7ec1e8b5f9d
+++ include/enums.h	945aeb2a149756db2b6b1ce665becda8ca8c7128
@@ -42,7 +42,12 @@ enum ASN1_Tag {
    GENERALIZED_TIME = 0x18,
 
    NO_OBJECT        = 0xFF00,
-   DIRECTORY_STRING = 0xFF01
+   DIRECTORY_STRING = 0xFF01,
+
+   // CV Certificate Tags
+
+   CV_Certificate = 0x7F,
+   CVC_ADO = 0x67
 };
 
 /*************************************************
@@ -116,6 +121,24 @@ static const u32bit NO_CERT_PATH_LIMIT =
 
 static const u32bit NO_CERT_PATH_LIMIT = 0xFFFFFFF0;
 
+/*******************************
+* cvc CHAT values              *
+*******************************/
+enum CHAT_values{
+      CVCA = 0xC0,
+      DVCA_domestic = 0x80,
+      DVCA_foreign =  0x40,
+      IS   = 0x00,
+
+      IRIS = 0x02,
+      FINGERPRINT = 0x01
+};
+
+/**
+* The encoding types used by the key when encoded via an X509 or CVC encoder.
+*/
+        enum EC_dompar_enc { ENC_EXPLICIT = 0, ENC_IMPLICITCA = 1, ENC_OID = 2 };
+
 }
 
 #endif
============================================================
--- include/exceptn.h	120505f40281475a5872fa41329b1e82f5adf194
+++ include/exceptn.h	4113be2be4823d8c836632896635c5d97deebd7f
@@ -206,7 +206,25 @@ struct Memory_Exhaustion : public Except
    Memory_Exhaustion() :
       Exception("Ran out of memory, allocation failed") {}
    };
-
+/*************************************************
+* No quadratic residue exception                 *
+* (for use in BigInt-functs->ressol())           *
+*************************************************/
+struct No_Quadratic_Residue : public Exception
+{
+    No_Quadratic_Residue() :
+            Exception("No quadratic residue") {}
+};
+struct Illegal_Point : public Exception
+{
+    Illegal_Point(const std::string& err = "")
+    : Exception(err) {}
+};
+struct Illegal_Transformation : public Exception
+{
+    Illegal_Transformation(const std::string& err = "Requested transformation is not possible")
+    : Exception(err) {}
+};
 }
 
 #endif
============================================================
--- include/filter.h	2050b7b09aa807090598434d8ac5ebb83fbf2503
+++ include/filter.h	ce7a80041648cf405604930703136a67584316f4
@@ -1,3 +1,4 @@
+// -*- mode: C++ -*-
 /*************************************************
 * Filter Header File                             *
 * (C) 1999-2007 The Botan Project                *
@@ -7,16 +8,25 @@
 #define BOTAN_FILTER_H__
 
 #include <botan/base.h>
+#include <botan/freestore.h>
 #include <vector>
+#include <iterator>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
 /*************************************************
 * Filter Base Class                              *
 *************************************************/
-class Filter
+class Filter : public Freestore
    {
    public:
+      typedef SharedPtrConverter<Filter> SharedFilterPtrConverter;
+
+      typedef std::auto_ptr<Filter> AutoFilterPtr;
+      typedef std::tr1::shared_ptr<Filter> SharedFilterPtr;
+      typedef std::vector<SharedFilterPtr> SharedFilterPtrVector;
+
       virtual void write(const byte[], u32bit) = 0;
       virtual void start_msg() {}
       virtual void end_msg() {}
@@ -30,8 +40,19 @@ class Filter
       void send(const MemoryRegion<byte>& in) { send(in.begin(), in.size()); }
       Filter();
    private:
-      Filter(const Filter&) {}
-      Filter& operator=(const Filter&) { return (*this); }
+      // CL: The implementation of the compiler generated copy constructor and
+      // assignment operator would be fine, but we need(?) them to be private.
+      // So we have to provide the default implementation ourselves.
+      //
+      // TODO: Check if the copy constructor and assignment operator are
+      // called at all. Otherwise it would be more idiomatic to declare them
+      // without a definition.
+      Filter(Filter const& f) : Freestore(f) {}
+      Filter& operator=(Filter const& f) 
+         {
+         Freestore::operator=(f);
+         return (*this); 
+         }
 
       friend class Pipe;
       friend class Fanout_Filter;
@@ -42,14 +63,64 @@ class Filter
 
       u32bit owns() const { return filter_owns; }
 
-      void attach(Filter*);
-      void set_next(Filter*[], u32bit);
-      Filter* get_next() const;
+      void attach(SharedFilterPtrConverter const&);
 
+      template<typename FilterPtr>
+      class EvaluatesTrue
+         {
+         public:
+            bool operator()(FilterPtr const& p)
+               {
+                 return p.get() != 0;
+               }
+         }; 
+
+      // Set the next filters.
+      // Assumes that [begin, end) is a range of SharedFilterPtr objects
+      // or AutoFilterPtr objects.
+      // ConstIter has to be a bidirectional iterator type.
+      template<typename ConstIter>
+      void set_next(ConstIter begin, ConstIter end)
+      {
+        typedef std::reverse_iterator<ConstIter> ConstRevIter;
+        typedef typename std::iterator_traits<ConstIter>::value_type PtrType;
+
+        // find last element that really contains a pointer
+        ConstIter iter = std::find_if(ConstRevIter(end),
+                                      ConstRevIter(begin),
+                                      EvaluatesTrue<PtrType>()).base();
+
+        this->next.clear();
+        this->next.reserve(std::distance(begin, iter));
+        for(; begin != iter; ++begin)
+           {
+             this->next.push_back(SharedFilterPtr(*begin));
+           }
+
+        this->port_num = 0;
+        this->filter_owns = 0;
+      }
+
+     // The followig overloads are replacements
+     // for set_next(Filter* v[], u32bit size).
+     // I'd rather forego them completely, above range based
+     // function template overload is much more idiomatic.
+//      void set_next(SharedFilterPtr const v[], u32bit size) 
+//         {
+//         this->set_next<SharedFilterPtr const*>(v, v + size); 
+//         }
+//
+//      void set_next(AutoFilterPtr v[], u32bit size) 
+//         {
+//         this->set_next<AutoFilterPtr*>(v, v + size); 
+//         }
+
+      SharedFilterPtr const get_next() const;
+
       SecureVector<byte> write_queue;
-      std::vector<Filter*> next;
+      SharedFilterPtrVector next;
       u32bit port_num, filter_owns;
-      bool owned;
+      bool owned; // true if filter belongs to a pipe --> prohibit filter sharing!
    };
 
 /*************************************************
@@ -60,9 +131,9 @@ class Fanout_Filter : public Filter
    protected:
       void incr_owns() { ++filter_owns; }
 
-      void set_port(u32bit n) { Filter::set_port(n); }
-      void set_next(Filter* f[], u32bit n) { Filter::set_next(f, n); }
-      void attach(Filter* f) { Filter::attach(f); }
+      using Filter::set_port;
+      using Filter::set_next;
+      using Filter::attach;
    };
 
 }
============================================================
--- include/filters.h	bb51ce701097541948779da3f3bbe96651dcf24c
+++ include/filters.h	d532a5323ceaca0314e6af1a883a918de9c781e8
@@ -29,10 +29,10 @@ class StreamCipher_Filter : public Keyed
 
       StreamCipher_Filter(const std::string&);
       StreamCipher_Filter(const std::string&, const SymmetricKey&);
-      ~StreamCipher_Filter() { delete cipher; }
+      ~StreamCipher_Filter() {  }
    private:
       SecureVector<byte> buffer;
-      StreamCipher* cipher;
+      std::tr1::shared_ptr<StreamCipher> cipher;
    };
 
 /*************************************************
@@ -45,10 +45,10 @@ class Hash_Filter : public Filter
       void end_msg();
 
       Hash_Filter(const std::string&, u32bit = 0);
-      ~Hash_Filter() { delete hash; }
+      ~Hash_Filter() {  }
    private:
       const u32bit OUTPUT_LENGTH;
-      HashFunction* hash;
+      std::tr1::shared_ptr<HashFunction> hash;
    };
 
 /*************************************************
@@ -62,10 +62,10 @@ class MAC_Filter : public Keyed_Filter
 
       MAC_Filter(const std::string&, u32bit = 0);
       MAC_Filter(const std::string&, const SymmetricKey&, u32bit = 0);
-      ~MAC_Filter() { delete mac; }
+      ~MAC_Filter() {  }
    private:
       const u32bit OUTPUT_LENGTH;
-      MessageAuthenticationCode* mac;
+      std::tr1::shared_ptr<MessageAuthenticationCode> mac;
    };
 
 }
============================================================
--- include/hmac.h	eb82b13624a2365487c9651fd45f9619abdc5f5c
+++ include/hmac.h	cb6137c68c3b33ef6916131f9e16caa91d07efcf
@@ -7,6 +7,7 @@
 #define BOTAN_HMAC_H__
 
 #include <botan/base.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -18,14 +19,14 @@ class HMAC : public MessageAuthenticatio
    public:
       void clear() throw();
       std::string name() const;
-      MessageAuthenticationCode* clone() const;
+      MessageAuthenticationCode::AutoMACPtr clone() const;
       HMAC(const std::string&);
-      ~HMAC() { delete hash; }
+      ~HMAC() { } 
    private:
       void add_data(const byte[], u32bit);
       void final_result(byte[]);
       void key(const byte[], u32bit);
-      HashFunction* hash;
+      std::tr1::shared_ptr<HashFunction> hash;
       SecureVector<byte> i_key, o_key;
    };
 
============================================================
--- include/if_algo.h	f801b3d836a41b2db02f82a6f7f3c1ca711d5128
+++ include/if_algo.h	b07f837317b6be619ccb8c2795f75679a96416ba
@@ -10,6 +10,8 @@
 #include <botan/pkcs8.h>
 #include <botan/pk_core.h>
 
+#include <botan/math/bigint.h>
+
 namespace Botan {
 
 /*************************************************
@@ -20,16 +22,16 @@ class IF_Scheme_PublicKey : public virtu
    public:
       bool check_key(bool) const;
 
-      const BigInt& get_n() const { return n; }
-      const BigInt& get_e() const { return e; }
+      const Botan::math::BigInt& get_n() const { return n; }
+      const Botan::math::BigInt& get_e() const { return e; }
 
       u32bit max_input_bits() const { return (n.bits() - 1); }
 
-      X509_Encoder* x509_encoder() const;
-      X509_Decoder* x509_decoder();
+      std::auto_ptr<X509_Encoder> x509_encoder() const;
+      std::auto_ptr<X509_Decoder> x509_decoder();
    protected:
       virtual void X509_load_hook();
-      BigInt n, e;
+      Botan::math::BigInt n, e;
       IF_Core core;
    };
 
@@ -42,15 +44,15 @@ class IF_Scheme_PrivateKey : public virt
    public:
       bool check_key(bool) const;
 
-      const BigInt& get_p() const { return p; }
-      const BigInt& get_q() const { return q; }
-      const BigInt& get_d() const { return d; }
+      const Botan::math::BigInt& get_p() const { return p; }
+      const Botan::math::BigInt& get_q() const { return q; }
+      const Botan::math::BigInt& get_d() const { return d; }
 
-      PKCS8_Encoder* pkcs8_encoder() const;
-      PKCS8_Decoder* pkcs8_decoder();
+      std::auto_ptr<PKCS8_Encoder> pkcs8_encoder() const;
+      std::auto_ptr<PKCS8_Decoder> pkcs8_decoder();
    protected:
       virtual void PKCS8_load_hook(bool = false);
-      BigInt d, p, q, d1, d2, c;
+      Botan::math::BigInt d, p, q, d1, d2, c;
    };
 
 }
============================================================
--- include/keypair.h	5e9ee863a0ee9dbe63cbcb39d5440a09c4f5c828
+++ include/keypair.h	19bbb3dc0ffcb6b4b503de2e5742ec08d2b5b9a7
@@ -15,8 +15,8 @@ namespace KeyPair {
 /*************************************************
 * Check key pair consistency                     *
 *************************************************/
-void check_key(PK_Encryptor*, PK_Decryptor*);
-void check_key(PK_Signer*, PK_Verifier*);
+void check_key(std::auto_ptr<PK_Encryptor>, std::auto_ptr<PK_Decryptor>);
+void check_key(std::auto_ptr<PK_Signer>, std::auto_ptr<PK_Verifier>);
 
 }
 
============================================================
--- include/libstate.h	4dddb269a906154b79debb9588397ac08334ccf6
+++ include/libstate.h	af666823f922b8c336c602be7567ebb0da5ce07c
@@ -8,12 +8,13 @@
 
 #include <botan/base.h>
 #include <botan/enums.h>
-#include <botan/init.h>
 #include <botan/ui.h>
+#include <botan/freestore.h>
 #include <string>
 #include <vector>
 #include <map>
 
+
 namespace Botan {
 
 /*************************************************
@@ -22,19 +23,10 @@ class Library_State
 class Library_State
    {
    public:
-      Library_State();
-      ~Library_State();
-
-      void initialize(const InitializerOptions&, Modules&);
-
-      void load(Modules&);
-
-      void add_engine(class Engine*);
-
       class Engine_Iterator
          {
          public:
-            class Engine* next();
+            std::tr1::shared_ptr<class Engine> next();
             Engine_Iterator(const Library_State& l) : lib(l) { n = 0; }
          private:
             const Library_State& lib;
@@ -49,66 +41,78 @@ class Library_State
             virtual ~UI() {}
          };
 
-      Allocator* get_allocator(const std::string& = "") const;
-      void add_allocator(Allocator*);
+      std::tr1::shared_ptr<Allocator> get_allocator(const std::string& = "") const;
+      void add_allocator(SharedPtrConverter<Allocator>);
       void set_default_allocator(const std::string&) const;
 
       bool rng_is_seeded() const { return rng->is_seeded(); }
       void randomize(byte[], u32bit);
 
       void set_prng(RandomNumberGenerator*);
-      void add_entropy_source(EntropySource*, bool = true);
+      void add_entropy_source(SharedPtrConverter<EntropySource>, bool = true);
       void add_entropy(const byte[], u32bit);
       void add_entropy(EntropySource&, bool);
       u32bit seed_prng(bool, u32bit);
 
-      void set_timer(class Timer*);
+      void load(class Modules&);
+
+      void set_timer(SharedPtrConverter<class Timer>);
       u64bit system_clock() const;
 
       class Config& config() const;
 
-      class Mutex* get_mutex() const;
-      class Mutex* get_named_mutex(const std::string&);
+      void add_engine(SharedPtrConverter<class Engine>);
 
-      void set_x509_state(class X509_GlobalState*);
-      class X509_GlobalState& x509_state();
+      std::auto_ptr<class Mutex> get_mutex() const;
+      std::tr1::shared_ptr<class Mutex> get_named_mutex(const std::string&);
 
+      void set_x509_state(SharedPtrConverter<class X509_GlobalState>);
+      std::tr1::shared_ptr<class X509_GlobalState> x509_state();
+
       void pulse(Pulse_Type) const;
-      void set_ui(UI*);
+      void set_ui(SharedPtrConverter<UI>);
 
-      void set_transcoder(class Charset_Transcoder*);
+      void set_transcoder(SharedPtrConverter<class Charset_Transcoder>);
       std::string transcode(const std::string,
                             Character_Set, Character_Set) const;
+
+      Library_State(SharedPtrConverter<class Mutex_Factory>);
+      ~Library_State();
    private:
       Library_State(const Library_State&) {}
       Library_State& operator=(const Library_State&) { return (*this); }
 
-      class Engine* get_engine_n(u32bit) const;
+      std::tr1::shared_ptr<class Engine> get_engine_n(u32bit) const;
 
-      class Mutex_Factory* mutex_factory;
-      class Timer* timer;
-      mutable class Config* config_obj;
-      class X509_GlobalState* x509_state_obj;
+      std::tr1::shared_ptr<class Mutex_Factory> mutex_factory;
+      std::tr1::shared_ptr<class Timer> timer;
+      std::tr1::shared_ptr<class Config> config_obj;
+      std::tr1::shared_ptr<class X509_GlobalState> x509_state_obj;
 
-      std::map<std::string, class Mutex*> locks;
-      std::map<std::string, Allocator*> alloc_factory;
-      mutable Allocator* cached_default_allocator;
+      std::map<std::string, std::tr1::shared_ptr<class Mutex> > locks;
+      std::map<std::string, std::tr1::shared_ptr<Allocator> > alloc_factory;
+      mutable std::tr1::shared_ptr<Allocator> cached_default_allocator;
 
-      UI* ui;
-      class Charset_Transcoder* transcoder;
+      std::tr1::shared_ptr<UI> ui;
+      std::tr1::shared_ptr<class Charset_Transcoder> transcoder;
       RandomNumberGenerator* rng;
-      std::vector<Allocator*> allocators;
-      std::vector<EntropySource*> entropy_sources;
-      std::vector<class Engine*> engines;
+      //std::tr1::shared_ptr<RandomNumberGenerator> rng;
+
+      std::vector<std::tr1::shared_ptr<Allocator> > allocators;
+      std::vector<std::tr1::shared_ptr<EntropySource> > entropy_sources;
+      std::vector<std::tr1::shared_ptr<class Engine> > engines;
    };
 
 /*************************************************
 * Global State                                   *
 *************************************************/
 Library_State& global_state();
+//void set_global_state(std::tr1::shared_ptr<Library_State>);
+//std::tr1::shared_ptr<Library_State> swap_global_state(std::tr1::shared_ptr<Library_State>);
 void set_global_state(Library_State*);
 Library_State* swap_global_state(Library_State*);
 
+
 }
 
 #endif
============================================================
--- include/look_pk.h	1f2ab76b42fca7ccef876265b1f0a8df5610f944
+++ include/look_pk.h	92c106b614a48a401d6a5613b3f38f77106a48c4
@@ -13,20 +13,20 @@ namespace Botan {
 /*************************************************
 * Get an PK algorithm object                     *
 *************************************************/
-PK_Encryptor* get_pk_encryptor(const PK_Encrypting_Key&, const std::string&);
-PK_Decryptor* get_pk_decryptor(const PK_Decrypting_Key&, const std::string&);
+std::auto_ptr<PK_Encryptor> get_pk_encryptor(const PK_Encrypting_Key&, const std::string&);
+std::auto_ptr<PK_Decryptor> get_pk_decryptor(const PK_Decrypting_Key&, const std::string&);
 
-PK_Signer*    get_pk_signer(const PK_Signing_Key&, const std::string&,
+std::auto_ptr<PK_Signer>    get_pk_signer(const PK_Signing_Key&, const std::string&,
                             Signature_Format = IEEE_1363);
 
-PK_Verifier*  get_pk_verifier(const PK_Verifying_with_MR_Key&,
+std::auto_ptr<PK_Verifier>  get_pk_verifier(const PK_Verifying_with_MR_Key&,
                               const std::string&,
                               Signature_Format = IEEE_1363);
-PK_Verifier*  get_pk_verifier(const PK_Verifying_wo_MR_Key&,
+std::auto_ptr<PK_Verifier>  get_pk_verifier(const PK_Verifying_wo_MR_Key&,
                               const std::string&,
                               Signature_Format = IEEE_1363);
 
-PK_Key_Agreement* get_pk_kas(const PK_Key_Agreement_Key&, const std::string&);
+std::auto_ptr<PK_Key_Agreement> get_pk_kas(const PK_Key_Agreement_Key&, const std::string&);
 
 }
 
============================================================
--- include/lookup.h	dd3c4a91f50bebfd4c710a828b007b8303b5536b
+++ include/lookup.h	6c345a7254733e1e2c026a0341007823ccaf32bc
@@ -17,38 +17,43 @@ namespace Botan {
 /*************************************************
 * Retrieve an object from the lookup table       *
 *************************************************/
-const BlockCipher*                  retrieve_block_cipher(const std::string&);
-const StreamCipher*                 retrieve_stream_cipher(const std::string&);
-const HashFunction*                 retrieve_hash(const std::string&);
-const MessageAuthenticationCode*    retrieve_mac(const std::string&);
-const S2K*                          retrieve_s2k(const std::string&);
-const BlockCipherModePaddingMethod* retrieve_bc_pad(const std::string&);
+// NOTE: these functions return internally stored objects, so we use shared_ptr here
+std::tr1::shared_ptr<BlockCipher const>                  retrieve_block_cipher(const std::string&);
+std::tr1::shared_ptr<StreamCipher const>                 retrieve_stream_cipher(const std::string&);
+std::tr1::shared_ptr<HashFunction const>                 retrieve_hash(const std::string&);
+std::tr1::shared_ptr<MessageAuthenticationCode const>    retrieve_mac(const std::string&);
+std::tr1::shared_ptr<S2K const>                          retrieve_s2k(const std::string&);
+std::tr1::shared_ptr<BlockCipherModePaddingMethod const> retrieve_bc_pad(const std::string&);
 
 /*************************************************
 * Get an algorithm object                        *
 *************************************************/
-BlockCipher*                        get_block_cipher(const std::string&);
-StreamCipher*                       get_stream_cipher(const std::string&);
-HashFunction*                       get_hash(const std::string&);
-MessageAuthenticationCode*          get_mac(const std::string&);
-S2K*                                get_s2k(const std::string&);
-const BlockCipherModePaddingMethod* get_bc_pad(const std::string&);
+// NOTE: these functions create and return new objects, letting the caller assume ownership of them
+std::auto_ptr<BlockCipher>                               get_block_cipher(const std::string&);
+std::auto_ptr<StreamCipher>                              get_stream_cipher(const std::string&);
+std::auto_ptr<HashFunction>                              get_hash(const std::string&);
+std::auto_ptr<MessageAuthenticationCode>                 get_mac(const std::string&);
+std::auto_ptr<S2K>                                       get_s2k(const std::string&);
+// NOTE: BlockCipherModePaddingMethod is not cloned
+std::tr1::shared_ptr<BlockCipherModePaddingMethod const> get_bc_pad(const std::string&);
 
 /*************************************************
 * Get an EMSA/EME/KDF/MGF function               *
 *************************************************/
-EME*  get_eme(const std::string&);
-EMSA* get_emsa(const std::string&);
-MGF*  get_mgf(const std::string&);
-KDF*  get_kdf(const std::string&);
+// NOTE: these functions create and return new objects, letting the caller assume ownership of them
+std::auto_ptr<EME>  get_eme(const std::string&);
+std::auto_ptr<EMSA> get_emsa(const std::string&);
+std::auto_ptr<MGF>  get_mgf(const std::string&);
+std::auto_ptr<KDF>  get_kdf(const std::string&);
 
 /*************************************************
 * Get a cipher object                            *
 *************************************************/
-Keyed_Filter* get_cipher(const std::string&, const SymmetricKey&,
+// NOTE: these functions return internally stored objects, so we use shared_ptr here
+std::tr1::shared_ptr<Keyed_Filter> get_cipher(const std::string&, const SymmetricKey&,
                          const InitializationVector&, Cipher_Dir);
-Keyed_Filter* get_cipher(const std::string&, const SymmetricKey&, Cipher_Dir);
-Keyed_Filter* get_cipher(const std::string&, Cipher_Dir);
+std::tr1::shared_ptr<Keyed_Filter> get_cipher(const std::string&, const SymmetricKey&, Cipher_Dir);
+std::tr1::shared_ptr<Keyed_Filter> get_cipher(const std::string&, Cipher_Dir);
 
 /*************************************************
 * Check to see if an algorithm exists            *
============================================================
--- include/mem_pool.h	5c7868d373529114f14223b4cb7533ffa0b7133e
+++ include/mem_pool.h	dd3a30876c9faca1296d06d25bf0a582590d9c08
@@ -66,7 +66,7 @@ class Pooling_Allocator : public Allocat
       std::vector<Memory_Block> blocks;
       std::vector<Memory_Block>::iterator last_used;
       std::vector<std::pair<void*, u32bit> > allocated;
-      Mutex* mutex;
+      std::tr1::shared_ptr<Mutex> mutex;
    };
 
 }
============================================================
--- include/modebase.h	b2233bf5cfbe0d16ec986291f086c5e07838b861
+++ include/modebase.h	c3deb9eabbf9ef04c291ac6b3c1460ba53dab983
@@ -7,6 +7,7 @@
 #define BOTAN_MODEBASE_H__
 
 #include <botan/basefilt.h>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -20,12 +21,12 @@ class BlockCipherMode : public Keyed_Fil
 
       BlockCipherMode(const std::string&, const std::string&,
                       u32bit, u32bit = 0, u32bit = 1);
-      virtual ~BlockCipherMode() { delete cipher; }
+      virtual ~BlockCipherMode() { }
    protected:
       void set_iv(const InitializationVector&);
       const u32bit BLOCK_SIZE, BUFFER_SIZE, IV_METHOD;
       const std::string mode_name;
-      BlockCipher* cipher;
+      std::tr1::shared_ptr<BlockCipher> cipher;
       SecureVector<byte> buffer, state;
       u32bit position;
    };
============================================================
--- include/modules.h	d5c0714b1d1a263bee2ecb352834c9d243a893ef
+++ include/modules.h	a0d5b85ee9524510723c55e73e9065e8078b8f54
@@ -9,6 +9,7 @@
 #include <botan/init.h>
 #include <string>
 #include <vector>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -18,15 +19,15 @@ class Modules
 class Modules
    {
    public:
-      virtual class Mutex_Factory* mutex_factory() const = 0;
-      virtual class Timer* timer() const = 0;
-      virtual class Charset_Transcoder* transcoder() const = 0;
+      virtual std::tr1::shared_ptr<class Mutex_Factory> mutex_factory() const = 0;
+      virtual std::tr1::shared_ptr<class Timer> timer() const = 0;
+      virtual std::tr1::shared_ptr<class Charset_Transcoder> transcoder() const = 0;
 
       virtual std::string default_allocator() const = 0;
 
-      virtual std::vector<class Allocator*> allocators() const = 0;
-      virtual std::vector<class EntropySource*> entropy_sources() const = 0;
-      virtual std::vector<class Engine*> engines() const = 0;
+      virtual std::vector<std::tr1::shared_ptr<class Allocator> > allocators() const = 0;
+      virtual std::vector<std::tr1::shared_ptr<class EntropySource> > entropy_sources() const = 0;
+      virtual std::vector<std::tr1::shared_ptr<class Engine> > engines() const = 0;
 
       virtual ~Modules() {}
    };
@@ -37,15 +38,15 @@ class Builtin_Modules : public Modules
 class Builtin_Modules : public Modules
    {
    public:
-      class Mutex_Factory* mutex_factory() const;
-      class Timer* timer() const;
-      class Charset_Transcoder* transcoder() const;
+      class std::tr1::shared_ptr<Mutex_Factory> mutex_factory() const;
+      class std::tr1::shared_ptr<Timer> timer() const;
+      class std::tr1::shared_ptr<Charset_Transcoder> transcoder() const;
 
       std::string default_allocator() const;
 
-      std::vector<class Allocator*> allocators() const;
-      std::vector<class EntropySource*> entropy_sources() const;
-      std::vector<class Engine*> engines() const;
+      std::vector<std::tr1::shared_ptr<class Allocator> > allocators() const;
+      std::vector<std::tr1::shared_ptr<class EntropySource> > entropy_sources() const;
+      std::vector<std::tr1::shared_ptr<class Engine> > engines() const;
 
       Builtin_Modules(const InitializerOptions&);
    private:
============================================================
--- include/mp_asm.h	43d835beafc05c9d0e39596ba54e73a53795e5b4
+++ include/mp_asm.h	693c2056d9f473aa10f20bae5d101ef37263f714
@@ -6,7 +6,7 @@
 #ifndef BOTAN_MP_ASM_H__
 #define BOTAN_MP_ASM_H__
 
-#include <botan/mp_types.h>
+#include <botan/math/mp_types.h>
 
 #if (BOTAN_MP_WORD_BITS == 8)
   typedef Botan::u16bit dword;
============================================================
--- include/mp_asmi.h	fb52f8210fae3cab3f224a25d9728222b2ce27f4
+++ include/mp_asmi.h	2ce78ddc78614b98cf3387def140d79cd91c6eb7
@@ -6,7 +6,7 @@
 #ifndef BOTAN_MP_ASM_INTERNAL_H__
 #define BOTAN_MP_ASM_INTERNAL_H__
 
-#include <botan/mp_asm.h>
+#include <botan/math/mp_asm.h>
 
 namespace Botan {
 
============================================================
--- include/mp_core.h	a31479cdef207a0cf98352de2a6813ddcdb909b2
+++ include/mp_core.h	db72ee72f31d2274c5e18ca58a1bd15c59fcbdb1
@@ -6,7 +6,7 @@
 #ifndef BOTAN_MP_CORE_H__
 #define BOTAN_MP_CORE_H__
 
-#include <botan/mp_types.h>
+#include <botan/math/mp_types.h>
 
 namespace Botan {
 
@@ -80,6 +80,11 @@ void bigint_mul(word[], u32bit, word[],
                 const word[], u32bit, u32bit,
                 const word[], u32bit, u32bit);
 
+/*void bigint_sec_mul(word z[], const word x[], u32bit x_size,
+                                 const word y[], u32bit y_size,
+                                 u32bit max_words
+                                 );*/
+
 void bigint_sqr(word[], u32bit, word[],
                 const word[], u32bit, u32bit);
 
============================================================
--- include/mp_types.h	064801a43de15a3fb4af0a26b9c4bd14fcd9b8f5
+++ include/mp_types.h	fcba1ca3c7294755de6817e3669f9bf6788e7087
@@ -22,8 +22,8 @@ namespace Botan {
   #error BOTAN_MP_WORD_BITS must be 8, 16, 32, or 64
 #endif
 
-const word MP_WORD_MASK = ~static_cast<word>(0);
-const word MP_WORD_TOP_BIT = static_cast<word>(1) << (8*sizeof(word) - 1);
+const word MP_WORD_MASK = ~static_cast<word>(0); 
+const word MP_WORD_TOP_BIT = static_cast<word>(1) << (8*sizeof(word) - 1); 
 const word MP_WORD_MAX = MP_WORD_MASK;
 
 }
============================================================
--- include/mutex.h	566d2d816963e3e255e0cd7ef9e58f4619cad8f8
+++ include/mutex.h	8eef961983ec3d176af85c7eff413bccae0b16b2
@@ -7,7 +7,10 @@
 #define BOTAN_MUTEX_H__
 
 #include <botan/exceptn.h>
+#include <botan/freestore.h>
 
+#include <botan/tr1_mem_includer.h>
+
 namespace Botan {
 
 /*************************************************
@@ -27,7 +30,7 @@ class Mutex_Factory
 class Mutex_Factory
    {
    public:
-      virtual Mutex* make() = 0;
+      virtual std::auto_ptr<Mutex> make() = 0;
       virtual ~Mutex_Factory() {}
    };
 
@@ -37,7 +40,7 @@ class Default_Mutex_Factory : public Mut
 class Default_Mutex_Factory : public Mutex_Factory
    {
    public:
-      Mutex* make();
+     std::auto_ptr<Mutex> make();
    };
 
 /*************************************************
@@ -46,10 +49,10 @@ class Mutex_Holder
 class Mutex_Holder
    {
    public:
-      Mutex_Holder(Mutex*);
+      Mutex_Holder(SharedPtrConverter<Mutex>);
       ~Mutex_Holder();
    private:
-      Mutex* mux;
+      std::tr1::shared_ptr<Mutex> mux;
    };
 
 /*************************************************
============================================================
--- include/oids.h	ca7fe98e914a8def168afa1d9e29ef594245f031
+++ include/oids.h	0b1192539d57a116d1ced8c6381f6f34da943c70
@@ -27,6 +27,7 @@ OID lookup(const std::string&);
 *************************************************/
 std::string lookup(const OID&);
 OID lookup(const std::string&);
+OID lookup_bsi(const std::string&);
 bool name_of(const OID&, const std::string&);
 
 }
============================================================
--- include/out_buf.h	cfe4dc7beb6cb4816788ad929eef3be9f22ff420
+++ include/out_buf.h	62e689b04f6a475d6e5e025e88a67c23ad873435
@@ -7,6 +7,7 @@
 #define BOTAN_OUTPUT_BUFFER_H__
 
 #include <botan/types.h>
+#include <botan/secqueue.h>
 #include <deque>
 
 namespace Botan {
@@ -21,7 +22,7 @@ class Output_Buffers
       u32bit peek(byte[], u32bit, u32bit, u32bit) const;
       u32bit remaining(u32bit) const;
 
-      void add(class SecureQueue*);
+      void add(SharedPtrConverter<class SecureQueue>);
       void retire();
 
       u32bit message_count() const;
@@ -29,9 +30,9 @@ class Output_Buffers
       Output_Buffers();
       ~Output_Buffers();
    private:
-      class SecureQueue* get(u32bit) const;
+	  std::tr1::shared_ptr<SecureQueue> get(u32bit) const;
 
-      std::deque<SecureQueue*> buffers;
+      std::deque<std::tr1::shared_ptr<SecureQueue> > buffers;
       u32bit offset;
    };
 
============================================================
--- include/par_hash.h	4add8710423444c47404c57c8b234fc7dc6fb22d
+++ include/par_hash.h	773ada35d8115d1c20778de70da18e2d9ff338e1
@@ -19,13 +19,13 @@ class Parallel : public HashFunction
    public:
       void clear() throw();
       std::string name() const;
-      HashFunction* clone() const;
+      AutoHashFunctionPtr clone() const;
       Parallel(const std::vector<std::string>&);
       ~Parallel();
    private:
       void add_data(const byte[], u32bit);
       void final_result(byte[]);
-      std::vector<HashFunction*> hashes;
+      std::vector<SharedHashFunctionPtr> hashes;
    };
 
 }
============================================================
--- include/pbe.h	6f41f1c709485124f6dda4dc2ac05d9218577d47
+++ include/pbe.h	dbb1c47581e5a580afd5bf6dde504976cf76dbfe
@@ -21,15 +21,15 @@ class PBE : public Filter
       virtual void set_key(const std::string&) = 0;
       virtual void new_params() = 0;
       virtual MemoryVector<byte> encode_params() const = 0;
-      virtual void decode_params(DataSource&) = 0;
+      virtual void decode_params(SharedPtrConverter<DataSource>) = 0;
       virtual OID get_oid() const = 0;
    };
 
 /*************************************************
 * Get a PBE object                               *
 *************************************************/
-PBE* get_pbe(const std::string&);
-PBE* get_pbe(const OID&, DataSource&);
+std::tr1::shared_ptr<PBE> get_pbe(const std::string&);
+std::tr1::shared_ptr<PBE> get_pbe(const OID&, SharedPtrConverter<DataSource>);
 
 }
 
============================================================
--- include/pbe_pkcs.h	dedf1488ad73ea2bd8bcfeb286f01e01f0dfb4c7
+++ include/pbe_pkcs.h	efa66e6cf31f004566cfdc8bdb7cce200537fc88
@@ -25,7 +25,7 @@ class PBE_PKCS5v15 : public PBE
       void set_key(const std::string&);
       void new_params();
       MemoryVector<byte> encode_params() const;
-      void decode_params(DataSource&);
+      void decode_params(SharedPtrConverter<DataSource>);
       OID get_oid() const;
       void flush_pipe(bool);
       const Cipher_Dir direction;
@@ -44,13 +44,13 @@ class PBE_PKCS5v20 : public PBE
       void write(const byte[], u32bit);
       void start_msg();
       void end_msg();
-      PBE_PKCS5v20(DataSource&);
+      PBE_PKCS5v20(SharedPtrConverter<DataSource>);
       PBE_PKCS5v20(const std::string&, const std::string&);
    private:
       void set_key(const std::string&);
       void new_params();
       MemoryVector<byte> encode_params() const;
-      void decode_params(DataSource&);
+      void decode_params(SharedPtrConverter<DataSource>);
       OID get_oid() const;
       void flush_pipe(bool);
       bool known_cipher(const std::string&) const;
============================================================
--- include/pem.h	8f1ebb1cad4f86b291912481e8fdb5277f9ef1e0
+++ include/pem.h	d06972fca7b38bf93799badb074d183e17701a27
@@ -7,6 +7,7 @@
 #define BOTAN_PEM_H__
 
 #include <botan/data_src.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
@@ -18,9 +19,9 @@ std::string encode(const MemoryRegion<by
 std::string encode(const byte[], u32bit, const std::string&);
 std::string encode(const MemoryRegion<byte>&, const std::string&);
 
-SecureVector<byte> decode(DataSource&, std::string&);
-SecureVector<byte> decode_check_label(DataSource&, const std::string&);
-bool matches(DataSource&, const std::string& = "");
+SecureVector<byte> decode(SharedPtrConverter<DataSource>, std::string&);
+SecureVector<byte> decode_check_label(SharedPtrConverter<DataSource>, const std::string&);
+bool matches(SharedPtrConverter<DataSource>, const std::string& = "");
 
 }
 
============================================================
--- include/pipe.h	d7528617243b81a9c2a0eb4b91f63c7b07db15aa
+++ include/pipe.h	575316d4d1a3ec9eefeacd528507488defa76060
@@ -18,6 +18,9 @@ class Pipe : public DataSource
 class Pipe : public DataSource
    {
    public:
+      typedef Filter::SharedFilterPtrConverter SharedFilterPtrConverter;
+      typedef Filter::SharedFilterPtr SharedFilterPtr;
+
       static const u32bit LAST_MESSAGE, DEFAULT_MESSAGE;
 
       void write(const byte[], u32bit);
@@ -52,26 +55,42 @@ class Pipe : public DataSource
       void start_msg();
       void end_msg();
 
-      void prepend(Filter*);
-      void append(Filter*);
+      void prepend(SharedFilterPtrConverter const&);
+      void append(SharedFilterPtrConverter const&);
       void pop();
       void reset();
 
-      Pipe(Filter* = 0, Filter* = 0, Filter* = 0, Filter* = 0);
-      Pipe(Filter*[], u32bit);
+      Pipe(SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter(),
+           SharedFilterPtrConverter const& = SharedFilterPtrConverter());
+      // Assumes that [begin, end) is a range of objects o for which
+      // SharedFilterPtrConverter(o) is valid.
+      // ConstIter has to be a bidirectional iterator type.
+      template<typename ConstIter>
+      Pipe(ConstIter const& begin, ConstIter const& end) 
+        : pipe(),
+          outputs(),
+          default_read(0),
+          inside_msg(false) {
+        this->init();
+        for(; begin != end; ++begin) {
+          this->append(*begin);
+        }
+      }
       ~Pipe();
    private:
       Pipe(const Pipe&) : DataSource() {}
       Pipe& operator=(const Pipe&) { return (*this); }
       void init();
-      void destruct(Filter*);
-      void find_endpoints(Filter*);
-      void clear_endpoints(Filter*);
+      void destruct(Filter::SharedFilterPtr &);
+      void find_endpoints(Filter::SharedFilterPtr const&);
+      void clear_endpoints(Filter::SharedFilterPtr const&);
 
       u32bit get_message_no(const std::string&, u32bit) const;
 
-      Filter* pipe;
-      class Output_Buffers* outputs;
+      SharedFilterPtr pipe;
+      std::tr1::shared_ptr<class Output_Buffers> outputs;
       u32bit default_read;
       bool inside_msg;
    };
============================================================
--- include/pk_algs.h	0cdb3f27d4178871d62f3ffd6eb4cf749b449c8b
+++ include/pk_algs.h	34700f51f1a5af6c629e6d7fde12725502ec3788
@@ -14,8 +14,8 @@ namespace Botan {
 /*************************************************
 * Get an PK key object                           *
 *************************************************/
-Public_Key*   get_public_key(const std::string&);
-Private_Key* get_private_key(const std::string&);
+std::auto_ptr<Public_Key> get_public_key(const std::string&);
+std::auto_ptr<Private_Key> get_private_key(const std::string&);
 
 }
 
============================================================
--- include/pk_core.h	b6bc6c56bc5f235e84e7f797ae1b38677cc5cda5
+++ include/pk_core.h	b7d76148b1bc6c1362f62c95f95478f01f695be4
@@ -6,10 +6,14 @@
 #ifndef BOTAN_PK_CORE_H__
 #define BOTAN_PK_CORE_H__
 
-#include <botan/bigint.h>
+#include <botan/tr1_mem_includer.h>
+
 #include <botan/dl_group.h>
 #include <botan/blinding.h>
 #include <botan/pk_ops.h>
+#include <botan/math/bigint.h>
+#include <botan/ec_dompar.h>
+#include <botan/ecdsa.h>
 
 namespace Botan {
 
@@ -19,20 +23,20 @@ class IF_Core
 class IF_Core
    {
    public:
-      BigInt public_op(const BigInt&) const;
-      BigInt private_op(const BigInt&) const;
+	  Botan::math::BigInt public_op(const Botan::math::BigInt&) const;
+      Botan::math::BigInt private_op(const Botan::math::BigInt&) const;
 
       IF_Core& operator=(const IF_Core&);
 
-      IF_Core() { op = 0; }
+      IF_Core() : op() { }
       IF_Core(const IF_Core&);
-      IF_Core(const BigInt&, const BigInt&,
-              const BigInt& = 0, const BigInt& = 0, const BigInt& = 0,
-              const BigInt& = 0, const BigInt& = 0, const BigInt& = 0);
-      ~IF_Core() { delete op; }
+      IF_Core(const Botan::math::BigInt&, const Botan::math::BigInt&,
+              const Botan::math::BigInt& = 0, const Botan::math::BigInt& = 0, const Botan::math::BigInt& = 0,
+              const Botan::math::BigInt& = 0, const Botan::math::BigInt& = 0, const Botan::math::BigInt& = 0);
+      ~IF_Core() { } 
    private:
-      IF_Operation* op;
-      Blinder blinder;
+     std::tr1::shared_ptr<IF_Operation> op;
+     Blinder blinder;
    };
 
 /*************************************************
@@ -41,17 +45,17 @@ class DSA_Core
 class DSA_Core
    {
    public:
-      SecureVector<byte> sign(const byte[], u32bit, const BigInt&) const;
+      SecureVector<byte> sign(const byte[], u32bit, const Botan::math::BigInt&) const;
       bool verify(const byte[], u32bit, const byte[], u32bit) const;
 
       DSA_Core& operator=(const DSA_Core&);
 
-      DSA_Core() { op = 0; }
+      DSA_Core() : op() { }
       DSA_Core(const DSA_Core&);
-      DSA_Core(const DL_Group&, const BigInt&, const BigInt& = 0);
-      ~DSA_Core() { delete op; }
+      DSA_Core(const DL_Group&, const Botan::math::BigInt&, const Botan::math::BigInt& = 0);
+      ~DSA_Core() {  }
    private:
-      DSA_Operation* op;
+     std::tr1::shared_ptr<DSA_Operation> op;
    };
 
 /*************************************************
@@ -60,17 +64,17 @@ class NR_Core
 class NR_Core
    {
    public:
-      SecureVector<byte> sign(const byte[], u32bit, const BigInt&) const;
+      SecureVector<byte> sign(const byte[], u32bit, const Botan::math::BigInt&) const;
       SecureVector<byte> verify(const byte[], u32bit) const;
 
       NR_Core& operator=(const NR_Core&);
 
-      NR_Core() { op = 0; }
+      NR_Core() : op() { }
       NR_Core(const NR_Core&);
-      NR_Core(const DL_Group&, const BigInt&, const BigInt& = 0);
-      ~NR_Core() { delete op; }
+      NR_Core(const DL_Group&, const Botan::math::BigInt&, const Botan::math::BigInt& = 0);
+      ~NR_Core() { }
    private:
-      NR_Operation* op;
+     std::tr1::shared_ptr<NR_Operation> op;
    };
 
 /*************************************************
@@ -79,17 +83,17 @@ class ELG_Core
 class ELG_Core
    {
    public:
-      SecureVector<byte> encrypt(const byte[], u32bit, const BigInt&) const;
+      SecureVector<byte> encrypt(const byte[], u32bit, const Botan::math::BigInt&) const;
       SecureVector<byte> decrypt(const byte[], u32bit) const;
 
       ELG_Core& operator=(const ELG_Core&);
 
-      ELG_Core() { op = 0; }
+      ELG_Core() : op() { }
       ELG_Core(const ELG_Core&);
-      ELG_Core(const DL_Group&, const BigInt&, const BigInt& = 0);
-      ~ELG_Core() { delete op; }
+      ELG_Core(const DL_Group&, const Botan::math::BigInt&, const Botan::math::BigInt& = 0);
+      ~ELG_Core() {  }
    private:
-      ELG_Operation* op;
+     std::tr1::shared_ptr<ELG_Operation> op;
       Blinder blinder;
       u32bit p_bytes;
    };
@@ -100,19 +104,55 @@ class DH_Core
 class DH_Core
    {
    public:
-      BigInt agree(const BigInt&) const;
+      Botan::math::BigInt agree(const Botan::math::BigInt&) const;
 
       DH_Core& operator=(const DH_Core&);
 
-      DH_Core() { op = 0; }
+      DH_Core() : op() { }
       DH_Core(const DH_Core&);
-      DH_Core(const DL_Group&, const BigInt&);
-      ~DH_Core() { delete op; }
+      DH_Core(const DL_Group&, const Botan::math::BigInt&);
+      ~DH_Core() { } 
    private:
-      DH_Operation* op;
-      Blinder blinder;
+     std::tr1::shared_ptr<DH_Operation> op;
+     Blinder blinder;
    };
 
+class ECDSA_Core
+{
+    public:
+        
+        bool const verify(const byte signature[], u32bit sig_len, const byte message[], u32bit mess_len) const;
+           
+        SecureVector<byte> const sign(const byte message[], u32bit mess_len) const;
+
+        ECDSA_Core& operator=(const ECDSA_Core&);
+
+        ECDSA_Core() : op() { }
+        ECDSA_Core(const ECDSA_Core&);
+		ECDSA_Core(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key);
+        ~ECDSA_Core() { } 
+    private:
+        std::tr1::shared_ptr<ECDSA_Operation> op;
+        
+        
+};
+
+class ECKAEG_Core
+{
+    public:
+        SecureVector<byte> agree(const Botan::math::ec::PointGFp&) const;
+
+        ECKAEG_Core& operator=(const ECKAEG_Core&);
+
+        ECKAEG_Core() : op() { }
+        ECKAEG_Core(const ECKAEG_Core&);
+        ECKAEG_Core(EC_Domain_Params const& dom_pars, Botan::math::BigInt const& priv_key, Botan::math::ec::PointGFp const& pub_key);
+        ~ECKAEG_Core() { } 
+    private:
+        std::tr1::shared_ptr<ECKAEG_Operation> op;
+        Blinder blinder;
+};
+
 }
 
 #endif
============================================================
--- include/pk_filts.h	717d97bf42adf752cac13930ae6cbe484da5a60a
+++ include/pk_filts.h	d6bd7fac866e0ac5c4d25069b7f617f89eb0c62b
@@ -19,10 +19,10 @@ class PK_Encryptor_Filter : public Filte
    public:
       void write(const byte[], u32bit);
       void end_msg();
-      PK_Encryptor_Filter(PK_Encryptor* c) : cipher(c) {}
-      ~PK_Encryptor_Filter() { delete cipher; }
+      PK_Encryptor_Filter(SharedPtrConverter<PK_Encryptor> const& c) : cipher(c.get_shared()) {}
+      ~PK_Encryptor_Filter() { }
    private:
-      PK_Encryptor* cipher;
+      std::tr1::shared_ptr<PK_Encryptor> cipher;
       SecureVector<byte> buffer;
    };
 
@@ -34,10 +34,10 @@ class PK_Decryptor_Filter : public Filte
    public:
       void write(const byte[], u32bit);
       void end_msg();
-      PK_Decryptor_Filter(PK_Decryptor* c) : cipher(c) {}
-      ~PK_Decryptor_Filter() { delete cipher; }
+      PK_Decryptor_Filter(SharedPtrConverter<PK_Decryptor> const& c) : cipher(c.get_shared()) {}
+      ~PK_Decryptor_Filter() { }
    private:
-      PK_Decryptor* cipher;
+     std::tr1::shared_ptr<PK_Decryptor> cipher;
       SecureVector<byte> buffer;
    };
 
@@ -49,10 +49,10 @@ class PK_Signer_Filter : public Filter
    public:
       void write(const byte[], u32bit);
       void end_msg();
-      PK_Signer_Filter(PK_Signer* s) : signer(s) {}
-      ~PK_Signer_Filter() { delete signer; }
+      PK_Signer_Filter(SharedPtrConverter<PK_Signer> const& s) : signer(s.get_shared()) {}
+      ~PK_Signer_Filter() { }
    private:
-      PK_Signer* signer;
+     std::tr1::shared_ptr<PK_Signer> signer;
    };
 
 /*************************************************
@@ -67,12 +67,12 @@ class PK_Verifier_Filter : public Filter
       void set_signature(const byte[], u32bit);
       void set_signature(const MemoryRegion<byte>&);
 
-      PK_Verifier_Filter(PK_Verifier* v) : verifier(v) {}
-      PK_Verifier_Filter(PK_Verifier*, const byte[], u32bit);
-      PK_Verifier_Filter(PK_Verifier*, const MemoryRegion<byte>&);
-      ~PK_Verifier_Filter() { delete verifier; }
+      PK_Verifier_Filter(SharedPtrConverter<PK_Verifier> const& v) : verifier(v.get_shared()) {}
+      PK_Verifier_Filter(SharedPtrConverter<PK_Verifier> const&, const byte[], u32bit);
+      PK_Verifier_Filter(SharedPtrConverter<PK_Verifier> const&, const MemoryRegion<byte>&);
+      ~PK_Verifier_Filter() {  }
    private:
-      PK_Verifier* verifier;
+      std::tr1::shared_ptr<PK_Verifier> verifier;
       SecureVector<byte> signature;
    };
 
============================================================
--- include/pk_keys.h	c5aee8b20fb5f7fbea75385e030e575c596802d6
+++ include/pk_keys.h	59c61dafb10d355ec5bc4a4c02d53bee13081796
@@ -12,6 +12,19 @@ namespace Botan {
 namespace Botan {
 
 /*************************************************
+* Forward declarations                           *
+*************************************************/
+
+class X509_Encoder;    // defined in x509_key.h
+class X509_Decoder;    // defined in x509_key.h
+class EAC1_1_CVC_Encoder; // defined in cvc_key.h
+class EAC1_1_CVC_Decoder; // defined in cvc_key.h
+
+class PKCS8_Encoder;   // defined in pkcs8.h
+class PKCS8_Decoder;   // defined in pkcs8.h
+
+
+/*************************************************
 * Public Key Base Class                          *
 *************************************************/
 class Public_Key
@@ -25,8 +38,8 @@ class Public_Key
       virtual u32bit message_part_size() const { return 0; }
       virtual u32bit max_input_bits() const = 0;
 
-      virtual class X509_Encoder* x509_encoder() const { return 0; }
-      virtual class X509_Decoder* x509_decoder() { return 0; }
+      virtual std::auto_ptr<X509_Encoder> x509_encoder() const;
+      virtual std::auto_ptr<X509_Decoder> x509_decoder();
 
       virtual ~Public_Key() {}
    protected:
@@ -39,8 +52,8 @@ class Private_Key : public virtual Publi
 class Private_Key : public virtual Public_Key
    {
    public:
-      virtual class PKCS8_Encoder* pkcs8_encoder() const { return 0; }
-      virtual class PKCS8_Decoder* pkcs8_decoder() { return 0; }
+     virtual std::auto_ptr<PKCS8_Encoder> pkcs8_encoder() const;
+      virtual std::auto_ptr<PKCS8_Decoder> pkcs8_decoder();
    protected:
       void load_check() const;
       void gen_check() const;
@@ -103,8 +116,7 @@ class PK_Key_Agreement_Key : public virt
 class PK_Key_Agreement_Key : public virtual Private_Key
    {
    public:
-      virtual SecureVector<byte> derive_key(const byte[], u32bit) const = 0;
-      virtual MemoryVector<byte> public_value() const = 0;
+      virtual SecureVector<byte> derive_key(Public_Key const&) const = 0;
       virtual ~PK_Key_Agreement_Key() {}
    };
 
============================================================
--- include/pk_ops.h	4c7b121d9c89e60bf7a836875b49715c9633da1d
+++ include/pk_ops.h	6103c639d87aefb0c5f31c933310c9693ff51d73
@@ -6,8 +6,11 @@
 #ifndef BOTAN_PK_OPS_H__
 #define BOTAN_PK_OPS_H__
 
-#include <botan/bigint.h>
+#include <botan/tr1_mem_includer.h>
+#include <botan/math/bigint.h>
 #include <botan/dl_group.h>
+#include <botan/math/ec/point_gfp.h>
+#include <botan/ecdsa.h>
 
 namespace Botan {
 
@@ -17,9 +20,9 @@ class IF_Operation
 class IF_Operation
    {
    public:
-      virtual BigInt public_op(const BigInt&) const = 0;
-      virtual BigInt private_op(const BigInt&) const = 0;
-      virtual IF_Operation* clone() const = 0;
+	  virtual Botan::math::BigInt public_op(const Botan::math::BigInt&) const = 0;
+      virtual Botan::math::BigInt private_op(const Botan::math::BigInt&) const = 0;
+      virtual std::auto_ptr<IF_Operation> clone() const = 0;
       virtual ~IF_Operation() {}
    };
 
@@ -32,8 +35,8 @@ class DSA_Operation
       virtual bool verify(const byte[], u32bit,
                           const byte[], u32bit) const = 0;
       virtual SecureVector<byte> sign(const byte[], u32bit,
-                                      const BigInt&) const = 0;
-      virtual DSA_Operation* clone() const = 0;
+                                      const Botan::math::BigInt&) const = 0;
+      virtual std::auto_ptr<DSA_Operation> clone() const = 0;
       virtual ~DSA_Operation() {}
    };
 
@@ -45,8 +48,8 @@ class NR_Operation
    public:
       virtual SecureVector<byte> verify(const byte[], u32bit) const = 0;
       virtual SecureVector<byte> sign(const byte[], u32bit,
-                                      const BigInt&) const = 0;
-      virtual NR_Operation* clone() const = 0;
+                                      const Botan::math::BigInt&) const = 0;
+      virtual std::auto_ptr<NR_Operation> clone() const = 0;
       virtual ~NR_Operation() {}
    };
 
@@ -57,9 +60,9 @@ class ELG_Operation
    {
    public:
       virtual SecureVector<byte> encrypt(const byte[], u32bit,
-                                         const BigInt&) const = 0;
-      virtual BigInt decrypt(const BigInt&, const BigInt&) const = 0;
-      virtual ELG_Operation* clone() const = 0;
+                                         const Botan::math::BigInt&) const = 0;
+      virtual Botan::math::BigInt decrypt(const Botan::math::BigInt&, const Botan::math::BigInt&) const = 0;
+      virtual std::auto_ptr<ELG_Operation> clone() const = 0;
       virtual ~ELG_Operation() {}
    };
 
@@ -69,11 +72,35 @@ class DH_Operation
 class DH_Operation
    {
    public:
-      virtual BigInt agree(const BigInt&) const = 0;
-      virtual DH_Operation* clone() const = 0;
+      virtual Botan::math::BigInt agree(const Botan::math::BigInt&) const = 0;
+      virtual std::auto_ptr<DH_Operation> clone() const = 0;
       virtual ~DH_Operation() {}
    };
 
+/*************************************************
+* ECDSA Operation                               *
+*************************************************/
+class ECDSA_Operation
+   {
+   public:
+      virtual bool const verify(const byte signature[], u32bit sig_len, const byte message[], Botan::u32bit mess_len) const = 0;
+          
+      virtual SecureVector<byte> const sign( const byte message[], u32bit mess_len) const = 0;
+      virtual std::auto_ptr<ECDSA_Operation> clone() const = 0;
+      virtual ~ECDSA_Operation() {}
+   };
+
+/*************************************************
+* ECKAEG Operation                               *
+*************************************************/
+class ECKAEG_Operation
+   {
+   public:
+	  virtual SecureVector<byte> agree(const Botan::math::ec::PointGFp&) const = 0;
+      virtual std::auto_ptr<ECKAEG_Operation> clone() const = 0;
+      virtual ~ECKAEG_Operation() {}
+   };
+
 }
 
 #endif
============================================================
--- include/pkcs10.h	2963efb4b97a36cdcd1bb51941ab613f9058ceaa
+++ include/pkcs10.h	29563f84efc224cdd95bfa8deaa676b242bef982
@@ -10,7 +10,6 @@
 #include <botan/pkcs8.h>
 #include <botan/datastor.h>
 #include <vector>
-
 namespace Botan {
 
 /*************************************************
@@ -19,7 +18,7 @@ class PKCS10_Request : public X509_Objec
 class PKCS10_Request : public X509_Object
    {
    public:
-      Public_Key* subject_public_key() const;
+     std::auto_ptr<Public_Key> subject_public_key() const;
 
       MemoryVector<byte> raw_public_key() const;
       X509_DN subject_dn() const;
@@ -32,7 +31,7 @@ class PKCS10_Request : public X509_Objec
 
       std::string challenge_password() const;
 
-      PKCS10_Request(DataSource&);
+      PKCS10_Request(SharedPtrConverter<DataSource>);
       PKCS10_Request(const std::string&);
    private:
       void force_decode();
============================================================
--- include/pkcs5.h	d383915babdee2ef270bba89440302a6abc522ec
+++ include/pkcs5.h	2333497cae8b1103974428a2419cb8bf9ec74dfc
@@ -17,7 +17,9 @@ class PKCS5_PBKDF1 : public S2K
    {
    public:
       std::string name() const;
-      S2K* clone() const { return new PKCS5_PBKDF1(hash_name); }
+      std::auto_ptr<S2K> clone() const { 
+    	  return std::auto_ptr<S2K>(new PKCS5_PBKDF1(hash_name)); 
+      }
       PKCS5_PBKDF1(const std::string&);
    private:
       OctetString derive(u32bit, const std::string&,
@@ -32,7 +34,9 @@ class PKCS5_PBKDF2 : public S2K
    {
    public:
       std::string name() const;
-      S2K* clone() const { return new PKCS5_PBKDF2(hash_name); }
+      std::auto_ptr<S2K> clone() const { 
+    	  return std::auto_ptr<S2K>(new PKCS5_PBKDF2(hash_name)); 
+      }
       PKCS5_PBKDF2(const std::string&);
    private:
       OctetString derive(u32bit, const std::string&,
============================================================
--- include/pkcs8.h	71d4caac3daf75e32dc5c1c44007c2a49ea12dcf
+++ include/pkcs8.h	29c49743b4cd70009025166972d7641521fb8bcc
@@ -55,13 +55,13 @@ std::string PEM_encode(const Private_Key
 std::string PEM_encode(const Private_Key&, const std::string&,
                        const std::string& = "");
 
-Private_Key* load_key(DataSource&, const User_Interface&);
-Private_Key* load_key(DataSource&, const std::string& = "");
+std::auto_ptr<Private_Key> load_key(std::tr1::shared_ptr<DataSource>, const User_Interface&);
+std::auto_ptr<Private_Key> load_key(std::tr1::shared_ptr<DataSource>, const std::string& = "");
 
-Private_Key* load_key(const std::string&, const User_Interface&);
-Private_Key* load_key(const std::string&, const std::string& = "");
+std::auto_ptr<Private_Key> load_key(const std::string&, const User_Interface&);
+std::auto_ptr<Private_Key> load_key(const std::string&, const std::string& = "");
 
-Private_Key* copy_key(const Private_Key&);
+std::auto_ptr<Private_Key> copy_key(const Private_Key&);
 
 }
 
============================================================
--- include/pow_mod.h	7ebb967845c2f1b069ca3d0b5c21c5349f2d55e7
+++ include/pow_mod.h	8c74c6027e255f01bfca0414d1157dcdf0913732
@@ -6,7 +6,7 @@
 #ifndef BOTAN_POWER_MOD_H__
 #define BOTAN_POWER_MOD_H__
 
-#include <botan/bigint.h>
+#include <botan/math/bigint.h>
 
 namespace Botan {
 
@@ -16,10 +16,10 @@ class Modular_Exponentiator
 class Modular_Exponentiator
    {
    public:
-      virtual void set_base(const BigInt&) = 0;
-      virtual void set_exponent(const BigInt&) = 0;
-      virtual BigInt execute() const = 0;
-      virtual Modular_Exponentiator* copy() const = 0;
+	   virtual void set_base(const Botan::math::BigInt&) = 0;
+      virtual void set_exponent(const Botan::math::BigInt&) = 0;
+      virtual Botan::math::BigInt execute() const = 0;
+      virtual std::auto_ptr<Modular_Exponentiator> copy() const = 0; 
       virtual ~Modular_Exponentiator() {}
    };
 
@@ -42,19 +42,19 @@ class Power_Mod
          EXP_IS_LARGE    = 0x0400
       };
 
-      void set_modulus(const BigInt&, Usage_Hints = NO_HINTS) const;
-      void set_base(const BigInt&) const;
-      void set_exponent(const BigInt&) const;
+      void set_modulus(const Botan::math::BigInt&, Usage_Hints = NO_HINTS) const;
+      void set_base(const Botan::math::BigInt&) const;
+      void set_exponent(const Botan::math::BigInt&) const;
 
-      BigInt execute() const;
+      Botan::math::BigInt execute() const;
 
       Power_Mod& operator=(const Power_Mod&);
 
-      Power_Mod(const BigInt& = 0, Usage_Hints = NO_HINTS);
+      Power_Mod(const Botan::math::BigInt& = 0, Usage_Hints = NO_HINTS);
       Power_Mod(const Power_Mod&);
       ~Power_Mod();
    private:
-      mutable Modular_Exponentiator* core;
+      mutable std::auto_ptr<Modular_Exponentiator> core;
       Usage_Hints hints;
    };
 
@@ -64,11 +64,11 @@ class Fixed_Exponent_Power_Mod : public 
 class Fixed_Exponent_Power_Mod : public Power_Mod
    {
    public:
-      BigInt operator()(const BigInt& b) const
+      Botan::math::BigInt operator()(const Botan::math::BigInt& b) const
          { set_base(b); return execute(); }
 
       Fixed_Exponent_Power_Mod() {}
-      Fixed_Exponent_Power_Mod(const BigInt&, const BigInt&,
+      Fixed_Exponent_Power_Mod(const Botan::math::BigInt&, const Botan::math::BigInt&,
                                Usage_Hints = NO_HINTS);
    };
 
@@ -78,11 +78,11 @@ class Fixed_Base_Power_Mod : public Powe
 class Fixed_Base_Power_Mod : public Power_Mod
    {
    public:
-      BigInt operator()(const BigInt& e) const
+      Botan::math::BigInt operator()(const Botan::math::BigInt& e) const
          { set_exponent(e); return execute(); }
 
       Fixed_Base_Power_Mod() {}
-      Fixed_Base_Power_Mod(const BigInt&, const BigInt&,
+      Fixed_Base_Power_Mod(const Botan::math::BigInt&, const Botan::math::BigInt&,
                            Usage_Hints = NO_HINTS);
    };
 
============================================================
--- include/pubkey.h	b281c65bae28486d8ef43e7815e55f1d21553b6f
+++ include/pubkey.h	686d7bea981edb78689363459e0b35239216d750
@@ -57,11 +57,11 @@ class PK_Signer
       void set_output_format(Signature_Format);
 
       PK_Signer(const PK_Signing_Key&, const std::string&);
-      ~PK_Signer() { delete emsa; }
+      ~PK_Signer() { }
    private:
       const PK_Signing_Key& key;
       Signature_Format sig_format;
-      EMSA* emsa;
+      std::tr1::shared_ptr<EMSA> emsa;
    };
 
 /*************************************************
@@ -92,7 +92,7 @@ class PK_Verifier
       virtual u32bit key_message_part_size() const = 0;
 
       Signature_Format sig_format;
-      EMSA* emsa;
+      std::tr1::shared_ptr<EMSA> emsa;
    };
 
 /*************************************************
@@ -101,11 +101,10 @@ class PK_Key_Agreement
 class PK_Key_Agreement
    {
    public:
-      SymmetricKey derive_key(u32bit, const byte[], u32bit,
+        SymmetricKey derive_key(u32bit, const Public_Key&,
                               const std::string& = "") const;
-      SymmetricKey derive_key(u32bit, const byte[], u32bit,
+      SymmetricKey derive_key(u32bit, const Public_Key&,
                                       const byte[], u32bit) const;
-
       PK_Key_Agreement(const PK_Key_Agreement_Key&, const std::string&);
    private:
       const PK_Key_Agreement_Key& key;
@@ -120,11 +119,11 @@ class PK_Encryptor_MR_with_EME : public 
    public:
       u32bit maximum_input_size() const;
       PK_Encryptor_MR_with_EME(const PK_Encrypting_Key&, const std::string&);
-      ~PK_Encryptor_MR_with_EME() { delete encoder; }
+      ~PK_Encryptor_MR_with_EME() {  }
    private:
       SecureVector<byte> enc(const byte[], u32bit) const;
       const PK_Encrypting_Key& key;
-      const EME* encoder;
+      std::tr1::shared_ptr<EME const> encoder;
    };
 
 /*************************************************
@@ -134,11 +133,11 @@ class PK_Decryptor_MR_with_EME : public 
    {
    public:
       PK_Decryptor_MR_with_EME(const PK_Decrypting_Key&, const std::string&);
-      ~PK_Decryptor_MR_with_EME() { delete encoder; }
+      ~PK_Decryptor_MR_with_EME() { }
    private:
       SecureVector<byte> dec(const byte[], u32bit) const;
       const PK_Decrypting_Key& key;
-      const EME* encoder;
+      std::tr1::shared_ptr<EME const> encoder;
    };
 
 /*************************************************
============================================================
--- include/randpool.h	282ae46ef6ee4355e39982da535d2de946516f9a
+++ include/randpool.h	e1d010322c983011b00f02dd5e7fc6a64c0d5401
@@ -29,8 +29,8 @@ class Randpool : public RandomNumberGene
       void mix_pool();
 
       const u32bit ITERATIONS_BEFORE_RESEED, POOL_BLOCKS;
-      BlockCipher* cipher;
-      MessageAuthenticationCode* mac;
+      std::tr1::shared_ptr<BlockCipher> cipher;
+      std::tr1::shared_ptr<MessageAuthenticationCode> mac;
 
       SecureVector<byte> pool, buffer, counter;
       u32bit entropy;
============================================================
--- include/reducer.h	531a57bee43fa9c80f2d6f83bb0552b79ca2b548
+++ include/reducer.h	9e158a5c35a7e7b3029cbf353d171e0e9e1387d8
@@ -6,7 +6,7 @@
 #ifndef BOTAN_MODARITH_H__
 #define BOTAN_MODARITH_H__
 
-#include <botan/bigint.h>
+#include <botan/math/bigint.h>
 
 namespace Botan {
 
@@ -16,16 +16,16 @@ class Modular_Reducer
 class Modular_Reducer
    {
    public:
-      BigInt multiply(const BigInt&, const BigInt&) const;
-      BigInt square(const BigInt&) const;
-      BigInt reduce(const BigInt&) const;
+	  Botan::math::BigInt multiply(const Botan::math::BigInt&, const Botan::math::BigInt&) const;
+      Botan::math::BigInt square(const Botan::math::BigInt&) const;
+      Botan::math::BigInt reduce(const Botan::math::BigInt&) const;
 
       bool initialized() const { return (mod_words != 0); }
 
       Modular_Reducer() { mod_words = 0; }
-      Modular_Reducer(const BigInt&);
+      Modular_Reducer(const Botan::math::BigInt&);
    private:
-      BigInt modulus, modulus_2, mu;
+      Botan::math::BigInt modulus, modulus_2, mu;
       u32bit mod_words, mod2_words, mu_words;
    };
 
============================================================
--- include/rmd160.h	1871f602862a83334df6aac4f63f16e52114d588
+++ include/rmd160.h	3a77c6d536862ac064a1962cf6b0b2a9eaf55686
@@ -18,7 +18,7 @@ class RIPEMD_160 : public MDx_HashFuncti
    public:
       void clear() throw();
       std::string name() const { return "RIPEMD-160"; }
-      HashFunction* clone() const { return new RIPEMD_160; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new RIPEMD_160); }
       RIPEMD_160() : MDx_HashFunction(20, 64, false, true) { clear(); }
    private:
       void hash(const byte[]);
============================================================
--- include/rng.h	ba9ce2605044c82d04e629ca741eda683dc4d819
+++ include/rng.h	8fd585ea7ddd2f2e0dd34cd27bdf6f972ab214a1
@@ -7,6 +7,7 @@
 #define BOTAN_GLOBAL_RNG_H__
 
 #include <botan/base.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
@@ -23,7 +24,7 @@ u32bit seed(bool = true, u32bit = 256);
 
 u32bit seed(bool = true, u32bit = 256);
 
-void add_es(EntropySource*, bool = true);
+void add_es(SharedPtrConverter<EntropySource>, bool = true);
 
 }
 
============================================================
--- include/rsa.h	bc6b4bf21a81862bc679e9c6c8c81f8523c50ca9
+++ include/rsa.h	83bce4086eeceaa3ca89148544ffa0c455469276
@@ -7,6 +7,7 @@
 #define BOTAN_RSA_H__
 
 #include <botan/if_algo.h>
+#include <botan/math/bigint.h>
 
 namespace Botan {
 
@@ -24,9 +25,9 @@ class RSA_PublicKey : public PK_Encrypti
       SecureVector<byte> verify(const byte[], u32bit) const;
 
       RSA_PublicKey() {}
-      RSA_PublicKey(const BigInt&, const BigInt&);
+      RSA_PublicKey(const Botan::math::BigInt&, const Botan::math::BigInt&);
    protected:
-      BigInt public_op(const BigInt&) const;
+      Botan::math::BigInt public_op(const Botan::math::BigInt&) const;
    };
 
 /*************************************************
@@ -44,11 +45,11 @@ class RSA_PrivateKey : public RSA_Public
       bool check_key(bool) const;
 
       RSA_PrivateKey() {}
-      RSA_PrivateKey(const BigInt&, const BigInt&, const BigInt&,
-                     const BigInt& = 0, const BigInt& = 0);
+      RSA_PrivateKey(const Botan::math::BigInt&, const Botan::math::BigInt&, const Botan::math::BigInt&,
+                     const Botan::math::BigInt& = 0, const Botan::math::BigInt& = 0);
       RSA_PrivateKey(u32bit, u32bit = 65537);
    private:
-      BigInt private_op(const byte[], u32bit) const;
+      Botan::math::BigInt private_op(const byte[], u32bit) const;
    };
 
 }
============================================================
--- include/s2k.h	109b40a203006c1b76f6a6c3d4caff17cdd0fac1
+++ include/s2k.h	4de65fff7413865a269f5d698566555fdfe43d7a
@@ -16,7 +16,7 @@ class S2K
 class S2K
    {
    public:
-      virtual S2K* clone() const = 0;
+      virtual std::auto_ptr<S2K> clone() const = 0;
       virtual std::string name() const = 0;
       virtual void clear() {}
 
============================================================
--- include/secmem.h	6c5143161c26e2aa0c8585a7b0740cefc483cd59
+++ include/secmem.h	7fb526768a06969b62b75825e62680a40b8d810e
@@ -8,7 +8,6 @@
 
 #include <botan/allocate.h>
 #include <botan/mem_ops.h>
-
 namespace Botan {
 
 /*************************************************
@@ -66,7 +65,7 @@ class MemoryRegion
 
       ~MemoryRegion() { deallocate(buf, allocated); }
    protected:
-      MemoryRegion() { buf = 0; alloc = 0; used = allocated = 0; }
+      MemoryRegion() { buf = 0; alloc = std::tr1::shared_ptr<Allocator>(); used = allocated = 0; }
       MemoryRegion(const MemoryRegion<T>& copy)
          {
          buf = 0;
@@ -79,9 +78,9 @@ class MemoryRegion
          { alloc = Allocator::get(locking); create(size); }
    private:
       T* allocate(u32bit n) const
-         {
-         return static_cast<T*>(alloc->allocate(sizeof(T)*n));
-         }
+      {
+      	return static_cast<T*>(alloc->allocate(sizeof(T)*n));
+      }
 
       void deallocate(T* p, u32bit n) const
          { alloc->deallocate(p, sizeof(T)*n); }
@@ -89,7 +88,7 @@ class MemoryRegion
       mutable T* buf;
       mutable u32bit used;
       mutable u32bit allocated;
-      mutable Allocator* alloc;
+      mutable std::tr1::shared_ptr<Allocator> alloc;
    };
 
 /*************************************************
============================================================
--- include/secqueue.h	a2c102173a749d25cf550df38ee83e88043e32f0
+++ include/secqueue.h	7e47a59d0fe4fce014b8d5bc69be5d5d79e95cc8
@@ -32,8 +32,8 @@ class SecureQueue : public Fanout_Filter
       ~SecureQueue() { destroy(); }
    private:
       void destroy();
-      class SecureQueueNode* head;
-      class SecureQueueNode* tail;
+      std::tr1::shared_ptr<class SecureQueueNode> head;
+      std::tr1::shared_ptr<class SecureQueueNode> tail;
    };
 
 }
============================================================
--- include/seed.h	7125d58aaf0fa6d1d3f36c2acf219c25c7c9db0f
+++ include/seed.h	f256c50054abef3aaabb8dff73627622ee76cb49
@@ -18,7 +18,7 @@ class SEED : public BlockCipher
    public:
       void clear() throw() { K.clear(); }
       std::string name() const { return "SEED"; }
-      BlockCipher* clone() const { return new SEED; }
+      AutoBlockCipherPtr clone() const { return AutoBlockCipherPtr(new SEED); }
       SEED() : BlockCipher(16, 16) {}
    private:
       void enc(const byte[], byte[]) const;
============================================================
--- include/sha160.h	4b02347f5d3093d6f9dffa6301eba8b9c1482b03
+++ include/sha160.h	a0e51e3c456b806195e5338dd1f7eedf9c9d2166
@@ -18,7 +18,7 @@ class SHA_160 : public MDx_HashFunction
    public:
       void clear() throw();
       std::string name() const { return "SHA-160"; }
-      HashFunction* clone() const { return new SHA_160; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new SHA_160); }
       SHA_160();
    private:
       void hash(const byte[]);
============================================================
--- include/sha256.h	cd9c6dd936f6352367057c5795848d46bbf248f1
+++ include/sha256.h	2e579da8c2b51a375a630ee3f0db17fb0d6e4dab
@@ -10,24 +10,47 @@ namespace Botan {
 
 namespace Botan {
 
+
 /*************************************************
-* SHA-256                                        *
+* SHA-{224,256} Base                             *
 *************************************************/
-class SHA_256 : public MDx_HashFunction
+class SHA_224256_BASE : public MDx_HashFunction
    {
-   public:
+   protected:
       void clear() throw();
-      std::string name() const { return "SHA-256"; }
-      HashFunction* clone() const { return new SHA_256; }
-      SHA_256() : MDx_HashFunction(32, 64, true, true) { clear(); }
+      SHA_224256_BASE(u32bit out) : MDx_HashFunction(out, 64, true, true) { clear(); }
+      SecureBuffer<u32bit, 64> W;
+      SecureBuffer<u32bit, 8> digest;
    private:
       void hash(const byte[]);
       void copy_out(byte[]);
+   };
 
-      SecureBuffer<u32bit, 64> W;
-      SecureBuffer<u32bit, 8> digest;
+/*************************************************
+* SHA-256                                        *
+*************************************************/
+class SHA_256 : public SHA_224256_BASE
+   {
+   public:
+      void clear() throw();
+      std::string name() const { return "SHA-256"; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new SHA_256); }
+      SHA_256() : SHA_224256_BASE(32) { clear ();}
    };
 
+
+/*************************************************
+* SHA-224                                        *
+*************************************************/
+class SHA_224 : public SHA_224256_BASE
+   {
+   public:
+      void clear() throw();
+      std::string name() const { return "SHA-224"; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new SHA_224); }
+      SHA_224() : SHA_224256_BASE(28) { clear();}
+   };
 }
 
+
 #endif
============================================================
--- include/sha_64.h	25b8f08f7ea8834469c21cfaa0dd543470af0d9a
+++ include/sha_64.h	9225fc7b3cfbf5d16fd3f4159cf201e18bba4820
@@ -34,7 +34,7 @@ class SHA_384 : public SHA_64_BASE
    public:
       void clear() throw();
       std::string name() const { return "SHA-384"; }
-      HashFunction* clone() const { return new SHA_384; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new SHA_384); }
       SHA_384() : SHA_64_BASE(48) { clear(); }
    };
 
@@ -46,7 +46,7 @@ class SHA_512 : public SHA_64_BASE
    public:
       void clear() throw();
       std::string name() const { return "SHA-512"; }
-      HashFunction* clone() const { return new SHA_512; }
+      AutoHashFunctionPtr clone() const { return AutoHashFunctionPtr(new SHA_512); }
       SHA_512() : SHA_64_BASE(64) { clear(); }
    };
 
============================================================
--- include/util.h	bff70e5c51cb75f6fcfb1335e1c5ad38c55ca924
+++ include/util.h	9d06296663f0eeab01d1d21290174c9b6e821dd7
@@ -7,7 +7,7 @@
 #define BOTAN_UTIL_H__
 
 #include <botan/types.h>
-
+#include <boost/type_traits.hpp>
 namespace Botan {
 
 /*************************************************
@@ -35,6 +35,19 @@ u32bit dl_work_factor(u32bit);
 u32bit entropy_estimate(const byte[], u32bit);
 u32bit dl_work_factor(u32bit);
 
+
+/************************************************
+* Pointer conversion                            *
+************************************************/
+
+template< typename T, typename S > T* pointer_cast( S* const& p )
+{
+return static_cast< typename ::boost::remove_cv< T >::type* >(
+     static_cast< void* >(
+       const_cast< typename ::boost::remove_cv< S >::type* >( p )
+     )
+   );
 }
+}
 
 #endif
============================================================
--- include/x509_ca.h	1e8a2dd2335b23e952715f5dbf4b1b792138dbd7
+++ include/x509_ca.h	a29fde1a641fdff5977b494a8bf131637002786a
@@ -29,7 +29,7 @@ class X509_CA
       X509_CRL update_crl(const X509_CRL&, const std::vector<CRL_Entry>&,
                           u32bit = 0) const;
 
-      static X509_Certificate make_cert(PK_Signer*, const AlgorithmIdentifier&,
+      static X509_Certificate make_cert(SharedPtrConverter<PK_Signer>, const AlgorithmIdentifier&,
                                         const MemoryRegion<byte>&,
                                         const X509_Time&, const X509_Time&,
                                         const X509_DN&, const X509_DN&,
@@ -45,13 +45,13 @@ class X509_CA
 
       AlgorithmIdentifier ca_sig_algo;
       X509_Certificate cert;
-      PK_Signer* signer;
+      std::tr1::shared_ptr<PK_Signer> signer;
    };
 
 /*************************************************
 * Choose a signing format for the key            *
 *************************************************/
-PK_Signer* choose_sig_format(const Private_Key&, AlgorithmIdentifier&);
+std::tr1::shared_ptr<PK_Signer> choose_sig_format(const Private_Key&, AlgorithmIdentifier&);
 
 
 }
============================================================
--- include/x509_crl.h	d583fee89c7e7db9f822e212248fd451ad51f69d
+++ include/x509_crl.h	2da53de764abb198e1280c6e3efd79f106dd5f10
@@ -33,7 +33,7 @@ class X509_CRL : public X509_Object
       X509_Time this_update() const;
       X509_Time next_update() const;
 
-      X509_CRL(DataSource&);
+      X509_CRL(SharedPtrConverter<DataSource>);
       X509_CRL(const std::string&);
    private:
       void force_decode();
============================================================
--- include/x509_ext.h	6bde07d391500117c5bf7f17f72aecab7386e1f4
+++ include/x509_ext.h	5dd88c985672cf7942f67afe5261054034c5b7df
@@ -12,6 +12,8 @@
 #include <botan/datastor.h>
 #include <botan/enums.h>
 
+#include <botan/tr1_mem_includer.h>
+
 namespace Botan {
 
 /*************************************************
@@ -22,7 +24,7 @@ class Certificate_Extension
    public:
       OID oid_of() const;
 
-      virtual Certificate_Extension* copy() const = 0;
+      virtual std::auto_ptr<Certificate_Extension> copy() const = 0;
 
       virtual void contents_to(Data_Store&, Data_Store&) const = 0;
       virtual std::string config_id() const = 0;
@@ -47,8 +49,8 @@ class Extensions : public ASN1_Object
 
       void contents_to(Data_Store&, Data_Store&) const;
 
-      void add(Certificate_Extension* extn)
-         { extensions.push_back(extn); }
+      void add(SharedPtrConverter<Certificate_Extension> extn)
+         { extensions.push_back(extn.get_shared()); }
 
       Extensions& operator=(const Extensions& e)
          { return copy_this(e); }
@@ -58,7 +60,7 @@ class Extensions : public ASN1_Object
       ~Extensions();
    private:
       Extensions& copy_this(const Extensions&);
-      std::vector<Certificate_Extension*> extensions;
+      std::vector<std::tr1::shared_ptr<Certificate_Extension> > extensions;
       bool should_throw;
    };
 
@@ -70,8 +72,8 @@ class Basic_Constraints : public Certifi
 class Basic_Constraints : public Certificate_Extension
    {
    public:
-      Basic_Constraints* copy() const
-         { return new Basic_Constraints(is_ca, path_limit); }
+      std::auto_ptr<Certificate_Extension> copy() const
+         { return std::auto_ptr<Certificate_Extension>(new Basic_Constraints(is_ca, path_limit)); }
 
       Basic_Constraints(bool ca = false, u32bit limit = 0) :
          is_ca(ca), path_limit(limit) {}
@@ -96,7 +98,8 @@ class Key_Usage : public Certificate_Ext
 class Key_Usage : public Certificate_Extension
    {
    public:
-      Key_Usage* copy() const { return new Key_Usage(constraints); }
+      std::auto_ptr<Certificate_Extension> copy() const
+         { return std::auto_ptr<Certificate_Extension>(new Key_Usage(constraints)); }
 
       Key_Usage(Key_Constraints c = NO_CONSTRAINTS) : constraints(c) {}
 
@@ -119,7 +122,8 @@ class Subject_Key_ID : public Certificat
 class Subject_Key_ID : public Certificate_Extension
    {
    public:
-      Subject_Key_ID* copy() const { return new Subject_Key_ID(key_id); }
+      std::auto_ptr<Certificate_Extension> copy() const
+        { return std::auto_ptr<Certificate_Extension>(new Subject_Key_ID(key_id)); }
 
       Subject_Key_ID() {}
       Subject_Key_ID(const MemoryRegion<byte>&);
@@ -143,7 +147,8 @@ class Authority_Key_ID : public Certific
 class Authority_Key_ID : public Certificate_Extension
    {
    public:
-      Authority_Key_ID* copy() const { return new Authority_Key_ID(key_id); }
+      std::auto_ptr<Certificate_Extension> copy() const
+              { return std::auto_ptr<Certificate_Extension>(new Authority_Key_ID(key_id)); }
 
       Authority_Key_ID() {}
       Authority_Key_ID(const MemoryRegion<byte>& k) : key_id(k) {}
@@ -193,8 +198,8 @@ class Subject_Alternative_Name : public 
 class Subject_Alternative_Name : public Alternative_Name
    {
    public:
-      Subject_Alternative_Name* copy() const
-         { return new Subject_Alternative_Name(get_alt_name()); }
+      std::auto_ptr<Certificate_Extension> copy() const
+              { return std::auto_ptr<Certificate_Extension>(new Subject_Alternative_Name(get_alt_name())); }
 
       Subject_Alternative_Name(const AlternativeName& = AlternativeName());
    };
@@ -205,8 +210,8 @@ class Issuer_Alternative_Name : public A
 class Issuer_Alternative_Name : public Alternative_Name
    {
    public:
-      Issuer_Alternative_Name* copy() const
-         { return new Issuer_Alternative_Name(get_alt_name()); }
+     std::auto_ptr<Certificate_Extension> copy() const
+              { return std::auto_ptr<Certificate_Extension>(new Issuer_Alternative_Name(get_alt_name())); }
 
       Issuer_Alternative_Name(const AlternativeName& = AlternativeName());
    };
@@ -217,7 +222,8 @@ class Extended_Key_Usage : public Certif
 class Extended_Key_Usage : public Certificate_Extension
    {
    public:
-      Extended_Key_Usage* copy() const { return new Extended_Key_Usage(oids); }
+     std::auto_ptr<Certificate_Extension> copy() const
+              { return std::auto_ptr<Certificate_Extension>(new Extended_Key_Usage(oids)); }
 
       Extended_Key_Usage() {}
       Extended_Key_Usage(const std::vector<OID>& o) : oids(o) {}
@@ -241,8 +247,8 @@ class Certificate_Policies : public Cert
 class Certificate_Policies : public Certificate_Extension
    {
    public:
-      Certificate_Policies* copy() const
-         { return new Certificate_Policies(oids); }
+     std::auto_ptr<Certificate_Extension> copy() const
+              { return std::auto_ptr<Certificate_Extension>(new Certificate_Policies(oids)); }
 
       Certificate_Policies() {}
       Certificate_Policies(const std::vector<OID>& o) : oids(o) {}
@@ -266,7 +272,7 @@ class CRL_Number : public Certificate_Ex
 class CRL_Number : public Certificate_Extension
    {
    public:
-      CRL_Number* copy() const;
+      std::auto_ptr<Certificate_Extension> copy() const ;
 
       CRL_Number() : has_value(false), crl_number(0) {}
       CRL_Number(u32bit n) : has_value(true), crl_number(n) {}
@@ -291,7 +297,8 @@ class CRL_ReasonCode : public Certificat
 class CRL_ReasonCode : public Certificate_Extension
    {
    public:
-      CRL_ReasonCode* copy() const { return new CRL_ReasonCode(reason); }
+      std::auto_ptr<Certificate_Extension> copy() const
+              { return std::auto_ptr<Certificate_Extension>(new CRL_ReasonCode(reason)); }
 
       CRL_ReasonCode(CRL_Code r = UNSPECIFIED) : reason(r) {}
 
============================================================
--- include/x509_key.h	114ed2e6923140353e6678260cec13c71cb4a2fd
+++ include/x509_key.h	1c5f39e4fd97381d72c7eb83cbf33bc7d5c8a7c5
@@ -42,11 +42,11 @@ std::string PEM_encode(const Public_Key&
 void encode(const Public_Key&, Pipe&, X509_Encoding = PEM);
 std::string PEM_encode(const Public_Key&);
 
-Public_Key* load_key(DataSource&);
-Public_Key* load_key(const std::string&);
-Public_Key* load_key(const MemoryRegion<byte>&);
+std::auto_ptr<Public_Key> load_key(SharedPtrConverter<DataSource>);
+std::auto_ptr<Public_Key> load_key(const std::string&);
+std::auto_ptr<Public_Key> load_key(const MemoryRegion<byte>&);
 
-Public_Key* copy_key(const Public_Key&);
+std::auto_ptr<Public_Key> copy_key(const Public_Key&);
 
 Key_Constraints find_constraints(const Public_Key&, Key_Constraints);
 
============================================================
--- include/x509_obj.h	e49bcc7c9c7d559e0f746b0c2533fe635309ac54
+++ include/x509_obj.h	ddadcb6f1a0068d70711c31175846af6aee208f6
@@ -9,20 +9,45 @@
 #include <botan/asn1_obj.h>
 #include <botan/pipe.h>
 #include <vector>
+#include <botan/signed_obj.h>
 
 namespace Botan {
 
 /*************************************************
 * Generic X.509 SIGNED Object                    *
 *************************************************/
-class X509_Object
+class X509_Object : public Signed_Object
    {
-   public:
+       public:
+
+           SecureVector<byte> tbs_data() const;
+           SecureVector<byte> signature() const;
+           SecureVector<byte> get_concat_sig() const;
+           static MemoryVector<byte> make_signed(SharedPtrConverter<class PK_Signer>,
+                   const AlgorithmIdentifier&,
+                   const MemoryRegion<byte>&);
+
+           void encode(Pipe&, X509_Encoding = PEM) const;
+           void decode_info(SharedPtrConverter<DataSource>);
+
+           bool check_signature(class Public_Key&) const;
+
+           X509_Object(const std::string&, const std::string&);
+           X509_Object(SharedPtrConverter<DataSource>, const std::string&);
+
+           virtual ~X509_Object() {}
+
+       protected:
+           X509_Object() {}
+           SecureVector<byte> sig;
+       private:
+           void init(SharedPtrConverter<DataSource>, const std::string&);
+   /*public:
       SecureVector<byte> tbs_data() const;
       SecureVector<byte> signature() const;
       AlgorithmIdentifier signature_algorithm() const;
 
-      static MemoryVector<byte> make_signed(class PK_Signer*,
+      static MemoryVector<byte> make_signed(std::tr1::shared_ptr<class PK_Signer>,
                                             const AlgorithmIdentifier&,
                                             const MemoryRegion<byte>&);
 
@@ -32,7 +57,7 @@ class X509_Object
       SecureVector<byte> BER_encode() const;
       std::string PEM_encode() const;
 
-      X509_Object(DataSource&, const std::string&);
+      X509_Object(std::tr1::shared_ptr<DataSource>&, const std::string&);
       X509_Object(const std::string&, const std::string&);
       virtual ~X509_Object() {}
    protected:
@@ -42,10 +67,10 @@ class X509_Object
       SecureVector<byte> tbs_bits, sig;
    private:
       virtual void force_decode() = 0;
-      void init(DataSource&, const std::string&);
-      void decode_info(DataSource&);
+      void init(std::tr1::shared_ptr<DataSource>&, const std::string&);
+      void decode_info(std::tr1::shared_ptr<DataSource>&);
       std::vector<std::string> PEM_labels_allowed;
-      std::string PEM_label_pref;
+      std::string PEM_label_pref;*/
    };
 
 }
============================================================
--- include/x509cert.h	361b75d7368d02b0de174bc2ec5a9884b27954af
+++ include/x509cert.h	653ebe9c62ed4097f172edb9e2427758f498a801
@@ -20,7 +20,7 @@ class X509_Certificate : public X509_Obj
 class X509_Certificate : public X509_Object
    {
    public:
-      Public_Key* subject_public_key() const;
+     std::auto_ptr<Public_Key> subject_public_key() const;
 
       X509_DN issuer_dn() const;
       X509_DN subject_dn() const;
@@ -45,7 +45,7 @@ class X509_Certificate : public X509_Obj
 
       bool operator==(const X509_Certificate&) const;
 
-      X509_Certificate(DataSource&);
+      X509_Certificate(std::tr1::shared_ptr<DataSource>);
       X509_Certificate(const std::string&);
    private:
       void force_decode();
============================================================
--- include/x509self.h	9aac88cb666ace50f762e4371408402e4618b33f
+++ include/x509self.h	71df28c15491825cbdf720b1d594cfe3eeef102c
@@ -37,6 +37,9 @@ class X509_Cert_Options
       Key_Constraints constraints;
       std::vector<OID> ex_constraints;
 
+        std::string hash_alg;
+        std::string encoding;
+
       void sanity_check() const;
 
       void CA_key(u32bit = 8);
============================================================
--- include/x509stat.h	1d90a638aa2acaeccfa96676c1019623ebec20ae
+++ include/x509stat.h	86f966a7474aa11e0baaa1b4a12a075bd7a2b45d
@@ -4,6 +4,7 @@
 *************************************************/
 
 #include <botan/asn1_oid.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
@@ -13,7 +14,7 @@ class Extension_Prototype
 class Extension_Prototype
    {
    public:
-      virtual class Certificate_Extension* make(const OID&) = 0;
+      virtual std::tr1::shared_ptr<class Certificate_Extension> make(const OID&) = 0;
       virtual ~Extension_Prototype() {}
    };
 
@@ -23,13 +24,13 @@ class X509_GlobalState
 class X509_GlobalState
    {
    public:
-      void add(Extension_Prototype*);
-      class Certificate_Extension* get_extension(const OID&) const;
+      void add(SharedPtrConverter<Extension_Prototype>);
+      std::tr1::shared_ptr<class Certificate_Extension> get_extension(const OID&) const;
 
       X509_GlobalState();
       ~X509_GlobalState();
    private:
-      std::vector<Extension_Prototype*> prototypes;
+      std::vector<std::tr1::shared_ptr<Extension_Prototype> > prototypes;
    };
 
 }
============================================================
--- include/x509stor.h	0c872441411cdd08c7665196990b748eb6eb2710
+++ include/x509stor.h	3a158612c808a37614d822ff9079ccb4652a8e24
@@ -71,12 +71,12 @@ class X509_Store
 
       X509_Code add_crl(const X509_CRL&);
       void add_cert(const X509_Certificate&, bool = false);
-      void add_certs(DataSource&);
-      void add_trusted_certs(DataSource&);
+      void add_certs(SharedPtrConverter<DataSource>);
+      void add_trusted_certs(SharedPtrConverter<DataSource>);
 
-      void add_new_certstore(Certificate_Store*);
+      void add_new_certstore(SharedPtrConverter<Certificate_Store>);
 
-      static X509_Code check_sig(const X509_Object&, Public_Key*);
+      static X509_Code check_sig(const X509_Object&, std::auto_ptr<Public_Key>);
 
       X509_Store();
       X509_Store(const X509_Store&);
@@ -115,7 +115,7 @@ class X509_Store
       X509_Code check_sig(const Cert_Info&, const Cert_Info&) const;
       void recompute_revoked_info() const;
 
-      void do_add_certs(DataSource&, bool);
+      void do_add_certs(SharedPtrConverter<DataSource>, bool);
       X509_Code construct_cert_chain(const X509_Certificate&,
                                      std::vector<u32bit>&, bool = false);
 
@@ -125,7 +125,7 @@ class X509_Store
       static const u32bit NO_CERT_FOUND = 0xFFFFFFFF;
       std::vector<Cert_Info> certs;
       std::vector<CRL_Data> revoked;
-      std::vector<Certificate_Store*> stores;
+      std::vector<std::tr1::shared_ptr<Certificate_Store> > stores;
       mutable bool revoked_info_valid;
    };
 
============================================================
--- include/x919_mac.h	42f8a906807c9dfffa52bf48e9f3e824bf77286b
+++ include/x919_mac.h	faa901b7c96a888a56e2f7c09e3527e54a2eb2aa
@@ -18,15 +18,15 @@ class ANSI_X919_MAC : public MessageAuth
    public:
       void clear() throw();
       std::string name() const { return "X9.19-MAC"; }
-      MessageAuthenticationCode* clone() const { return new ANSI_X919_MAC; }
+      AutoMACPtr clone() const { return AutoMACPtr(new ANSI_X919_MAC); }
       ANSI_X919_MAC();
       ~ANSI_X919_MAC();
    private:
       void add_data(const byte[], u32bit);
       void final_result(byte[]);
       void key(const byte[], u32bit);
-      BlockCipher* e;
-      BlockCipher* d;
+      std::tr1::shared_ptr<BlockCipher> e;
+      std::tr1::shared_ptr<BlockCipher> d;
       SecureBuffer<byte, 8> state;
       u32bit position;
    };
============================================================
--- include/x931_rng.h	2dedc53610c7b07e26bfa9b314c7e56b1db402f9
+++ include/x931_rng.h	253f05c06514cd64cd1dc21d5312622a5074ebdf
@@ -7,6 +7,7 @@
 #define BOTAN_ANSI_X931_RNG_H__
 
 #include <botan/base.h>
+#include <botan/freestore.h>
 
 namespace Botan {
 
@@ -21,14 +22,15 @@ class ANSI_X931_RNG : public RandomNumbe
       void clear() throw();
       std::string name() const;
 
-      ANSI_X931_RNG(const std::string& = "", RandomNumberGenerator* = 0);
+      ANSI_X931_RNG(const std::string& = "",
+    		  SharedPtrConverter<RandomNumberGenerator> = SharedPtrConverter<RandomNumberGenerator>());
       ~ANSI_X931_RNG();
    private:
       void add_randomness(const byte[], u32bit);
       void update_buffer();
 
-      BlockCipher* cipher;
-      RandomNumberGenerator* prng;
+      std::tr1::shared_ptr<BlockCipher> cipher;
+      std::tr1::shared_ptr<RandomNumberGenerator> prng;
       SecureVector<byte> V, R;
       u32bit position;
    };
============================================================
--- misc/config/arch/amd64	0bf63f53099d9804fc351f00c0a60c53199c8b28
+++ misc/config/arch/amd64	e99af0aae34e6c83886d5386e79380471b977fe9
@@ -2,8 +2,6 @@ default_submodel amd64
 
 default_submodel amd64
 
-endian little
-
 <aliases>
 x86-64
 x86_64 # for RPM
@@ -17,9 +15,6 @@ core -> core2duo
 
 <submodel_aliases>
 core -> core2duo
-core2 -> core2duo
-intelcore2 -> core2duo
-intelcore2duo -> core2duo
 athlon64 -> opteron
 k8 -> opteron
 </submodel_aliases>
============================================================
--- misc/config/arch/ia32	2cea203db7576d32a3134dc45035afde3a9a800b
+++ misc/config/arch/ia32	5c1f1b7c540593929009f455a0b2b322cda9c448
@@ -2,8 +2,6 @@ default_submodel i586
 
 default_submodel i586
 
-endian little
-
 <aliases>
 x86
 ix86
============================================================
--- misc/config/arch/sparc32	39f7a595d67765bacc938ca37a31a961f83804f6
+++ misc/config/arch/sparc32	2507cb5d028e15ad2e71f4fb95a16249c1945bab
@@ -4,8 +4,6 @@ default_submodel sparc32-v8
 # (especially BigInt). Also, it's fairly rare nowadays, so we default to V8.
 default_submodel sparc32-v8
 
-endian big
-
 <aliases>
 sparc
 </aliases>
============================================================
--- misc/python/src/block.cpp	b298add9b49710e8d6af9df4982a884203204161
+++ misc/python/src/block.cpp	140867b7786eb4c7491d868c08b85e94d4aa44cf
@@ -67,7 +67,7 @@ class Wrapped_Block_Cipher : public Bloc
       void dec(const byte in[], byte out[]) const { cipher->decrypt(in, out); }
       void key(const byte key[], u32bit len) { cipher->set_key(key, len); }
       std::string name() const { return cipher->name(); }
-      BlockCipher* clone() const { return cipher->clone(); }
+      AutoBlockCipherPtr clone() const { return cipher->clone(); }
 
       Wrapped_Block_Cipher(python::object py_obj, BlockCipher* c) :
          BlockCipher(c->BLOCK_SIZE, c->MINIMUM_KEYLENGTH,
@@ -75,19 +75,19 @@ class Wrapped_Block_Cipher : public Bloc
          obj(py_obj), cipher(c) {}
    private:
       python::object obj;
-      BlockCipher* cipher;
+      AutoBlockCipherPtr cipher;
    };
 
 class Py_BlockCipher_Wrapper : public Py_BlockCipher,
                                public python::wrapper<Py_BlockCipher>
    {
    public:
-      BlockCipher* clone() const
+      AutoBlockCipherPtr clone() const
          {
          python::object self = get_owner(this);
          python::object py_clone = self.attr("__class__")();
          BlockCipher* bc = python::extract<BlockCipher*>(py_clone);
-         return new Wrapped_Block_Cipher(py_clone, bc);
+         return AutoBlockCipherPtr(new Wrapped_Block_Cipher(py_clone, bc));
          }
 
       std::string name() const
============================================================
--- misc/python/src/hash.cpp	a68f2ccf4f9e8632f7633a4218b9f6055061855b
+++ misc/python/src/hash.cpp	3281b86000a35d8672051cf2277cd15ceb0a8683
@@ -35,14 +35,15 @@ class Wrapped_HashFunction : public Hash
       void final_result(byte out[]) { hash->final(out); }
 
       std::string name() const { return hash->name(); }
-      HashFunction* clone() const { return hash->clone(); }
+      AutoHashFunctionPtr clone() const { return hash->clone(); }
 
-      Wrapped_HashFunction(python::object py_obj, HashFunction* h) :
+      Wrapped_HashFunction(python::object py_obj,
+                           SharedHashFunctionPtrConverter const& hc) :
          HashFunction(h->OUTPUT_LENGTH, h->HASH_BLOCK_SIZE),
-         obj(py_obj), hash(h) {}
+         obj(py_obj), hash(hc.get_shared()) {}
    private:
       python::object obj;
-      HashFunction* hash;
+      SharedHashFunctionPtr hash;
    };
 
 class Py_HashFunction_Wrapper : public Py_HashFunction,
============================================================
--- misc/python/src/macs.cpp	192ac72ac1f7d6ac12360c89f7a0c3df8606d23e
+++ misc/python/src/macs.cpp	bc1f6ca94de7cfb456ee29801ba591cf46b8bff0
@@ -36,11 +36,11 @@ class Py_MAC
 
       Py_MAC(const std::string& name)
          {
-         mac = get_mac(name);
+         mac = std::tr1::shared_ptr<MessageAuthenticationCode>(get_mac(name).release());
          }
-      ~Py_MAC() { delete mac; }
+      ~Py_MAC() { }
    private:
-      MessageAuthenticationCode* mac;
+      std::tr1::shared_ptr<MessageAuthenticationCode> mac;
    };
 
 void export_macs()
============================================================
--- misc/python/src/stream.cpp	a4d0da989701f86885876b839054f158f538a7e9
+++ misc/python/src/stream.cpp	27c086313b5f8b0100dd5e4c0944858823e0f282
@@ -33,11 +33,11 @@ class Py_StreamCipher
 
       Py_StreamCipher(const std::string& name)
          {
-         cipher = get_stream_cipher(name);
+         cipher = std::tr1::shared_ptr<StreamCipher>(get_stream_cipher(name).release());
          }
-      ~Py_StreamCipher() { delete cipher; }
+      ~Py_StreamCipher() {  }
    private:
-      StreamCipher* cipher;
+      std::tr1::shared_ptr<StreamCipher> cipher;
    };
 
 void export_stream_ciphers()
============================================================
--- misc/python/src/x509.cpp	01ee39cbd1a13523fbe87f7076915493d5ba59f7
+++ misc/python/src/x509.cpp	0f80045bb7e8c0d33c7ca311221a69e0777a4555
@@ -42,7 +42,7 @@ class memvec_to_hexstr
    public:
       static PyObject* convert(const T& in)
          {
-         Pipe pipe(new Hex_Encoder);
+         Pipe pipe(create_shared_ptr<Hex_Decoder>());
          pipe.process_msg(in);
          std::string result = pipe.read_all_as_string();
          return python::incref(python::str(result).ptr());
============================================================
--- modules/alg_amd64/sha160.cpp	929af7129275293ff09089a5c13ecfa8927eec0e
+++ modules/alg_amd64/sha160.cpp	cf1bc082fc82714258ef1cef7f45c06fafaba48c
@@ -4,7 +4,7 @@
 *************************************************/
 
 #include <botan/sha160.h>
-#include <botan/bit_ops.h>
+#include <botan/math/bit_ops.h>
 
 namespace Botan {
 
============================================================
--- modules/alg_ia32/sha160.cpp	9b4ec6eca3c9909f97700f85d9d66b39d66d3373
+++ modules/alg_ia32/sha160.cpp	b03c29b21d93122c0d6282068b0e2e8dcede56dc
@@ -4,7 +4,7 @@
 *************************************************/
 
 #include <botan/sha160.h>
-#include <botan/bit_ops.h>
+#include <botan/math/bit_ops.h>
 
 namespace Botan {
 
============================================================
--- modules/alloc_mmap/mmap_mem.cpp	19ff049ea80042cf62e1f02ede47004f3acf048a
+++ modules/alloc_mmap/mmap_mem.cpp	6c227f711e8dc90cc80e470a926946bf26e86e3a
@@ -90,7 +90,7 @@ void* MemoryMapping_Allocator::alloc_blo
    void* ptr = mmap(0, n, PROT_READ | PROT_WRITE, MAP_SHARED,
                     file.get_fd(), 0);
 
-   if(ptr == static_cast<void*>(MAP_FAILED))
+   if(ptr == static_cast<void*>(MAP_FAILED)) 
       throw MemoryMapping_Failed("Could not map file");
 
    return ptr;
============================================================
--- modules/es_egd/es_egd.cpp	39d2684aac4c7a382253daf8e50b1c00d797d437
+++ modules/es_egd/es_egd.cpp	eba7755597844e248a425db09649cc2ac1bebadb
@@ -5,7 +5,7 @@
 
 #include <botan/es_egd.h>
 #include <botan/config.h>
-#include <botan/bit_ops.h>
+#include <botan/math/bit_ops.h>
 #include <botan/parsing.h>
 #include <cstring>
 
@@ -61,7 +61,7 @@ u32bit EGD_EntropySource::do_poll(byte o
 
    byte buffer[2];
    buffer[0] = 1;
-   buffer[1] = static_cast<byte>(length);
+   buffer[1] = static_cast<byte>(length); 
 
    if(write(fd, buffer, 2) != 2) { close(fd); return 0; }
    if(read(fd, buffer, 1) != 1)  { close(fd); return 0; }
============================================================
--- modules/es_ftw/es_ftw.cpp	6b9dc7cec896eed27ff456d7a2e4df9947eae598
+++ modules/es_ftw/es_ftw.cpp	ca1c9a63f3264fd17809a8a2e029b069e32c53ca
@@ -97,7 +97,8 @@ void FTW_EntropySource::gather_from_file
       return;
 
    SecureVector<byte> read_buf(1024);
-   ssize_t got = ::read(fd, read_buf.begin(), read_buf.size());
+   ssize_t got = ::read(fd, read_buf.begin(), read_buf.size()); 
+
    close(fd);
 
    if(got > 0)
============================================================
--- modules/es_unix/unix_cmd.cpp	e749e0619b750a2faf429dcd44fc030f344fd280
+++ modules/es_unix/unix_cmd.cpp	03940ed1eaa9e3e9954e434ba0b7fdc015a65f2d
@@ -16,9 +16,9 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
-#include <stdlib.h>
 #include <unistd.h>
 #include <signal.h>
+#include <stdlib.h>
 
 namespace Botan {
 
@@ -41,7 +41,7 @@ void do_exec(const std::vector<std::stri
       {
       const std::string full_path = paths[j] + "/" + arg_list[0];
       const char* fsname = full_path.c_str();
-      execl(fsname, fsname, arg1, arg2, arg3, arg4, 0);
+      execl(fsname, fsname, arg1, arg2, arg3, arg4, NULL);
       }
    }
 
@@ -158,7 +158,7 @@ void DataSource_Command::create_pipe(con
       }
    else if(pid > 0)
       {
-      pipe = new pipe_wrapper;
+      pipe = std::tr1::shared_ptr<pipe_wrapper>(new pipe_wrapper);
       pipe->fd = pipe_fd[0];
       pipe->pid = pid;
       close(pipe_fd[1]);
@@ -207,8 +207,7 @@ void DataSource_Command::shutdown_pipe()
          }
 
       close(pipe->fd);
-      delete pipe;
-      pipe = 0;
+      pipe.reset();
       }
    }
 
@@ -226,7 +225,6 @@ DataSource_Command::DataSource_Command(c
    if(arg_list.size() > 5)
       throw Invalid_Argument("DataSource_Command: Too many args");
 
-   pipe = 0;
    create_pipe(path);
    }
 
============================================================
--- modules/es_unix/unix_cmd.h	11b6da666e000229de3db2dee4b54061be9259a9
+++ modules/es_unix/unix_cmd.h	5d9a4f713677f216d615076a72f637f130f8c43c
@@ -48,7 +48,7 @@ class DataSource_Command : public DataSo
       const u32bit MAX_BLOCK_USECS, KILL_WAIT;
 
       std::vector<std::string> arg_list;
-      struct pipe_wrapper* pipe;
+      std::tr1::shared_ptr<struct pipe_wrapper> pipe;
    };
 
 }
============================================================
--- modules/es_win32/es_win32.cpp	e8926bb59147dcd331a5c940cac2123326d665e0
+++ modules/es_win32/es_win32.cpp	6ce81dcc3f6e138231aeb97c6d3d9702d62dd922
@@ -100,10 +100,9 @@ void Win32_EntropySource::do_fast_poll()
    add_bytes(&point, sizeof(point));
    GetCaretPos(&point);
    add_bytes(&point, sizeof(point));
-
-   LARGE_INTEGER perf_counter;
-   QueryPerformanceCounter(&perf_counter);
-   add_bytes(&perf_counter, sizeof(perf_counter));
+   LARGE_INTEGER perf_counter; 
+   QueryPerformanceCounter(&perf_counter); 
+   add_bytes(&perf_counter, sizeof(perf_counter)); 
    }
 
 }
============================================================
--- modules/mux_pthr/mux_pthr.cpp	1b71d8f314a2e4019a17e8ec0512e9bc33d74042
+++ modules/mux_pthr/mux_pthr.cpp	35f7c1f07340ae23bc695e31eb26bc729682b197
@@ -17,7 +17,7 @@ namespace Botan {
 /*************************************************
 * Pthread Mutex Factory                          *
 *************************************************/
-Mutex* Pthread_Mutex_Factory::make()
+std::auto_ptr<Mutex> Pthread_Mutex_Factory::make()
    {
 
    class Pthread_Mutex : public Mutex
@@ -50,7 +50,7 @@ Mutex* Pthread_Mutex_Factory::make()
          pthread_mutex_t mutex;
       };
 
-   return new Pthread_Mutex();
+   return std::auto_ptr<Mutex>(new Pthread_Mutex());
    }
 
 }
============================================================
--- modules/mux_pthr/mux_pthr.h	3cba14c238dd6906b6f2ad7313f1acb020a8e2a1
+++ modules/mux_pthr/mux_pthr.h	c8bee4a5d5a6ef5b2bd968476c7b6f019e0edca5
@@ -16,7 +16,7 @@ class Pthread_Mutex_Factory : public Mut
 class Pthread_Mutex_Factory : public Mutex_Factory
    {
    public:
-      Mutex* make();
+     std::auto_ptr<Mutex> make();
    };
 
 }
============================================================
--- modules/mux_qt/mux_qt.cpp	4348db9135214fb67f32c090b365bce6bc57fca7
+++ modules/mux_qt/mux_qt.cpp	b893e4e5af9bca1f44bd017ff6294b773615635a
@@ -15,7 +15,7 @@ namespace Botan {
 /*************************************************
 * Qt Mutex Factory                               *
 *************************************************/
-Mutex* Qt_Mutex_Factory::make()
+std::auto_ptr<Mutex> Qt_Mutex_Factory::make()
    {
    class Qt_Mutex : public Mutex
       {
@@ -26,7 +26,7 @@ Mutex* Qt_Mutex_Factory::make()
          QMutex mutex;
       };
 
-   return new Qt_Mutex();
+   return std::auto_ptr<Mutex>(new Qt_Mutex());
    }
 
 }
============================================================
--- modules/mux_qt/mux_qt.h	761e85cec7751826125aa7a8fe92585ffdfc24a6
+++ modules/mux_qt/mux_qt.h	00a1c714fae50c7f72075a63c00db1cf105c7b50
@@ -16,7 +16,7 @@ class Qt_Mutex_Factory : public Mutex_Fa
 class Qt_Mutex_Factory : public Mutex_Factory
    {
    public:
-      Mutex* make();
+     std::auto_ptr<Mutex> make();
    };
 
 }
============================================================
--- modules/mux_win32/mux_win32.cpp	19a4300b712529f55d9d07436c2a849f19694099
+++ modules/mux_win32/mux_win32.cpp	3b214275abed4e8423354959053a60c2061b7def
@@ -12,7 +12,7 @@ namespace Botan {
 /*************************************************
 * Win32 Mutex Factory                            *
 *************************************************/
-Mutex* Win32_Mutex_Factory::make()
+std::auto_ptr<Mutex> Win32_Mutex_Factory::make()
    {
    class Win32_Mutex : public Mutex
       {
@@ -26,7 +26,7 @@ Mutex* Win32_Mutex_Factory::make()
          CRITICAL_SECTION mutex;
       };
 
-   return new Win32_Mutex();
+   return std::auto_ptr<Mutex>(new Win32_Mutex());
    }
 
 }
============================================================
--- modules/mux_win32/mux_win32.h	d606c2bf9333915986ea27af96e37d3ae4dbcc0d
+++ modules/mux_win32/mux_win32.h	c1b4c4a4f76a8a0661310ce3f4b3a72a08590884
@@ -16,7 +16,7 @@ class Win32_Mutex_Factory : public Mutex
 class Win32_Mutex_Factory : public Mutex_Factory
    {
    public:
-      Mutex* make();
+     std::auto_ptr<Mutex> make();
    };
 }
 
============================================================
--- src/asn1_int.cpp	f2c2e23eaf6d2fa711a14e0b9d06933d90885501
+++ src/asn1_int.cpp	7a7e3926bce89863046a9a8cc7504b6f3ba021be
@@ -50,13 +50,13 @@ std::string to_string(const BER_Object& 
 /*************************************************
 * Do heuristic tests for BER data                *
 *************************************************/
-bool maybe_BER(DataSource& source)
+bool maybe_BER(SharedPtrConverter<DataSource> source)
    {
    byte first_byte;
-   if(!source.peek_byte(first_byte))
+   if(!source.get_shared()->peek_byte(first_byte))
       throw Stream_IO_Error("ASN1::maybe_BER: Source was empty");
 
-   if(first_byte == (SEQUENCE | CONSTRUCTED))
+   if((first_byte == (SEQUENCE | CONSTRUCTED)) || (first_byte == CV_Certificate) || first_byte == CVC_ADO)
       return true;
    return false;
    }
============================================================
--- src/asn1_str.cpp	1a3b46df6c07368ff753748688d171d3f7f16551
+++ src/asn1_str.cpp	14608621192719015bdebcf35123ef7ee9e5da67
@@ -44,7 +44,7 @@ ASN1_Tag choose_encoding(const std::stri
       0x00, 0x00, 0x00, 0x00 };
 
    for(u32bit j = 0; j != str.size(); ++j)
-      if(!IS_PRINTABLE[static_cast<byte>(str[j])])
+  	  if(!IS_PRINTABLE[static_cast<byte>(str[j])])
          {
          const std::string type = global_config().option("x509/ca/str_type");
 
============================================================
--- src/base.cpp	42d599ac6a7769d1ea6cae06c345e8ecb9e2bbcf
+++ src/base.cpp	2b0008aec79b685d30e34d1e1b05aab5c5d43f44
@@ -7,6 +7,8 @@
 #include <botan/version.h>
 #include <botan/util.h>
 #include <botan/config.h>
+#include <botan/bigint.h>
+using namespace Botan::math;
 
 namespace Botan {
 
@@ -150,7 +152,7 @@ void BufferedComputation::update(const s
 *************************************************/
 void BufferedComputation::update(const std::string& str)
    {
-   update(reinterpret_cast<const byte*>(str.data()), str.size());
+	update(reinterpret_cast<const byte*>(str.data()), str.size());
    }
 
 /*************************************************
============================================================
--- src/base64.cpp	051a2bfee04baa078b6ac9f25e6f955be2a5ebdb
+++ src/base64.cpp	56c846ca7c74423da0ae38c8d7cb050b15ecfe5a
@@ -147,9 +147,9 @@ void Base64_Decoder::decode(const byte i
 *************************************************/
 void Base64_Decoder::decode(const byte in[4], byte out[3])
    {
-   out[0] = ((BASE64_TO_BIN[in[0]] << 2) | (BASE64_TO_BIN[in[1]] >> 4));
-   out[1] = ((BASE64_TO_BIN[in[1]] << 4) | (BASE64_TO_BIN[in[2]] >> 2));
-   out[2] = ((BASE64_TO_BIN[in[2]] << 6) | (BASE64_TO_BIN[in[3]]));
+    out[0] = ((BASE64_TO_BIN[in[0]] << 2) | (BASE64_TO_BIN[in[1]] >> 4));
+    out[1] = ((BASE64_TO_BIN[in[1]] << 4) | (BASE64_TO_BIN[in[2]] >> 2));
+    out[2] = ((BASE64_TO_BIN[in[2]] << 6) | (BASE64_TO_BIN[in[3]]));
    }
 
 /*************************************************
@@ -176,8 +176,8 @@ void Base64_Decoder::handle_bad_char(byt
       return;
 
    throw Decoding_Error(
-      std::string("Base64_Decoder: Invalid base64 character '") +
-      static_cast<char>(c) + "'"
+       std::string("Base64_Decoder: Invalid base64 character '") +
+       static_cast<char>(c) + "'"
       );
    }
 
============================================================
--- src/basefilt.cpp	0bf28cb04325d403ef59e7189e7972b489900a6f
+++ src/basefilt.cpp	510f0f5db11730105039b15edb712ece8f8c167d
@@ -3,6 +3,12 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
+/*#ifdef TRONE_STD
+#include <tr1/array>
+#elif TRONE_BOOST
+#include <boost/tr1/array.hpp>
+#endif*/
+#include <botan/tr1_array_includer.h>
 #include <botan/basefilt.h>
 
 namespace Botan {
@@ -10,45 +16,39 @@ namespace Botan {
 /*************************************************
 * Chain Constructor                              *
 *************************************************/
-Chain::Chain(Filter* f1, Filter* f2, Filter* f3, Filter* f4)
+Chain::Chain(SharedFilterPtrConverter const& f1c,
+             SharedFilterPtrConverter const& f2c,
+             SharedFilterPtrConverter const& f3c,
+             SharedFilterPtrConverter const& f4c)
+   : Fanout_Filter()
    {
+     SharedFilterPtr const& f1(f1c.get_shared());
    if(f1) { attach(f1); incr_owns(); }
+   SharedFilterPtr const& f2(f2c.get_shared());
    if(f2) { attach(f2); incr_owns(); }
+   SharedFilterPtr const& f3(f3c.get_shared());
    if(f3) { attach(f3); incr_owns(); }
+   SharedFilterPtr const& f4(f4c.get_shared());
    if(f4) { attach(f4); incr_owns(); }
    }
 
 /*************************************************
-* Chain Constructor                              *
-*************************************************/
-Chain::Chain(Filter* filters[], u32bit count)
-   {
-   for(u32bit j = 0; j != count; ++j)
-      if(filters[j])
-         {
-         attach(filters[j]);
-         incr_owns();
-         }
-   }
-
-/*************************************************
 * Fork Constructor                               *
 *************************************************/
-Fork::Fork(Filter* f1, Filter* f2, Filter* f3, Filter* f4)
+Fork::Fork(SharedFilterPtrConverter const& f1c,
+           SharedFilterPtrConverter const& f2c,
+           SharedFilterPtrConverter const& f3c,
+           SharedFilterPtrConverter const& f4c)
+   : Fanout_Filter()
    {
-   Filter* filters[4] = { f1, f2, f3, f4 };
-   set_next(filters, 4);
+     std::tr1::array<SharedFilterPtr,4> filters = {{ f1c.get_shared(),
+                                                     f2c.get_shared(),
+                                                     f3c.get_shared(),
+                                                     f4c.get_shared() }};
+   set_next(filters.begin(), filters.end());
    }
 
 /*************************************************
-* Fork Constructor                               *
-*************************************************/
-Fork::Fork(Filter* filters[], u32bit count)
-   {
-   set_next(filters, count);
-   }
-
-/*************************************************
 * Set the algorithm key                          *
 *************************************************/
 void Keyed_Filter::set_key(const SymmetricKey& key)
============================================================
--- src/ber_dec.cpp	d22b06ac717befb508e9dbe7d34bcf5681280287
+++ src/ber_dec.cpp	e9d77f9f03f36ab9d8e460a6607c0896c703663d
@@ -4,8 +4,9 @@
 *************************************************/
 
 #include <botan/ber_dec.h>
+#include <botan/bit_ops.h>
 #include <botan/bigint.h>
-#include <botan/bit_ops.h>
+using namespace Botan::math;
 
 namespace Botan {
 
@@ -14,7 +15,7 @@ namespace {
 /*************************************************
 * BER decode an ASN.1 type tag                   *
 *************************************************/
-u32bit decode_tag(DataSource* ber, ASN1_Tag& type_tag, ASN1_Tag& class_tag)
+u32bit decode_tag(const std::tr1::shared_ptr<DataSource>& ber, ASN1_Tag& type_tag, ASN1_Tag& class_tag)
    {
    byte b;
    if(!ber->read_byte(b))
@@ -51,12 +52,12 @@ u32bit decode_tag(DataSource* ber, ASN1_
 /*************************************************
 * Find the EOC marker                            *
 *************************************************/
-u32bit find_eoc(DataSource*);
+u32bit find_eoc(const std::tr1::shared_ptr<DataSource>&);
 
 /*************************************************
 * BER decode an ASN.1 length field               *
 *************************************************/
-u32bit decode_length(DataSource* ber, u32bit& field_size)
+u32bit decode_length(const std::tr1::shared_ptr<DataSource>& ber, u32bit& field_size)
    {
    byte b;
    if(!ber->read_byte(b))
@@ -86,7 +87,7 @@ u32bit decode_length(DataSource* ber, u3
 /*************************************************
 * BER decode an ASN.1 length field               *
 *************************************************/
-u32bit decode_length(DataSource* ber)
+u32bit decode_length(const std::tr1::shared_ptr<DataSource>& ber)
    {
    u32bit dummy;
    return decode_length(ber, dummy);
@@ -95,7 +96,7 @@ u32bit decode_length(DataSource* ber)
 /*************************************************
 * Find the EOC marker                            *
 *************************************************/
-u32bit find_eoc(DataSource* ber)
+u32bit find_eoc(const std::tr1::shared_ptr<DataSource>& ber)
    {
    SecureVector<byte> buffer(DEFAULT_BUFFERSIZE), data;
 
@@ -107,20 +108,20 @@ u32bit find_eoc(DataSource* ber)
       data.append(buffer, got);
       }
 
-   DataSource_Memory source(data);
+   std::tr1::shared_ptr<DataSource_Memory> source(new DataSource_Memory(data));
    data.destroy();
 
    u32bit length = 0;
    while(true)
       {
       ASN1_Tag type_tag, class_tag;
-      u32bit tag_size = decode_tag(&source, type_tag, class_tag);
+      u32bit tag_size = decode_tag(source, type_tag, class_tag);
       if(type_tag == NO_OBJECT)
          break;
 
       u32bit length_size = 0;
-      u32bit item_size = decode_length(&source, length_size);
-      source.discard_next(item_size);
+      u32bit item_size = decode_length(source, length_size);
+      source->discard_next(item_size);
 
       length += item_size + length_size + tag_size;
 
@@ -137,8 +138,8 @@ void BER_Object::assert_is_a(ASN1_Tag ty
 *************************************************/
 void BER_Object::assert_is_a(ASN1_Tag type_tag, ASN1_Tag class_tag)
    {
-   if(this->type_tag != type_tag || this->class_tag != class_tag)
-      throw BER_Decoding_Error("Tag mismatch when decoding");
+       if(this->type_tag != type_tag || this->class_tag != class_tag)
+           throw BER_Decoding_Error("Tag mismatch when decoding");
    }
 
 /*************************************************
@@ -229,7 +230,14 @@ BER_Decoder BER_Decoder::start_cons(ASN1
 BER_Decoder BER_Decoder::start_cons(ASN1_Tag type_tag)
    {
    BER_Object obj = get_next_object();
-   obj.assert_is_a(type_tag, CONSTRUCTED);
+   //obj.assert_is_a(type_tag, CONSTRUCTED); // this function call actually checks for
+                                            // (UNIVERSAL | CONSTRUCTED)
+   // BEGIN (replacement for above call)
+   if(obj.type_tag != type_tag || (obj.class_tag & CONSTRUCTED) != CONSTRUCTED)
+   {
+       throw BER_Decoding_Error("Tag mismatch when decoding");
+   }
+   // END (replacement)
    BER_Decoder result(obj.value, obj.value.size());
    result.parent = this;
    return result;
@@ -250,9 +258,9 @@ BER_Decoder& BER_Decoder::end_cons()
 /*************************************************
 * BER_Decoder Constructor                        *
 *************************************************/
-BER_Decoder::BER_Decoder(DataSource& src)
+BER_Decoder::BER_Decoder(SharedPtrConverter<DataSource> const& src)
    {
-   source = &src;
+   source = src.get_shared();
    owns = false;
    pushed.type_tag = pushed.class_tag = NO_OBJECT;
    parent = 0;
@@ -263,7 +271,7 @@ BER_Decoder::BER_Decoder(const byte data
  *************************************************/
 BER_Decoder::BER_Decoder(const byte data[], u32bit length)
    {
-   source = new DataSource_Memory(data, length);
+   source = std::tr1::shared_ptr<DataSource_Memory>(new DataSource_Memory(data, length));
    owns = true;
    pushed.type_tag = pushed.class_tag = NO_OBJECT;
    parent = 0;
@@ -274,7 +282,7 @@ BER_Decoder::BER_Decoder(const MemoryReg
 *************************************************/
 BER_Decoder::BER_Decoder(const MemoryRegion<byte>& data)
    {
-   source = new DataSource_Memory(data);
+   source = std::tr1::shared_ptr<DataSource_Memory>(new DataSource_Memory(data));
    owns = true;
    pushed.type_tag = pushed.class_tag = NO_OBJECT;
    parent = 0;
@@ -301,9 +309,7 @@ BER_Decoder::~BER_Decoder()
 *************************************************/
 BER_Decoder::~BER_Decoder()
    {
-   if(owns)
-      delete source;
-   source = 0;
+   source.reset();
    }
 
 /*************************************************
@@ -452,7 +458,6 @@ BER_Decoder& BER_Decoder::decode_optiona
                                                  u16bit type_no)
    {
    BER_Object obj = get_next_object();
-
    ASN1_Tag type_tag = static_cast<ASN1_Tag>(type_no);
 
    out.clear();
@@ -463,5 +468,37 @@ BER_Decoder& BER_Decoder::decode_optiona
 
    return (*this);
    }
+/********************************************
+* optional decoding for MemoryRegion<byte>  *
+* for primitive types only                  *
+********************************************/
+   BER_Decoder& BER_Decoder::decode_optional(MemoryRegion<byte>& out,
+                                             ASN1_Tag real_type,
+                                             ASN1_Tag type_tag,
+                                             ASN1_Tag class_tag,
+                                             const MemoryRegion<byte>& default_value)
+     {
+         BER_Object obj = get_next_object();
+         if(obj.type_tag == type_tag && obj.class_tag == class_tag)
+         {
+             if(class_tag & CONSTRUCTED)
+             {
+                 throw Decoding_Error("decode_optional(MemoryRegion<byte>&, ...) can not decode constructed types");
+             }
+             else
+             {
+                 push_back(obj);
+                 decode(out, real_type, type_tag, class_tag);
+             }
+         }
+         else
+         {
+             out = default_value;
+             push_back(obj);
+         }
 
+         return (*this);
+
+     }
+
 }
============================================================
--- src/blinding.cpp	53fd0d7c91414698f91d3a69220267f839eef5bd
+++ src/blinding.cpp	1d0f7a1d157ed60866f3a37f7b2404941594650b
@@ -4,8 +4,11 @@
 *************************************************/
 
 #include <botan/blinding.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
============================================================
--- src/cbc_mac.cpp	b3c8242798b008bb0b0d81ea3b0d7d10e906b5b8
+++ src/cbc_mac.cpp	da331f82d53c408d343d42cd323c91af6370fb89
@@ -79,9 +79,9 @@ std::string CBC_MAC::name() const
 /*************************************************
 * Return a clone of this object                  *
 *************************************************/
-MessageAuthenticationCode* CBC_MAC::clone() const
+CBC_MAC::AutoMACPtr CBC_MAC::clone() const
    {
-   return new CBC_MAC(e->name());
+   return CBC_MAC::AutoMACPtr(new CBC_MAC(e->name()));
    }
 
 /*************************************************
@@ -94,16 +94,18 @@ CBC_MAC::CBC_MAC(const std::string& ciph
                              keylength_multiple_of(cipher)),
    state(block_size_of(cipher))
    {
-   e = get_block_cipher(cipher);
+   e = std::tr1::shared_ptr<BlockCipher>(get_block_cipher(cipher).release());
    position = 0;
    }
 
 /*************************************************
 * CBC-MAC Destructor                             *
 *************************************************/
+/*
 CBC_MAC::~CBC_MAC()
    {
    delete e;
    }
+*/
 
 }
============================================================
--- src/charset.cpp	9b04fadf0a683fbf0bcf033846b3848f1cb599d6
+++ src/charset.cpp	41c442ec7db4e9abb1963fa0dee2cad473113816
@@ -92,10 +92,11 @@ bool caseless_cmp(char a, char b)
 *************************************************/
 bool caseless_cmp(char a, char b)
    {
-   return (std::tolower(static_cast<unsigned char>(a)) ==
-           std::tolower(static_cast<unsigned char>(b)));
+       return (std::tolower(static_cast<unsigned char>(a)) ==
+	           std::tolower(static_cast<unsigned char>(b)));
    }
 
+
 }
 
 /*************************************************
============================================================
--- src/cmac.cpp	a04835d6edf3c504406b4eb69f8bdf6eb645e4db
+++ src/cmac.cpp	8b0f605f3815739dbcc94dc6fb43e23e05f2b871
@@ -122,9 +122,9 @@ std::string CMAC::name() const
 /*************************************************
 * Return a clone of this object                  *
 *************************************************/
-MessageAuthenticationCode* CMAC::clone() const
+CMAC::AutoMACPtr CMAC::clone() const
    {
-   return new CMAC(e->name());
+   return CMAC::AutoMACPtr(new CMAC(e->name()));
    }
 
 /*************************************************
@@ -136,7 +136,7 @@ CMAC::CMAC(const std::string& bc_name) :
                              max_keylength_of(bc_name),
                              keylength_multiple_of(bc_name))
    {
-   e = get_block_cipher(bc_name);
+   e = std::tr1::shared_ptr<BlockCipher>(get_block_cipher(bc_name).release());
 
    if(e->BLOCK_SIZE == 16)     polynomial = 0x87;
    else if(e->BLOCK_SIZE == 8) polynomial = 0x1B;
============================================================
--- src/config.cpp	cb5e6f5108247da86e71cfbb2e553cfc755d4c9a
+++ src/config.cpp	9342ebe7c22d118b6d3d0e27891245a39d2e99fc
@@ -12,6 +12,11 @@
 #include <botan/mutex.h>
 #include <string>
 
+
+using namespace Botan::math;
+using namespace Botan::math::ec;
+using namespace Botan::math::gf;
+
 namespace Botan {
 
 /*************************************************
@@ -34,6 +39,7 @@ std::string Config::get(const std::strin
                                                section + "/" + key, "");
    }
 
+
 /*************************************************
 * See if a particular option has been set        *
 *************************************************/
@@ -62,6 +68,35 @@ void Config::set(const std::string& sect
       settings[full_key] = value;
    }
 
+void Config::set_ec_dompar(const std::string& oid, const std::vector<std::string>& dom_par)
+{
+    Named_Mutex_Holder lock("config");
+    ec_domain_params[oid] = dom_par;
+}
+EC_Domain_Params Config::get_ec_dompar(const std::string& oid)
+{
+    Named_Mutex_Holder lock("config");
+    if(!search_map(ec_domain_params, oid, false, true))
+    {
+        throw Lookup_Error("could not find requested domain parameter oid");
+    }
+	std::vector<std::string> dom_par =
+		search_map<std::string, std::vector<std::string> >(ec_domain_params,
+            oid);
+    BigInt p(dom_par[0]); // give as 0x...
+    gf::GFpElement a(p, BigInt(dom_par[1]));
+    gf::GFpElement b(p, BigInt(dom_par[2]));
+    Botan::Pipe pipe(Botan::create_shared_ptr<Botan::Hex_Decoder>());
+    pipe.process_msg(dom_par[3]);
+    ::Botan::SecureVector<byte> sv_g = pipe.read_all();
+    CurveGFp curve(a, b, p);
+    PointGFp G = OS2ECP ( sv_g, curve );
+    G.check_invariants();
+    BigInt order(dom_par[4]);
+    BigInt cofactor(dom_par[5]);
+    EC_Domain_Params result(curve, G, order, cofactor);
+     return result;
+}
 /*************************************************
 * Add an alias                                   *
 *************************************************/
@@ -182,12 +217,19 @@ void Config::choose_sig_format(const std
       padding = "EMSA3(" + hash + ")";
       format = IEEE_1363;
       }
-   else if(algo_name == "DSA")
+   else if(algo_name == "ECDSA")
       {
-      std::string hash = global_state().config().deref_alias("SHA-1");
-      padding = "EMSA1(" + hash + ")";
-      format = DER_SEQUENCE;
+
+          std::string hash = global_state().config().option("x509/ca/ecdsa_hash");
+
+      if(hash == "")
+      {
+         throw Invalid_State("No value set for x509/ca/ecdsa_hash");
       }
+
+          padding = "EMSA1_BSI(" + hash + ")";
+          format = IEEE_1363;
+      }
    else
       throw Invalid_Argument("Unknown X.509 signing key type: " + algo_name);
    }
============================================================
--- src/crl_ent.cpp	5bea084ef556530cb38d3de655db2983ff08f5ca
+++ src/crl_ent.cpp	a68a0947e32c35de546ab60d922783bf64f501d1
@@ -7,10 +7,11 @@
 #include <botan/x509_ext.h>
 #include <botan/der_enc.h>
 #include <botan/ber_dec.h>
-#include <botan/bigint.h>
 #include <botan/config.h>
 #include <botan/oids.h>
 #include <botan/util.h>
+#include <botan/bigint.h>
+using namespace Botan::math;
 
 namespace Botan {
 
@@ -69,10 +70,11 @@ void CRL_Entry::encode_into(DER_Encoder&
    {
    Extensions extensions;
 
-   extensions.add(new Cert_Extension::CRL_ReasonCode(reason));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::CRL_ReasonCode>(
+       new Cert_Extension::CRL_ReasonCode(reason)));
 
    der.start_cons(SEQUENCE)
-         .encode(BigInt::decode(serial, serial.size()))
+         .encode(math::BigInt::decode(serial, serial.size()))
          .encode(time)
          .encode(extensions)
       .end_cons();
@@ -105,7 +107,7 @@ void CRL_Entry::decode_from(BER_Decoder&
       reason = CRL_Code(info.get1_u32bit("X509v3.CRLReasonCode"));
       }
 
-   serial = BigInt::encode(serial_number_bn);
+   serial = math::BigInt::encode(serial_number_bn);
    }
 
 }
============================================================
--- src/data_snk.cpp	fae39562bf0033d40f6bf9d9959228adab62a8b2
+++ src/data_snk.cpp	b59a17aac01bdc4dc22fe1d2b009796b10552a6d
@@ -21,9 +21,9 @@ void DataSink_Stream::write(const byte o
 /*************************************************
 * DataSink_Stream Constructor                    *
 *************************************************/
-DataSink_Stream::DataSink_Stream(std::ostream& stream) : fsname("std::ostream")
+DataSink_Stream::DataSink_Stream(const SharedPtrConverter<std::ostream>& stream) : fsname("std::ostream")
    {
-   sink = &stream;
+   sink = stream.get_shared();
    owns = false;
    }
 
@@ -34,9 +34,9 @@ DataSink_Stream::DataSink_Stream(const s
                                  bool use_binary) : fsname(file)
    {
    if(use_binary)
-      sink = new std::ofstream(fsname.c_str(), std::ios::binary);
+      sink = std::tr1::shared_ptr<std::ostream>(new std::ofstream(fsname.c_str(), std::ios::binary));
    else
-      sink = new std::ofstream(fsname.c_str());
+      sink = std::tr1::shared_ptr<std::ostream>(new std::ofstream(fsname.c_str()));
 
    if(!sink->good())
       throw Stream_IO_Error("DataSink_Stream: Failure opening " + fsname);
@@ -48,9 +48,7 @@ DataSink_Stream::~DataSink_Stream()
 *************************************************/
 DataSink_Stream::~DataSink_Stream()
    {
-   if(owns)
-      delete sink;
-   sink = 0;
+    sink.reset();
    }
 
 }
============================================================
--- src/data_src.cpp	0b0c1e5793da7b053571a78da4ee951013211190
+++ src/data_src.cpp	c4797b3dee36f435c652d5552eeb790f990a1539
@@ -103,6 +103,7 @@ u32bit DataSource_Stream::read(byte out[
 u32bit DataSource_Stream::read(byte out[], u32bit length)
    {
    source->read(reinterpret_cast<char*>(out), length);
+   
    if(source->bad())
       throw Stream_IO_Error("DataSource_Stream::read: Source failure");
 
@@ -168,9 +169,9 @@ DataSource_Stream::DataSource_Stream(con
                                      bool use_binary) : fsname(file)
    {
    if(use_binary)
-      source = new std::ifstream(fsname.c_str(), std::ios::binary);
+      source = std::tr1::shared_ptr<std::istream>(new std::ifstream(fsname.c_str(), std::ios::binary));
    else
-      source = new std::ifstream(fsname.c_str());
+      source = std::tr1::shared_ptr<std::istream>(new std::ifstream(fsname.c_str()));
 
    if(!source->good())
       throw Stream_IO_Error("DataSource_Stream: Failure opening " + fsname);
@@ -182,7 +183,6 @@ DataSource_Stream::~DataSource_Stream()
 *************************************************/
 DataSource_Stream::~DataSource_Stream()
    {
-   delete source;
    }
 
 }
============================================================
--- src/datastor.cpp	301a7be0303d65b1589216c1f2bcb072ac17e34b
+++ src/datastor.cpp	988c2c0075b907ef51eeef0e8f0e6d09b496d878
@@ -102,7 +102,7 @@ Data_Store::get1_memvec(const std::strin
    if(vals.empty())
       return MemoryVector<byte>();
 
-   Pipe pipe(new Hex_Decoder(FULL_CHECK));
+   Pipe pipe(create_shared_ptr<Hex_Decoder>(FULL_CHECK));
    pipe.start_msg();
    if(vals.size())
       pipe.write(vals[0]);
@@ -148,7 +148,7 @@ void Data_Store::add(const std::string& 
 *************************************************/
 void Data_Store::add(const std::string& key, const MemoryRegion<byte>& val)
    {
-   Pipe pipe(new Hex_Encoder);
+   Pipe pipe(create_shared_ptr<Hex_Encoder>());
    pipe.process_msg(val);
    add(key, pipe.read_all_as_string());
    }
============================================================
--- src/def_alg.cpp	1d57382fe9d2db420dc1550a8c1afbd116bdfe6e
+++ src/def_alg.cpp	7708b0c2b28d1120b3646952c4c6018ff8cd0100
@@ -8,48 +8,18 @@
 #include <botan/parsing.h>
 
 #include <botan/aes.h>
-#include <botan/blowfish.h>
-#include <botan/cast128.h>
-#include <botan/cast256.h>
-#include <botan/des.h>
-#include <botan/gost.h>
-#include <botan/idea.h>
-#include <botan/kasumi.h>
-#include <botan/lion.h>
-#include <botan/lubyrack.h>
-#include <botan/mars.h>
-#include <botan/misty1.h>
-#include <botan/rc2.h>
-#include <botan/rc5.h>
-#include <botan/rc6.h>
-#include <botan/safer_sk.h>
-#include <botan/seed.h>
-#include <botan/serpent.h>
-#include <botan/skipjack.h>
-#include <botan/square.h>
-#include <botan/tea.h>
-#include <botan/twofish.h>
-#include <botan/xtea.h>
 
-#include <botan/arc4.h>
-#include <botan/turing.h>
-#include <botan/wid_wake.h>
+#include <botan/des.h>
 
 #include <botan/adler32.h>
 #include <botan/crc24.h>
 #include <botan/crc32.h>
-#include <botan/fork256.h>
-#include <botan/has160.h>
-#include <botan/md2.h>
-#include <botan/md4.h>
-#include <botan/md5.h>
-#include <botan/rmd128.h>
+
 #include <botan/rmd160.h>
 #include <botan/sha160.h>
 #include <botan/sha256.h>
 #include <botan/sha_64.h>
-#include <botan/tiger.h>
-#include <botan/whrlpool.h>
+
 #include <botan/par_hash.h>
 
 #include <botan/cbc_mac.h>
@@ -58,7 +28,7 @@
 #include <botan/x919_mac.h>
 
 #include <botan/mode_pad.h>
-#include <botan/pgp_s2k.h>
+
 #include <botan/pkcs5.h>
 
 namespace Botan {
@@ -66,14 +36,57 @@ namespace Botan {
 /*************************************************
 * Some macros to simplify control flow           *
 *************************************************/
-#define HANDLE_TYPE_NO_ARGS(NAME, TYPE)        \
-   if(algo_name == NAME)                       \
-      {                                        \
-      if(name.size() == 1)                     \
-         return new TYPE;                      \
-      throw Invalid_Algorithm_Name(algo_spec); \
+#define HANDLE_TYPE_NO_ARGS_BC(NAME, TYPE)                    \
+   if(algo_name == NAME)                                      \
+      {                                                       \
+      if(name.size() == 1)                                    \
+         return std::tr1::shared_ptr<BlockCipher>(new TYPE);  \
+      throw Invalid_Algorithm_Name(algo_spec);                \
       }
 
+#define HANDLE_TYPE_NO_ARGS_SC(NAME, TYPE)                    \
+   if(algo_name == NAME)                                      \
+      {                                                       \
+      if(name.size() == 1)                                    \
+         return std::tr1::shared_ptr<StreamCipher>(new TYPE); \
+      throw Invalid_Algorithm_Name(algo_spec);                \
+      }
+
+#define HANDLE_TYPE_NO_ARGS_HF(NAME, TYPE)                    \
+   if(algo_name == NAME)                                      \
+      {                                                       \
+      if(name.size() == 1)                                    \
+         return std::tr1::shared_ptr<HashFunction>(new TYPE); \
+      throw Invalid_Algorithm_Name(algo_spec);                \
+      }
+
+#define HANDLE_TYPE_NO_ARGS_MAC(NAME, TYPE)                                 \
+   if(algo_name == NAME)                                                    \
+      {                                                                     \
+      if(name.size() == 1)                                                  \
+         return std::tr1::shared_ptr<MessageAuthenticationCode>(new TYPE);  \
+      throw Invalid_Algorithm_Name(algo_spec);                              \
+      }
+
+#define HANDLE_TYPE_NO_ARGS_S2K(NAME, TYPE)                                 \
+   if(algo_name == NAME)                                                    \
+      {                                                                     \
+      if(name.size() == 1)                                                  \
+         return std::tr1::shared_ptr<S2K>(new TYPE);                        \
+      throw Invalid_Algorithm_Name(algo_spec);                              \
+      }
+
+#define HANDLE_TYPE_NO_ARGS_PM(NAME, TYPE)                                    \
+   if(algo_name == NAME)                                                      \
+      {                                                                       \
+      if(name.size() == 1)                                                    \
+         return std::tr1::shared_ptr<BlockCipherModePaddingMethod>(new TYPE); \
+      throw Invalid_Algorithm_Name(algo_spec);                                \
+      }
+
+
+
+
 #define HANDLE_TYPE_ONE_U32BIT(NAME, TYPE, DEFAULT) \
    if(algo_name == NAME)                            \
       {                                             \
@@ -84,6 +97,8 @@ namespace Botan {
       throw Invalid_Algorithm_Name(algo_spec);      \
       }
 
+
+
 #define HANDLE_TYPE_TWO_U32BIT(NAME, TYPE, DEFAULT)               \
    if(algo_name == NAME)                                          \
       {                                                           \
@@ -96,174 +111,152 @@ namespace Botan {
       throw Invalid_Algorithm_Name(algo_spec);                    \
       }
 
-#define HANDLE_TYPE_ONE_STRING(NAME, TYPE)     \
-   if(algo_name == NAME)                       \
-      {                                        \
-      if(name.size() == 2)                     \
-         return new TYPE(name[1]);             \
+
+
+#define HANDLE_TYPE_ONE_STRING_MAC(NAME, TYPE)                                       \
+   if(algo_name == NAME)                                                             \
+      {                                                                              \
+      if(name.size() == 2)                                                           \
+         return std::tr1::shared_ptr<MessageAuthenticationCode>(new TYPE(name[1]));  \
+      throw Invalid_Algorithm_Name(algo_spec);                                       \
+      }
+
+#define HANDLE_TYPE_ONE_STRING_S2K(NAME, TYPE)                 \
+   if(algo_name == NAME)                                       \
+      {                                                        \
+      if(name.size() == 2)                                     \
+         return std::tr1::shared_ptr<S2K>(new TYPE(name[1]));  \
       throw Invalid_Algorithm_Name(algo_spec); \
       }
 
+
 /*************************************************
 * Look for an algorithm with this name           *
 *************************************************/
-BlockCipher*
+std::tr1::shared_ptr<BlockCipher>
 Default_Engine::find_block_cipher(const std::string& algo_spec) const
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    if(name.empty())
-      return 0;
+      return std::tr1::shared_ptr<BlockCipher>();
    const std::string algo_name = deref_alias(name[0]);
 
-   HANDLE_TYPE_NO_ARGS("AES", AES);
-   HANDLE_TYPE_NO_ARGS("AES-128", AES_128);
-   HANDLE_TYPE_NO_ARGS("AES-192", AES_192);
-   HANDLE_TYPE_NO_ARGS("AES-256", AES_256);
-   HANDLE_TYPE_NO_ARGS("Blowfish", Blowfish);
-   HANDLE_TYPE_NO_ARGS("CAST-128", CAST_128);
-   HANDLE_TYPE_NO_ARGS("CAST-256", CAST_256);
-   HANDLE_TYPE_NO_ARGS("DES", DES);
-   HANDLE_TYPE_NO_ARGS("DESX", DESX);
-   HANDLE_TYPE_NO_ARGS("TripleDES", TripleDES);
-   HANDLE_TYPE_NO_ARGS("GOST", GOST);
-   HANDLE_TYPE_NO_ARGS("IDEA", IDEA);
-   HANDLE_TYPE_NO_ARGS("KASUMI", KASUMI);
-   HANDLE_TYPE_ONE_STRING("Luby-Rackoff", LubyRackoff);
-   HANDLE_TYPE_NO_ARGS("MARS", MARS);
-   HANDLE_TYPE_ONE_U32BIT("MISTY1", MISTY1, 8);
-   HANDLE_TYPE_NO_ARGS("RC2", RC2);
-   HANDLE_TYPE_ONE_U32BIT("RC5", RC5, 12);
-   HANDLE_TYPE_NO_ARGS("RC6", RC6);
-   HANDLE_TYPE_ONE_U32BIT("SAFER-SK", SAFER_SK, 10);
-   HANDLE_TYPE_NO_ARGS("SEED", SEED);
-   HANDLE_TYPE_NO_ARGS("Serpent", Serpent);
-   HANDLE_TYPE_NO_ARGS("Skipjack", Skipjack);
-   HANDLE_TYPE_NO_ARGS("Square", Square);
-   HANDLE_TYPE_NO_ARGS("TEA", TEA);
-   HANDLE_TYPE_NO_ARGS("Twofish", Twofish);
-   HANDLE_TYPE_NO_ARGS("XTEA", XTEA);
+   HANDLE_TYPE_NO_ARGS_BC("AES", AES);
+   HANDLE_TYPE_NO_ARGS_BC("AES-128", AES_128);
+   HANDLE_TYPE_NO_ARGS_BC("AES-192", AES_192);
+   HANDLE_TYPE_NO_ARGS_BC("AES-256", AES_256);
 
-   if(algo_name == "Lion")
-      {
-      if(name.size() != 4)
-         throw Invalid_Algorithm_Name(algo_spec);
-      return new Lion(name[1], name[2], to_u32bit(name[3]));
-      }
-   return 0;
+   HANDLE_TYPE_NO_ARGS_BC("DES", DES);
+   HANDLE_TYPE_NO_ARGS_BC("DESX", DESX);
+   HANDLE_TYPE_NO_ARGS_BC("TripleDES", TripleDES);
+
+   return std::tr1::shared_ptr<BlockCipher>();
    }
 
 /*************************************************
 * Look for an algorithm with this name           *
 *************************************************/
-StreamCipher*
+std::tr1::shared_ptr<StreamCipher>
 Default_Engine::find_stream_cipher(const std::string& algo_spec) const
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    if(name.empty())
-      return 0;
+      return std::tr1::shared_ptr<StreamCipher>();
    const std::string algo_name = deref_alias(name[0]);
 
-   HANDLE_TYPE_ONE_U32BIT("ARC4", ARC4, 0);
-   HANDLE_TYPE_ONE_U32BIT("RC4_drop", ARC4, 768);
-   HANDLE_TYPE_NO_ARGS("Turing", Turing);
-   HANDLE_TYPE_NO_ARGS("WiderWake4+1-BE", WiderWake_41_BE);
-
-   return 0;
+   return std::tr1::shared_ptr<StreamCipher>();
    }
 
 /*************************************************
 * Look for an algorithm with this name           *
 *************************************************/
-HashFunction*
+std::tr1::shared_ptr<HashFunction>
 Default_Engine::find_hash(const std::string& algo_spec) const
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    if(name.empty())
-      return 0;
+      return std::tr1::shared_ptr<HashFunction>();
    const std::string algo_name = deref_alias(name[0]);
 
-   HANDLE_TYPE_NO_ARGS("Adler32", Adler32);
-   HANDLE_TYPE_NO_ARGS("CRC24", CRC24);
-   HANDLE_TYPE_NO_ARGS("CRC32", CRC32);
-   HANDLE_TYPE_NO_ARGS("FORK-256", FORK_256);
-   HANDLE_TYPE_NO_ARGS("HAS-160", HAS_160);
-   HANDLE_TYPE_NO_ARGS("MD2", MD2);
-   HANDLE_TYPE_NO_ARGS("MD4", MD4);
-   HANDLE_TYPE_NO_ARGS("MD5", MD5);
-   HANDLE_TYPE_NO_ARGS("RIPEMD-128", RIPEMD_128);
-   HANDLE_TYPE_NO_ARGS("RIPEMD-160", RIPEMD_160);
-   HANDLE_TYPE_NO_ARGS("SHA-160", SHA_160);
-   HANDLE_TYPE_NO_ARGS("SHA-256", SHA_256);
-   HANDLE_TYPE_NO_ARGS("SHA-384", SHA_384);
-   HANDLE_TYPE_NO_ARGS("SHA-512", SHA_512);
-   HANDLE_TYPE_TWO_U32BIT("Tiger", Tiger, 24);
-   HANDLE_TYPE_NO_ARGS("Whirlpool", Whirlpool);
+   HANDLE_TYPE_NO_ARGS_HF("Adler32", Adler32);
+   HANDLE_TYPE_NO_ARGS_HF("CRC24", CRC24);
+   HANDLE_TYPE_NO_ARGS_HF("CRC32", CRC32);
 
+   HANDLE_TYPE_NO_ARGS_HF("RIPEMD-160", RIPEMD_160);
+
+   HANDLE_TYPE_NO_ARGS_HF("SHA-160", SHA_160);
+   HANDLE_TYPE_NO_ARGS_HF("SHA-224", SHA_224);
+   HANDLE_TYPE_NO_ARGS_HF("SHA-256", SHA_256);
+   HANDLE_TYPE_NO_ARGS_HF("SHA-384", SHA_384);
+   HANDLE_TYPE_NO_ARGS_HF("SHA-512", SHA_512);
+
+
    if(algo_name == "Parallel")
       {
       if(name.size() < 2)
          throw Invalid_Algorithm_Name(algo_spec);
       name.erase(name.begin());
-      return new Parallel(name);
+      return std::tr1::shared_ptr<HashFunction>(new Parallel(name));
       }
-   return 0;
+   return std::tr1::shared_ptr<HashFunction>();
    }
 
 /*************************************************
 * Look for an algorithm with this name           *
 *************************************************/
-MessageAuthenticationCode*
+std::tr1::shared_ptr<MessageAuthenticationCode>
 Default_Engine::find_mac(const std::string& algo_spec) const
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    if(name.empty())
-      return 0;
+      return std::tr1::shared_ptr<MessageAuthenticationCode>();
    const std::string algo_name = deref_alias(name[0]);
 
-   HANDLE_TYPE_ONE_STRING("CBC-MAC", CBC_MAC);
-   HANDLE_TYPE_ONE_STRING("CMAC", CMAC);
-   HANDLE_TYPE_ONE_STRING("HMAC", HMAC);
-   HANDLE_TYPE_NO_ARGS("X9.19-MAC", ANSI_X919_MAC);
+   HANDLE_TYPE_ONE_STRING_MAC("CBC-MAC", CBC_MAC);
+   HANDLE_TYPE_ONE_STRING_MAC("CMAC", CMAC);
+   HANDLE_TYPE_ONE_STRING_MAC("HMAC", HMAC);
+   HANDLE_TYPE_NO_ARGS_MAC("X9.19-MAC", ANSI_X919_MAC);
 
-   return 0;
+   return std::tr1::shared_ptr<MessageAuthenticationCode>();
    }
 
 /*************************************************
 * Look for an algorithm with this name           *
 *************************************************/
-S2K* Default_Engine::find_s2k(const std::string& algo_spec) const
+
+std::tr1::shared_ptr<S2K>
+Default_Engine::find_s2k(const std::string& algo_spec) const
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    if(name.empty())
-      return 0;
+      return std::tr1::shared_ptr<S2K>();
 
    const std::string algo_name = deref_alias(name[0]);
 
-   HANDLE_TYPE_ONE_STRING("PBKDF1", PKCS5_PBKDF1);
-   HANDLE_TYPE_ONE_STRING("PBKDF2", PKCS5_PBKDF2);
-   HANDLE_TYPE_ONE_STRING("OpenPGP-S2K", OpenPGP_S2K);
+   HANDLE_TYPE_ONE_STRING_S2K("PBKDF1", PKCS5_PBKDF1);
+   HANDLE_TYPE_ONE_STRING_S2K("PBKDF2", PKCS5_PBKDF2);
 
-   return 0;
+
+   return std::tr1::shared_ptr<S2K>();
    }
-
 /*************************************************
 * Look for an algorithm with this name           *
 *************************************************/
-BlockCipherModePaddingMethod*
+std::tr1::shared_ptr<BlockCipherModePaddingMethod>
 Default_Engine::find_bc_pad(const std::string& algo_spec) const
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    if(name.empty())
-      return 0;
+      return std::tr1::shared_ptr<BlockCipherModePaddingMethod>();
 
    const std::string algo_name = deref_alias(name[0]);
 
-   HANDLE_TYPE_NO_ARGS("PKCS7",       PKCS7_Padding);
-   HANDLE_TYPE_NO_ARGS("OneAndZeros", OneAndZeros_Padding);
-   HANDLE_TYPE_NO_ARGS("X9.23",       ANSI_X923_Padding);
-   HANDLE_TYPE_NO_ARGS("NoPadding",   Null_Padding);
+   HANDLE_TYPE_NO_ARGS_PM("PKCS7",       PKCS7_Padding);
+   HANDLE_TYPE_NO_ARGS_PM("OneAndZeros", OneAndZeros_Padding);
+   HANDLE_TYPE_NO_ARGS_PM("X9.23",       ANSI_X923_Padding);
+   HANDLE_TYPE_NO_ARGS_PM("NoPadding",   Null_Padding);
 
-   return 0;
+   return std::tr1::shared_ptr<BlockCipherModePaddingMethod>();
    }
 
 }
============================================================
--- src/def_char.cpp	9d0a75ae7178a2423bb4e1a0f11473f8231b8cc4
+++ src/def_char.cpp	249adf0e4a263802168689ab03c731058a4dcd85
@@ -83,8 +83,8 @@ std::string latin1_to_utf8(const std::st
          utf8 += static_cast<char>(c);
       else
          {
-         utf8 += static_cast<char>((0xC0 | (c >> 6)));
-         utf8 += static_cast<char>((0x80 | (c & 0x3F)));
+         	utf8 += static_cast<char>((0xC0 | (c >> 6)));
+         	utf8 += static_cast<char>((0x80 | (c & 0x3F)));
          }
       }
    return utf8;
============================================================
--- src/def_mode.cpp	691cb0c3bff70d8d74df99cdde4c9e155687bc3e
+++ src/def_mode.cpp	20075ee611f4e270ec4dd678134cf7998258c20b
@@ -20,9 +20,11 @@ namespace Botan {
 /*************************************************
 * Get a cipher object                            *
 *************************************************/
-Keyed_Filter* Default_Engine::get_cipher(const std::string& algo_spec,
-                                         Cipher_Dir direction)
+Engine::Keyed_Filter_Ptr
+Default_Engine::get_cipher(const std::string& algo_spec,
+                           Cipher_Dir direction)
    {
+
    std::vector<std::string> algo_parts = split_on(algo_spec, '/');
    if(algo_parts.empty())
       throw Invalid_Algorithm_Name(algo_spec);
@@ -32,13 +34,13 @@ Keyed_Filter* Default_Engine::get_cipher
    if(have_stream_cipher(cipher))
       {
       if(algo_parts.size() == 1)
-         return new StreamCipher_Filter(cipher);
-      return 0;
+        return create_shared_ptr<StreamCipher_Filter>(cipher);
+      return Engine::Keyed_Filter_Ptr();
       }
    else if(have_block_cipher(cipher))
       {
       if(algo_parts.size() != 2 && algo_parts.size() != 3)
-         return 0;
+         return Engine::Keyed_Filter_Ptr();
 
       std::string mode = algo_parts[1];
       u32bit bits = 0;
@@ -63,61 +65,61 @@ Keyed_Filter* Default_Engine::get_cipher
          padding = (mode == "CBC") ? "PKCS7" : "NoPadding";
 
       if(mode == "ECB" && padding == "CTS")
-         return 0;
+         return Engine::Keyed_Filter_Ptr();
       else if((mode != "CBC" && mode != "ECB") && padding != "NoPadding")
          throw Invalid_Algorithm_Name(algo_spec);
 
       if(mode == "OFB")
-         return new OFB(cipher);
+        return create_shared_ptr<OFB>(cipher);
       else if(mode == "CTR-BE")
-         return new CTR_BE(cipher);
+        return create_shared_ptr<CTR_BE>(cipher);
       else if(mode == "ECB" || mode == "CBC" || mode == "CTS" ||
               mode == "CFB" || mode == "EAX")
          {
          if(mode == "ECB")
             {
             if(direction == ENCRYPTION)
-               return new ECB_Encryption(cipher, padding);
+               return create_shared_ptr<ECB_Encryption>(cipher, padding);
             else
-               return new ECB_Decryption(cipher, padding);
+               return create_shared_ptr<ECB_Decryption>(cipher, padding);
             }
          else if(mode == "CFB")
             {
             if(direction == ENCRYPTION)
-               return new CFB_Encryption(cipher, bits);
+               return create_shared_ptr<CFB_Encryption>(cipher, bits);
             else
-               return new CFB_Decryption(cipher, bits);
+               return create_shared_ptr<CFB_Decryption>(cipher, bits);
             }
          else if(mode == "CBC")
             {
             if(padding == "CTS")
                {
                if(direction == ENCRYPTION)
-                  return new CTS_Encryption(cipher);
+                  return create_shared_ptr<CTS_Encryption>(cipher);
                else
-                  return new CTS_Decryption(cipher);
+                  return create_shared_ptr<CTS_Decryption>(cipher);
                }
             if(direction == ENCRYPTION)
-               return new CBC_Encryption(cipher, padding);
+               return create_shared_ptr<CBC_Encryption>(cipher, padding);
             else
-               return new CBC_Decryption(cipher, padding);
+               return create_shared_ptr<CBC_Decryption>(cipher, padding);
             }
          else if(mode == "EAX")
             {
             if(direction == ENCRYPTION)
-               return new EAX_Encryption(cipher, bits);
+               return create_shared_ptr<EAX_Encryption>(cipher, bits);
             else
-               return new EAX_Decryption(cipher, bits);
+               return create_shared_ptr<EAX_Decryption>(cipher, bits);
             }
          else
             throw Internal_Error("get_mode: " + cipher + "/"
                                               + mode + "/" + padding);
          }
       else
-         return 0;
+         return Engine::Keyed_Filter_Ptr();
       }
 
-   return 0;
+   return Engine::Keyed_Filter_Ptr();
    }
 
 }
============================================================
--- src/def_ops.cpp	5c9ed9b4ab2a62b38445ba340f5920b6dd8ba5e1
+++ src/def_ops.cpp	92370dab81f21c305be2620f2b6c067813f39d0f
@@ -4,10 +4,21 @@
 *************************************************/
 
 #include <botan/eng_def.h>
-#include <botan/pow_mod.h>
-#include <botan/numthry.h>
-#include <botan/reducer.h>
+#include <botan/bigintfuncs.h>
+#include <botan/bigint/reducer.h>
+#include <botan/bigint/pow_mod.h>
+#include <botan/ec_dompar.h>
+#include <botan/ecdsa.h>
+#include <botan/gf/gfp_element.h>
+#ifdef TA_COLL_T
+#include <botan/ta.h>
+#endif
+#include <assert.h>
 
+
+using namespace Botan::math;
+using namespace Botan::math::ec;
+
 namespace Botan {
 
 namespace {
@@ -22,7 +33,9 @@ class Default_IF_Op : public IF_Operatio
          { return powermod_e_n(i); }
       BigInt private_op(const BigInt&) const;
 
-      IF_Operation* clone() const { return new Default_IF_Op(*this); }
+      std::auto_ptr<IF_Operation> clone() const {
+    	  return std::auto_ptr<IF_Operation>(new Default_IF_Op(*this));
+      }
 
       Default_IF_Op(const BigInt&, const BigInt&, const BigInt&,
                     const BigInt&, const BigInt&, const BigInt&,
@@ -70,6 +83,7 @@ BigInt Default_IF_Op::private_op(const B
 /*************************************************
 * Default DSA Operation                          *
 *************************************************/
+/*
 class Default_DSA_Op : public DSA_Operation
    {
    public:
@@ -85,10 +99,11 @@ class Default_DSA_Op : public DSA_Operat
       Fixed_Base_Power_Mod powermod_g_p, powermod_y_p;
       Modular_Reducer mod_p, mod_q;
    };
-
+*/
 /*************************************************
 * Default_DSA_Op Constructor                     *
 *************************************************/
+/*
 Default_DSA_Op::Default_DSA_Op(const DL_Group& grp, const BigInt& y1,
                                const BigInt& x1) : x(x1), y(y1), group(grp)
    {
@@ -97,10 +112,11 @@ Default_DSA_Op::Default_DSA_Op(const DL_
    mod_p = Modular_Reducer(group.get_p());
    mod_q = Modular_Reducer(group.get_q());
    }
-
+*/
 /*************************************************
 * Default DSA Verify Operation                   *
 *************************************************/
+/*
 bool Default_DSA_Op::verify(const byte msg[], u32bit msg_len,
                             const byte sig[], u32bit sig_len) const
    {
@@ -122,10 +138,11 @@ bool Default_DSA_Op::verify(const byte m
 
    return (mod_q.reduce(s) == r);
    }
-
+*/
 /*************************************************
 * Default DSA Sign Operation                     *
 *************************************************/
+/*
 SecureVector<byte> Default_DSA_Op::sign(const byte in[], u32bit length,
                                         const BigInt& k) const
    {
@@ -146,10 +163,11 @@ SecureVector<byte> Default_DSA_Op::sign(
    s.binary_encode(output + (output.size() - s.bytes()));
    return output;
    }
-
+*/
 /*************************************************
 * Default NR Operation                           *
 *************************************************/
+/*
 class Default_NR_Op : public NR_Operation
    {
    public:
@@ -165,10 +183,11 @@ class Default_NR_Op : public NR_Operatio
       Fixed_Base_Power_Mod powermod_g_p, powermod_y_p;
       Modular_Reducer mod_p, mod_q;
    };
-
+*/
 /*************************************************
 * Default_NR_Op Constructor                      *
 *************************************************/
+/*
 Default_NR_Op::Default_NR_Op(const DL_Group& grp, const BigInt& y1,
                              const BigInt& x1) : x(x1), y(y1), group(grp)
    {
@@ -177,10 +196,11 @@ Default_NR_Op::Default_NR_Op(const DL_Gr
    mod_p = Modular_Reducer(group.get_p());
    mod_q = Modular_Reducer(group.get_q());
    }
-
+*/
 /*************************************************
 * Default NR Verify Operation                    *
 *************************************************/
+/*
 SecureVector<byte> Default_NR_Op::verify(const byte in[], u32bit length) const
    {
    const BigInt& q = group.get_q();
@@ -197,10 +217,11 @@ SecureVector<byte> Default_NR_Op::verify
    BigInt i = mod_p.multiply(powermod_g_p(d), powermod_y_p(c));
    return BigInt::encode(mod_q.reduce(c - i));
    }
-
+*/
 /*************************************************
 * Default NR Sign Operation                      *
 *************************************************/
+/*
 SecureVector<byte> Default_NR_Op::sign(const byte in[], u32bit length,
                                        const BigInt& k) const
    {
@@ -224,10 +245,11 @@ SecureVector<byte> Default_NR_Op::sign(c
    d.binary_encode(output + (output.size() - d.bytes()));
    return output;
    }
-
+*/
 /*************************************************
 * Default ElGamal Operation                      *
 *************************************************/
+/*
 class Default_ELG_Op : public ELG_Operation
    {
    public:
@@ -243,10 +265,11 @@ class Default_ELG_Op : public ELG_Operat
       Fixed_Exponent_Power_Mod powermod_x_p;
       Modular_Reducer mod_p;
    };
-
+*/
 /*************************************************
 * Default_ELG_Op Constructor                     *
 *************************************************/
+/*
 Default_ELG_Op::Default_ELG_Op(const DL_Group& group, const BigInt& y,
                                const BigInt& x) : p(group.get_p())
    {
@@ -257,10 +280,11 @@ Default_ELG_Op::Default_ELG_Op(const DL_
    if(x != 0)
       powermod_x_p = Fixed_Exponent_Power_Mod(x, p);
    }
-
+*/
 /*************************************************
 * Default ElGamal Encrypt Operation              *
 *************************************************/
+/*
 SecureVector<byte> Default_ELG_Op::encrypt(const byte in[], u32bit length,
                                            const BigInt& k) const
    {
@@ -276,10 +300,11 @@ SecureVector<byte> Default_ELG_Op::encry
    b.binary_encode(output + output.size() / 2 + (p.bytes() - b.bytes()));
    return output;
    }
-
+*/
 /*************************************************
 * Default ElGamal Decrypt Operation              *
 *************************************************/
+/*
 BigInt Default_ELG_Op::decrypt(const BigInt& a, const BigInt& b) const
    {
    if(a >= p || b >= p)
@@ -287,7 +312,7 @@ BigInt Default_ELG_Op::decrypt(const Big
 
    return mod_p.multiply(b, inverse_mod(powermod_x_p(a), p));
    }
-
+*/
 /*************************************************
 * Default DH Operation                           *
 *************************************************/
@@ -295,7 +320,9 @@ class Default_DH_Op : public DH_Operatio
    {
    public:
       BigInt agree(const BigInt& i) const { return powermod_x_p(i); }
-      DH_Operation* clone() const { return new Default_DH_Op(*this); }
+      std::auto_ptr<DH_Operation> clone() const {
+    	  return std::auto_ptr<DH_Operation>(new Default_DH_Op(*this));
+      }
 
       Default_DH_Op(const DL_Group& group, const BigInt& x) :
          powermod_x_p(x, group.get_p()) {}
@@ -303,53 +330,250 @@ class Default_DH_Op : public DH_Operatio
       const Fixed_Exponent_Power_Mod powermod_x_p;
    };
 
+/*************************************************
+* Default ECDSA operation                        *
+*************************************************/
+class Default_ECDSA_Op : public ECDSA_Operation
+    {
+    public:
+        bool const verify(const byte signature[], u32bit sig_len, const byte message[], u32bit mess_len) const;
+
+        SecureVector<byte> const sign(const byte message[], u32bit mess_len) const;
+
+        std::auto_ptr<ECDSA_Operation> clone() const {
+            return std::auto_ptr<ECDSA_Operation>(new Default_ECDSA_Op(*this));
+            }
+
+        Default_ECDSA_Op(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key);
+      private:
+              Botan::EC_Domain_Params m_dom_pars;
+              PointGFp m_pub_key;
+              BigInt m_priv_key;
+
+      };
+
+      bool const Default_ECDSA_Op::verify(const byte signature[], u32bit sig_len, const byte message[], u32bit mess_len) const
+      {
+          //NOTE: it is not checked whether the public point is set
+          if(m_dom_pars.get_curve().get_p() == 0)
+          {
+            throw Internal_Error("domain parameters not set");
+          }
+          BigInt e(message, mess_len);
+          if(sig_len % 2 != 0)
+          {
+              throw Invalid_Argument("Erroneous length of signature");
+          }
+          u32bit rs_len = sig_len/2;
+          SecureVector<byte> sv_r;
+          SecureVector<byte> sv_s;
+          sv_r.set(signature, rs_len);
+          sv_s.set(signature+rs_len, rs_len);
+          BigInt r = BigInt::decode ( sv_r, sv_r.size());
+          BigInt s = BigInt::decode (sv_s, sv_s.size());
+
+          if(r < 0 || r >= m_dom_pars.get_order())
+          {
+           throw Invalid_Argument("r in ECDSA signature has an illegal value");
+          }
+          if(s < 0 || s >= m_dom_pars.get_order())
+          {
+              throw Invalid_Argument("s in ECDSA signature has an illegal value");
+          }
+
+          BigInt w = inverse_mod(s, m_dom_pars.get_order());
+          PointGFp R = w*(e*m_dom_pars.get_base_point() + r*m_pub_key);
+          if(R.is_zero())
+          {
+           return false;
+          }
+          BigInt x = R.get_affine_x().get_value();
+          bool result = (x % m_dom_pars.get_order() == r);
+          return result;
+      }
+      SecureVector<byte> const Default_ECDSA_Op::sign(const byte message[], u32bit mess_len) const
+      {
+           if(m_priv_key == 0)
+           {
+               throw Internal_Error("Default_ECDSA_Op::sign(): no private key");
+           }
+           if(m_dom_pars.get_curve().get_p() == 0)
+           {
+               throw Internal_Error("Default_ECDSA_Op::sign(): domain parameters not set");
+           }
+
+           BigInt e(message, mess_len);
+
+           // generate k
+           BigInt k;
+           BigInt r(0);
+           const BigInt n(m_dom_pars.get_order());
+         while(r == 0)
+         {
+               k = random_integer(1,n);
+
+               PointGFp k_times_P(m_dom_pars.get_base_point());
+               k_times_P.mult_this_secure(k, n, n-1);
+               k_times_P.check_invariants();
+               r =  k_times_P.get_affine_x().get_value() % n;
+         }
+           BigInt k_inv = inverse_mod(k, n);
+
+           // use randomization against attacks on s:
+           // a = k_inv * (r*(d + x) + e) mod n
+           // b = k_inv * r * x mod n
+           // s = a - b mod n
+           // where x is a random integer
+           #ifdef CMS_RAND
+           BigInt x = Botan::random_integer(0, n);
+           BigInt s = m_priv_key + x; // obscure the secret from the beginning
+                            // all following operations thus are randomized
+           s *= r;
+           s += e;
+           s *= k_inv;
+           s %= n;
+
+           BigInt b = x; // again, start with the random number
+           b *= r;
+           b *= k_inv;
+           b %= n;
+           s -= b; // s = a - b
+           if(s <= 0) // s %= n
+           {
+            s += n;
+           }
+           #else // CMS_RAND
+           // no countermeasure here
+           BigInt s(r);
+           s *= m_priv_key;
+           s += e;
+           s *= k_inv;
+           s %= n;
+
+           #endif // CMS_RAND
+
+           SecureVector<byte> sv_r = BigInt::encode_1363 ( r, m_dom_pars.get_order().bytes() );
+           SecureVector<byte> sv_s = BigInt::encode_1363 ( s, m_dom_pars.get_order().bytes() );
+
+           SecureVector<byte> result(sv_r);
+           result.append(sv_s);
+           return result;
+      }
+      Default_ECDSA_Op::Default_ECDSA_Op(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key)
+    : m_dom_pars(dom_pars),
+      m_pub_key(pub_key),
+      m_priv_key(priv_key)
+      {
+
+      }
+
+      /*************************************************
+      * Default ECKAEG operation                        *
+      *************************************************/
+         class Default_ECKAEG_Op : public ECKAEG_Operation
+         {
+         public:
+             SecureVector<byte> agree(const PointGFp& i) const;
+
+             std::auto_ptr<ECKAEG_Operation> clone() const {
+                return std::auto_ptr<ECKAEG_Operation>(new Default_ECKAEG_Op(*this));
+            }
+
+            Default_ECKAEG_Op(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key);
+         private:
+             Botan::EC_Domain_Params m_dom_pars;
+             PointGFp m_pub_key;
+             BigInt m_priv_key;
+
+         };
+
+         Default_ECKAEG_Op::Default_ECKAEG_Op(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key)
+          : m_dom_pars(dom_pars),
+            m_pub_key(pub_key),
+            m_priv_key(priv_key)
+         {
+
+         }
+         SecureVector<byte> Default_ECKAEG_Op::agree(const PointGFp& i) const
+         {
+             BigInt cofactor(m_dom_pars.get_cofactor());
+             BigInt n = m_dom_pars.get_order();
+             BigInt l(inverse_mod(cofactor,n)); // l=h^-1 mod n
+             PointGFp Q(cofactor*i); // q = h*Pb
+             PointGFp S(Q);
+             BigInt group_order = m_dom_pars.get_cofactor() * n;
+             S.mult_this_secure((m_priv_key*l)%n, group_order, n-1);
+             S.check_invariants();
+             return FE2OSP(S.get_affine_x()); // fe2os(xs)
+         }
+
 }
 
 /*************************************************
 * Acquire an IF op                               *
 *************************************************/
-IF_Operation* Default_Engine::if_op(const BigInt& e, const BigInt& n,
+std::tr1::shared_ptr<IF_Operation> Default_Engine::if_op(const BigInt& e, const BigInt& n,
                                     const BigInt& d, const BigInt& p,
                                     const BigInt& q, const BigInt& d1,
                                     const BigInt& d2, const BigInt& c) const
    {
-   return new Default_IF_Op(e, n, d, p, q, d1, d2, c);
+   return std::tr1::shared_ptr<IF_Operation>(new Default_IF_Op(e, n, d, p, q, d1, d2, c));
    }
 
 /*************************************************
 * Acquire a DSA op                               *
 *************************************************/
+/*
 DSA_Operation* Default_Engine::dsa_op(const DL_Group& group, const BigInt& y,
                                       const BigInt& x) const
    {
    return new Default_DSA_Op(group, y, x);
    }
-
+*/
 /*************************************************
 * Acquire a NR op                                *
 *************************************************/
+/*
 NR_Operation* Default_Engine::nr_op(const DL_Group& group, const BigInt& y,
                                     const BigInt& x) const
    {
    return new Default_NR_Op(group, y, x);
    }
-
+*/
 /*************************************************
 * Acquire an ElGamal op                          *
 *************************************************/
+/*
 ELG_Operation* Default_Engine::elg_op(const DL_Group& group, const BigInt& y,
                                       const BigInt& x) const
    {
    return new Default_ELG_Op(group, y, x);
    }
-
+*/
 /*************************************************
 * Acquire a DH op                                *
 *************************************************/
-DH_Operation* Default_Engine::dh_op(const DL_Group& group,
+std::tr1::shared_ptr<DH_Operation> Default_Engine::dh_op(const DL_Group& group,
                                     const BigInt& x) const
    {
-   return new Default_DH_Op(group, x);
+   return std::tr1::shared_ptr<DH_Operation>(new Default_DH_Op(group, x));
    }
 
+/*************************************************
+* Acquire a ECKAEG op                            *
+*************************************************/
+std::tr1::shared_ptr<ECKAEG_Operation> Default_Engine::eckaeg_op(EC_Domain_Params const& dom_pars,
+        BigInt const& priv_key, PointGFp const& pub_key) const
+ {
+     return std::tr1::shared_ptr<ECKAEG_Operation>(new Default_ECKAEG_Op(dom_pars,
+             priv_key, pub_key));
+ }
+
+   std::tr1::shared_ptr<ECDSA_Operation> Default_Engine::ecdsa_op(EC_Domain_Params const& dom_pars,
+           BigInt const& priv_key, PointGFp const& pub_key) const
+    {
+        return std::tr1::shared_ptr<ECDSA_Operation>(new Default_ECDSA_Op(dom_pars,
+                priv_key, pub_key));
+    }
+
 }
============================================================
--- src/def_powm.cpp	ca58e34d3b5679bc60ced7813df3a350ca3f577f
+++ src/def_powm.cpp	5c88ab1b0a5b5947b67880826cbcf0182b21bdf9
@@ -4,19 +4,22 @@
 *************************************************/
 
 #include <botan/eng_def.h>
-#include <botan/def_powm.h>
+#include <botan/bigint/def_powm.h>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
 * Choose a modular exponentation algorithm       *
 *************************************************/
-Modular_Exponentiator*
+std::auto_ptr<Modular_Exponentiator>
 Default_Engine::mod_exp(const BigInt& n, Power_Mod::Usage_Hints hints) const
    {
    if(n.is_odd())
-      return new Montgomery_Exponentiator(n, hints);
-   return new Fixed_Window_Exponentiator(n, hints);
+      return std::auto_ptr<Modular_Exponentiator>(new Montgomery_Exponentiator(n, hints));
+   return std::auto_ptr<Modular_Exponentiator>(new Fixed_Window_Exponentiator(n, hints));
    }
 
 }
============================================================
--- src/defalloc.cpp	940db8ef03ae170341d257f9f7e4320ee3938935
+++ src/defalloc.cpp	013168053edc9c815d058eb4e5dfe95bcc2d1f02
@@ -21,7 +21,11 @@ void* do_malloc(u32bit n, bool do_lock)
    void* ptr = std::malloc(n);
 
    if(!ptr)
-      return 0;
+   {
+       throw Memory_Exhaustion();
+       //  return 0;
+   }
+    
 
    if(do_lock)
       lock_mem(ptr, n);
@@ -82,13 +86,13 @@ void Locking_Allocator::dealloc_block(vo
 /*************************************************
 * Get an allocator                               *
 *************************************************/
-Allocator* Allocator::get(bool locking)
+std::tr1::shared_ptr<Allocator> Allocator::get(bool locking)
    {
    std::string type = "";
    if(!locking)
       type = "malloc";
 
-   Allocator* alloc = global_state().get_allocator(type);
+   std::tr1::shared_ptr<Allocator> alloc = global_state().get_allocator(type);
    if(alloc)
       return alloc;
 
============================================================
--- src/der_enc.cpp	431f71f58e378c7de52d0f540e5271fe705f5e65
+++ src/der_enc.cpp	755cc7fe13aaecd1bc07c5c39db49713ef0e12ae
@@ -5,10 +5,11 @@
 
 #include <botan/der_enc.h>
 #include <botan/asn1_int.h>
+#include <botan/parsing.h>
+#include <algorithm>
 #include <botan/bigint.h>
 #include <botan/bit_ops.h>
-#include <botan/parsing.h>
-#include <algorithm>
+using namespace Botan::math;
 
 namespace Botan {
 
@@ -25,7 +26,7 @@ SecureVector<byte> encode_tag(ASN1_Tag t
 
    SecureVector<byte> encoded_tag;
    if(type_tag <= 30)
-      encoded_tag.append(static_cast<byte>(type_tag | class_tag));
+   	  encoded_tag.append(static_cast<byte>(type_tag | class_tag));
    else
       {
       u32bit blocks = high_bit(type_tag) + 6;
============================================================
--- src/des.cpp	b4b952183124098874fc21851366dfec58fdd8de
+++ src/des.cpp	8bce086afe9166bda6cda643a55e1f8eb5237141
@@ -186,7 +186,7 @@ void TripleDES::enc(const byte in[], byt
 void TripleDES::enc(const byte in[], byte out[]) const
    {
    u32bit L = load_be<u32bit>(in, 0), R = load_be<u32bit>(in, 1);
-
+   
    DES::IP(L, R);
    des1.raw_encrypt(L, R);
    des2.raw_decrypt(R, L);
============================================================
--- src/des_tab.cpp	46b05668500c5e0d8f22409c0aa9800f1bbbd3d7
+++ src/des_tab.cpp	52ebd23f08f7a059e0df41ce21b3c88e1f1e2f76
@@ -368,267 +368,267 @@ const u64bit DES::IPTAB1[256] = {
    0x00001040, 0x00040040, 0x10000000, 0x10041000 };
 
 const u64bit DES::IPTAB1[256] = {
-0x0000000000000000, 0x0000000200000000, 0x0000000000000002, 0x0000000200000002,
-0x0000020000000000, 0x0000020200000000, 0x0000020000000002, 0x0000020200000002,
-0x0000000000000200, 0x0000000200000200, 0x0000000000000202, 0x0000000200000202,
-0x0000020000000200, 0x0000020200000200, 0x0000020000000202, 0x0000020200000202,
-0x0002000000000000, 0x0002000200000000, 0x0002000000000002, 0x0002000200000002,
-0x0002020000000000, 0x0002020200000000, 0x0002020000000002, 0x0002020200000002,
-0x0002000000000200, 0x0002000200000200, 0x0002000000000202, 0x0002000200000202,
-0x0002020000000200, 0x0002020200000200, 0x0002020000000202, 0x0002020200000202,
-0x0000000000020000, 0x0000000200020000, 0x0000000000020002, 0x0000000200020002,
-0x0000020000020000, 0x0000020200020000, 0x0000020000020002, 0x0000020200020002,
-0x0000000000020200, 0x0000000200020200, 0x0000000000020202, 0x0000000200020202,
-0x0000020000020200, 0x0000020200020200, 0x0000020000020202, 0x0000020200020202,
-0x0002000000020000, 0x0002000200020000, 0x0002000000020002, 0x0002000200020002,
-0x0002020000020000, 0x0002020200020000, 0x0002020000020002, 0x0002020200020002,
-0x0002000000020200, 0x0002000200020200, 0x0002000000020202, 0x0002000200020202,
-0x0002020000020200, 0x0002020200020200, 0x0002020000020202, 0x0002020200020202,
-0x0200000000000000, 0x0200000200000000, 0x0200000000000002, 0x0200000200000002,
-0x0200020000000000, 0x0200020200000000, 0x0200020000000002, 0x0200020200000002,
-0x0200000000000200, 0x0200000200000200, 0x0200000000000202, 0x0200000200000202,
-0x0200020000000200, 0x0200020200000200, 0x0200020000000202, 0x0200020200000202,
-0x0202000000000000, 0x0202000200000000, 0x0202000000000002, 0x0202000200000002,
-0x0202020000000000, 0x0202020200000000, 0x0202020000000002, 0x0202020200000002,
-0x0202000000000200, 0x0202000200000200, 0x0202000000000202, 0x0202000200000202,
-0x0202020000000200, 0x0202020200000200, 0x0202020000000202, 0x0202020200000202,
-0x0200000000020000, 0x0200000200020000, 0x0200000000020002, 0x0200000200020002,
-0x0200020000020000, 0x0200020200020000, 0x0200020000020002, 0x0200020200020002,
-0x0200000000020200, 0x0200000200020200, 0x0200000000020202, 0x0200000200020202,
-0x0200020000020200, 0x0200020200020200, 0x0200020000020202, 0x0200020200020202,
-0x0202000000020000, 0x0202000200020000, 0x0202000000020002, 0x0202000200020002,
-0x0202020000020000, 0x0202020200020000, 0x0202020000020002, 0x0202020200020002,
-0x0202000000020200, 0x0202000200020200, 0x0202000000020202, 0x0202000200020202,
-0x0202020000020200, 0x0202020200020200, 0x0202020000020202, 0x0202020200020202,
-0x0000000002000000, 0x0000000202000000, 0x0000000002000002, 0x0000000202000002,
-0x0000020002000000, 0x0000020202000000, 0x0000020002000002, 0x0000020202000002,
-0x0000000002000200, 0x0000000202000200, 0x0000000002000202, 0x0000000202000202,
-0x0000020002000200, 0x0000020202000200, 0x0000020002000202, 0x0000020202000202,
-0x0002000002000000, 0x0002000202000000, 0x0002000002000002, 0x0002000202000002,
-0x0002020002000000, 0x0002020202000000, 0x0002020002000002, 0x0002020202000002,
-0x0002000002000200, 0x0002000202000200, 0x0002000002000202, 0x0002000202000202,
-0x0002020002000200, 0x0002020202000200, 0x0002020002000202, 0x0002020202000202,
-0x0000000002020000, 0x0000000202020000, 0x0000000002020002, 0x0000000202020002,
-0x0000020002020000, 0x0000020202020000, 0x0000020002020002, 0x0000020202020002,
-0x0000000002020200, 0x0000000202020200, 0x0000000002020202, 0x0000000202020202,
-0x0000020002020200, 0x0000020202020200, 0x0000020002020202, 0x0000020202020202,
-0x0002000002020000, 0x0002000202020000, 0x0002000002020002, 0x0002000202020002,
-0x0002020002020000, 0x0002020202020000, 0x0002020002020002, 0x0002020202020002,
-0x0002000002020200, 0x0002000202020200, 0x0002000002020202, 0x0002000202020202,
-0x0002020002020200, 0x0002020202020200, 0x0002020002020202, 0x0002020202020202,
-0x0200000002000000, 0x0200000202000000, 0x0200000002000002, 0x0200000202000002,
-0x0200020002000000, 0x0200020202000000, 0x0200020002000002, 0x0200020202000002,
-0x0200000002000200, 0x0200000202000200, 0x0200000002000202, 0x0200000202000202,
-0x0200020002000200, 0x0200020202000200, 0x0200020002000202, 0x0200020202000202,
-0x0202000002000000, 0x0202000202000000, 0x0202000002000002, 0x0202000202000002,
-0x0202020002000000, 0x0202020202000000, 0x0202020002000002, 0x0202020202000002,
-0x0202000002000200, 0x0202000202000200, 0x0202000002000202, 0x0202000202000202,
-0x0202020002000200, 0x0202020202000200, 0x0202020002000202, 0x0202020202000202,
-0x0200000002020000, 0x0200000202020000, 0x0200000002020002, 0x0200000202020002,
-0x0200020002020000, 0x0200020202020000, 0x0200020002020002, 0x0200020202020002,
-0x0200000002020200, 0x0200000202020200, 0x0200000002020202, 0x0200000202020202,
-0x0200020002020200, 0x0200020202020200, 0x0200020002020202, 0x0200020202020202,
-0x0202000002020000, 0x0202000202020000, 0x0202000002020002, 0x0202000202020002,
-0x0202020002020000, 0x0202020202020000, 0x0202020002020002, 0x0202020202020002,
-0x0202000002020200, 0x0202000202020200, 0x0202000002020202, 0x0202000202020202,
-0x0202020002020200, 0x0202020202020200, 0x0202020002020202, 0x0202020202020202 };
+0x0000000000000000LL, 0x0000000200000000LL, 0x0000000000000002LL, 0x0000000200000002LL,
+0x0000020000000000LL, 0x0000020200000000LL, 0x0000020000000002LL, 0x0000020200000002LL,
+0x0000000000000200LL, 0x0000000200000200LL, 0x0000000000000202LL, 0x0000000200000202LL,
+0x0000020000000200LL, 0x0000020200000200LL, 0x0000020000000202LL, 0x0000020200000202LL,
+0x0002000000000000LL, 0x0002000200000000LL, 0x0002000000000002LL, 0x0002000200000002LL,
+0x0002020000000000LL, 0x0002020200000000LL, 0x0002020000000002LL, 0x0002020200000002LL,
+0x0002000000000200LL, 0x0002000200000200LL, 0x0002000000000202LL, 0x0002000200000202LL,
+0x0002020000000200LL, 0x0002020200000200LL, 0x0002020000000202LL, 0x0002020200000202LL,
+0x0000000000020000LL, 0x0000000200020000LL, 0x0000000000020002LL, 0x0000000200020002LL,
+0x0000020000020000LL, 0x0000020200020000LL, 0x0000020000020002LL, 0x0000020200020002LL,
+0x0000000000020200LL, 0x0000000200020200LL, 0x0000000000020202LL, 0x0000000200020202LL,
+0x0000020000020200LL, 0x0000020200020200LL, 0x0000020000020202LL, 0x0000020200020202LL,
+0x0002000000020000LL, 0x0002000200020000LL, 0x0002000000020002LL, 0x0002000200020002LL,
+0x0002020000020000LL, 0x0002020200020000LL, 0x0002020000020002LL, 0x0002020200020002LL,
+0x0002000000020200LL, 0x0002000200020200LL, 0x0002000000020202LL, 0x0002000200020202LL,
+0x0002020000020200LL, 0x0002020200020200LL, 0x0002020000020202LL, 0x0002020200020202LL,
+0x0200000000000000LL, 0x0200000200000000LL, 0x0200000000000002LL, 0x0200000200000002LL,
+0x0200020000000000LL, 0x0200020200000000LL, 0x0200020000000002LL, 0x0200020200000002LL,
+0x0200000000000200LL, 0x0200000200000200LL, 0x0200000000000202LL, 0x0200000200000202LL,
+0x0200020000000200LL, 0x0200020200000200LL, 0x0200020000000202LL, 0x0200020200000202LL,
+0x0202000000000000LL, 0x0202000200000000LL, 0x0202000000000002LL, 0x0202000200000002LL,
+0x0202020000000000LL, 0x0202020200000000LL, 0x0202020000000002LL, 0x0202020200000002LL,
+0x0202000000000200LL, 0x0202000200000200LL, 0x0202000000000202LL, 0x0202000200000202LL,
+0x0202020000000200LL, 0x0202020200000200LL, 0x0202020000000202LL, 0x0202020200000202LL,
+0x0200000000020000LL, 0x0200000200020000LL, 0x0200000000020002LL, 0x0200000200020002LL,
+0x0200020000020000LL, 0x0200020200020000LL, 0x0200020000020002LL, 0x0200020200020002LL,
+0x0200000000020200LL, 0x0200000200020200LL, 0x0200000000020202LL, 0x0200000200020202LL,
+0x0200020000020200LL, 0x0200020200020200LL, 0x0200020000020202LL, 0x0200020200020202LL,
+0x0202000000020000LL, 0x0202000200020000LL, 0x0202000000020002LL, 0x0202000200020002LL,
+0x0202020000020000LL, 0x0202020200020000LL, 0x0202020000020002LL, 0x0202020200020002LL,
+0x0202000000020200LL, 0x0202000200020200LL, 0x0202000000020202LL, 0x0202000200020202LL,
+0x0202020000020200LL, 0x0202020200020200LL, 0x0202020000020202LL, 0x0202020200020202LL,
+0x0000000002000000LL, 0x0000000202000000LL, 0x0000000002000002LL, 0x0000000202000002LL,
+0x0000020002000000LL, 0x0000020202000000LL, 0x0000020002000002LL, 0x0000020202000002LL,
+0x0000000002000200LL, 0x0000000202000200LL, 0x0000000002000202LL, 0x0000000202000202LL,
+0x0000020002000200LL, 0x0000020202000200LL, 0x0000020002000202LL, 0x0000020202000202LL,
+0x0002000002000000LL, 0x0002000202000000LL, 0x0002000002000002LL, 0x0002000202000002LL,
+0x0002020002000000LL, 0x0002020202000000LL, 0x0002020002000002LL, 0x0002020202000002LL,
+0x0002000002000200LL, 0x0002000202000200LL, 0x0002000002000202LL, 0x0002000202000202LL,
+0x0002020002000200LL, 0x0002020202000200LL, 0x0002020002000202LL, 0x0002020202000202LL,
+0x0000000002020000LL, 0x0000000202020000LL, 0x0000000002020002LL, 0x0000000202020002LL,
+0x0000020002020000LL, 0x0000020202020000LL, 0x0000020002020002LL, 0x0000020202020002LL,
+0x0000000002020200LL, 0x0000000202020200LL, 0x0000000002020202LL, 0x0000000202020202LL,
+0x0000020002020200LL, 0x0000020202020200LL, 0x0000020002020202LL, 0x0000020202020202LL,
+0x0002000002020000LL, 0x0002000202020000LL, 0x0002000002020002LL, 0x0002000202020002LL,
+0x0002020002020000LL, 0x0002020202020000LL, 0x0002020002020002LL, 0x0002020202020002LL,
+0x0002000002020200LL, 0x0002000202020200LL, 0x0002000002020202LL, 0x0002000202020202LL,
+0x0002020002020200LL, 0x0002020202020200LL, 0x0002020002020202LL, 0x0002020202020202LL,
+0x0200000002000000LL, 0x0200000202000000LL, 0x0200000002000002LL, 0x0200000202000002LL,
+0x0200020002000000LL, 0x0200020202000000LL, 0x0200020002000002LL, 0x0200020202000002LL,
+0x0200000002000200LL, 0x0200000202000200LL, 0x0200000002000202LL, 0x0200000202000202LL,
+0x0200020002000200LL, 0x0200020202000200LL, 0x0200020002000202LL, 0x0200020202000202LL,
+0x0202000002000000LL, 0x0202000202000000LL, 0x0202000002000002LL, 0x0202000202000002LL,
+0x0202020002000000LL, 0x0202020202000000LL, 0x0202020002000002LL, 0x0202020202000002LL,
+0x0202000002000200LL, 0x0202000202000200LL, 0x0202000002000202LL, 0x0202000202000202LL,
+0x0202020002000200LL, 0x0202020202000200LL, 0x0202020002000202LL, 0x0202020202000202LL,
+0x0200000002020000LL, 0x0200000202020000LL, 0x0200000002020002LL, 0x0200000202020002LL,
+0x0200020002020000LL, 0x0200020202020000LL, 0x0200020002020002LL, 0x0200020202020002LL,
+0x0200000002020200LL, 0x0200000202020200LL, 0x0200000002020202LL, 0x0200000202020202LL,
+0x0200020002020200LL, 0x0200020202020200LL, 0x0200020002020202LL, 0x0200020202020202LL,
+0x0202000002020000LL, 0x0202000202020000LL, 0x0202000002020002LL, 0x0202000202020002LL,
+0x0202020002020000LL, 0x0202020202020000LL, 0x0202020002020002LL, 0x0202020202020002LL,
+0x0202000002020200LL, 0x0202000202020200LL, 0x0202000002020202LL, 0x0202000202020202LL,
+0x0202020002020200LL, 0x0202020202020200LL, 0x0202020002020202LL, 0x0202020202020202LL };
 
 const u64bit DES::IPTAB2[256] = {
-0x0000000000000000, 0x0000010000000000, 0x0000000000000100, 0x0000010000000100,
-0x0001000000000000, 0x0001010000000000, 0x0001000000000100, 0x0001010000000100,
-0x0000000000010000, 0x0000010000010000, 0x0000000000010100, 0x0000010000010100,
-0x0001000000010000, 0x0001010000010000, 0x0001000000010100, 0x0001010000010100,
-0x0100000000000000, 0x0100010000000000, 0x0100000000000100, 0x0100010000000100,
-0x0101000000000000, 0x0101010000000000, 0x0101000000000100, 0x0101010000000100,
-0x0100000000010000, 0x0100010000010000, 0x0100000000010100, 0x0100010000010100,
-0x0101000000010000, 0x0101010000010000, 0x0101000000010100, 0x0101010000010100,
-0x0000000001000000, 0x0000010001000000, 0x0000000001000100, 0x0000010001000100,
-0x0001000001000000, 0x0001010001000000, 0x0001000001000100, 0x0001010001000100,
-0x0000000001010000, 0x0000010001010000, 0x0000000001010100, 0x0000010001010100,
-0x0001000001010000, 0x0001010001010000, 0x0001000001010100, 0x0001010001010100,
-0x0100000001000000, 0x0100010001000000, 0x0100000001000100, 0x0100010001000100,
-0x0101000001000000, 0x0101010001000000, 0x0101000001000100, 0x0101010001000100,
-0x0100000001010000, 0x0100010001010000, 0x0100000001010100, 0x0100010001010100,
-0x0101000001010000, 0x0101010001010000, 0x0101000001010100, 0x0101010001010100,
-0x0000000100000000, 0x0000010100000000, 0x0000000100000100, 0x0000010100000100,
-0x0001000100000000, 0x0001010100000000, 0x0001000100000100, 0x0001010100000100,
-0x0000000100010000, 0x0000010100010000, 0x0000000100010100, 0x0000010100010100,
-0x0001000100010000, 0x0001010100010000, 0x0001000100010100, 0x0001010100010100,
-0x0100000100000000, 0x0100010100000000, 0x0100000100000100, 0x0100010100000100,
-0x0101000100000000, 0x0101010100000000, 0x0101000100000100, 0x0101010100000100,
-0x0100000100010000, 0x0100010100010000, 0x0100000100010100, 0x0100010100010100,
-0x0101000100010000, 0x0101010100010000, 0x0101000100010100, 0x0101010100010100,
-0x0000000101000000, 0x0000010101000000, 0x0000000101000100, 0x0000010101000100,
-0x0001000101000000, 0x0001010101000000, 0x0001000101000100, 0x0001010101000100,
-0x0000000101010000, 0x0000010101010000, 0x0000000101010100, 0x0000010101010100,
-0x0001000101010000, 0x0001010101010000, 0x0001000101010100, 0x0001010101010100,
-0x0100000101000000, 0x0100010101000000, 0x0100000101000100, 0x0100010101000100,
-0x0101000101000000, 0x0101010101000000, 0x0101000101000100, 0x0101010101000100,
-0x0100000101010000, 0x0100010101010000, 0x0100000101010100, 0x0100010101010100,
-0x0101000101010000, 0x0101010101010000, 0x0101000101010100, 0x0101010101010100,
-0x0000000000000001, 0x0000010000000001, 0x0000000000000101, 0x0000010000000101,
-0x0001000000000001, 0x0001010000000001, 0x0001000000000101, 0x0001010000000101,
-0x0000000000010001, 0x0000010000010001, 0x0000000000010101, 0x0000010000010101,
-0x0001000000010001, 0x0001010000010001, 0x0001000000010101, 0x0001010000010101,
-0x0100000000000001, 0x0100010000000001, 0x0100000000000101, 0x0100010000000101,
-0x0101000000000001, 0x0101010000000001, 0x0101000000000101, 0x0101010000000101,
-0x0100000000010001, 0x0100010000010001, 0x0100000000010101, 0x0100010000010101,
-0x0101000000010001, 0x0101010000010001, 0x0101000000010101, 0x0101010000010101,
-0x0000000001000001, 0x0000010001000001, 0x0000000001000101, 0x0000010001000101,
-0x0001000001000001, 0x0001010001000001, 0x0001000001000101, 0x0001010001000101,
-0x0000000001010001, 0x0000010001010001, 0x0000000001010101, 0x0000010001010101,
-0x0001000001010001, 0x0001010001010001, 0x0001000001010101, 0x0001010001010101,
-0x0100000001000001, 0x0100010001000001, 0x0100000001000101, 0x0100010001000101,
-0x0101000001000001, 0x0101010001000001, 0x0101000001000101, 0x0101010001000101,
-0x0100000001010001, 0x0100010001010001, 0x0100000001010101, 0x0100010001010101,
-0x0101000001010001, 0x0101010001010001, 0x0101000001010101, 0x0101010001010101,
-0x0000000100000001, 0x0000010100000001, 0x0000000100000101, 0x0000010100000101,
-0x0001000100000001, 0x0001010100000001, 0x0001000100000101, 0x0001010100000101,
-0x0000000100010001, 0x0000010100010001, 0x0000000100010101, 0x0000010100010101,
-0x0001000100010001, 0x0001010100010001, 0x0001000100010101, 0x0001010100010101,
-0x0100000100000001, 0x0100010100000001, 0x0100000100000101, 0x0100010100000101,
-0x0101000100000001, 0x0101010100000001, 0x0101000100000101, 0x0101010100000101,
-0x0100000100010001, 0x0100010100010001, 0x0100000100010101, 0x0100010100010101,
-0x0101000100010001, 0x0101010100010001, 0x0101000100010101, 0x0101010100010101,
-0x0000000101000001, 0x0000010101000001, 0x0000000101000101, 0x0000010101000101,
-0x0001000101000001, 0x0001010101000001, 0x0001000101000101, 0x0001010101000101,
-0x0000000101010001, 0x0000010101010001, 0x0000000101010101, 0x0000010101010101,
-0x0001000101010001, 0x0001010101010001, 0x0001000101010101, 0x0001010101010101,
-0x0100000101000001, 0x0100010101000001, 0x0100000101000101, 0x0100010101000101,
-0x0101000101000001, 0x0101010101000001, 0x0101000101000101, 0x0101010101000101,
-0x0100000101010001, 0x0100010101010001, 0x0100000101010101, 0x0100010101010101,
-0x0101000101010001, 0x0101010101010001, 0x0101000101010101, 0x0101010101010101 };
+0x0000000000000000LL, 0x0000010000000000LL, 0x0000000000000100LL, 0x0000010000000100LL,
+0x0001000000000000LL, 0x0001010000000000LL, 0x0001000000000100LL, 0x0001010000000100LL,
+0x0000000000010000LL, 0x0000010000010000LL, 0x0000000000010100LL, 0x0000010000010100LL,
+0x0001000000010000LL, 0x0001010000010000LL, 0x0001000000010100LL, 0x0001010000010100LL,
+0x0100000000000000LL, 0x0100010000000000LL, 0x0100000000000100LL, 0x0100010000000100LL,
+0x0101000000000000LL, 0x0101010000000000LL, 0x0101000000000100LL, 0x0101010000000100LL,
+0x0100000000010000LL, 0x0100010000010000LL, 0x0100000000010100LL, 0x0100010000010100LL,
+0x0101000000010000LL, 0x0101010000010000LL, 0x0101000000010100LL, 0x0101010000010100LL,
+0x0000000001000000LL, 0x0000010001000000LL, 0x0000000001000100LL, 0x0000010001000100LL,
+0x0001000001000000LL, 0x0001010001000000LL, 0x0001000001000100LL, 0x0001010001000100LL,
+0x0000000001010000LL, 0x0000010001010000LL, 0x0000000001010100LL, 0x0000010001010100LL,
+0x0001000001010000LL, 0x0001010001010000LL, 0x0001000001010100LL, 0x0001010001010100LL,
+0x0100000001000000LL, 0x0100010001000000LL, 0x0100000001000100LL, 0x0100010001000100LL,
+0x0101000001000000LL, 0x0101010001000000LL, 0x0101000001000100LL, 0x0101010001000100LL,
+0x0100000001010000LL, 0x0100010001010000LL, 0x0100000001010100LL, 0x0100010001010100LL,
+0x0101000001010000LL, 0x0101010001010000LL, 0x0101000001010100LL, 0x0101010001010100LL,
+0x0000000100000000LL, 0x0000010100000000LL, 0x0000000100000100LL, 0x0000010100000100LL,
+0x0001000100000000LL, 0x0001010100000000LL, 0x0001000100000100LL, 0x0001010100000100LL,
+0x0000000100010000LL, 0x0000010100010000LL, 0x0000000100010100LL, 0x0000010100010100LL,
+0x0001000100010000LL, 0x0001010100010000LL, 0x0001000100010100LL, 0x0001010100010100LL,
+0x0100000100000000LL, 0x0100010100000000LL, 0x0100000100000100LL, 0x0100010100000100LL,
+0x0101000100000000LL, 0x0101010100000000LL, 0x0101000100000100LL, 0x0101010100000100LL,
+0x0100000100010000LL, 0x0100010100010000LL, 0x0100000100010100LL, 0x0100010100010100LL,
+0x0101000100010000LL, 0x0101010100010000LL, 0x0101000100010100LL, 0x0101010100010100LL,
+0x0000000101000000LL, 0x0000010101000000LL, 0x0000000101000100LL, 0x0000010101000100LL,
+0x0001000101000000LL, 0x0001010101000000LL, 0x0001000101000100LL, 0x0001010101000100LL,
+0x0000000101010000LL, 0x0000010101010000LL, 0x0000000101010100LL, 0x0000010101010100LL,
+0x0001000101010000LL, 0x0001010101010000LL, 0x0001000101010100LL, 0x0001010101010100LL,
+0x0100000101000000LL, 0x0100010101000000LL, 0x0100000101000100LL, 0x0100010101000100LL,
+0x0101000101000000LL, 0x0101010101000000LL, 0x0101000101000100LL, 0x0101010101000100LL,
+0x0100000101010000LL, 0x0100010101010000LL, 0x0100000101010100LL, 0x0100010101010100LL,
+0x0101000101010000LL, 0x0101010101010000LL, 0x0101000101010100LL, 0x0101010101010100LL,
+0x0000000000000001LL, 0x0000010000000001LL, 0x0000000000000101LL, 0x0000010000000101LL,
+0x0001000000000001LL, 0x0001010000000001LL, 0x0001000000000101LL, 0x0001010000000101LL,
+0x0000000000010001LL, 0x0000010000010001LL, 0x0000000000010101LL, 0x0000010000010101LL,
+0x0001000000010001LL, 0x0001010000010001LL, 0x0001000000010101LL, 0x0001010000010101LL,
+0x0100000000000001LL, 0x0100010000000001LL, 0x0100000000000101LL, 0x0100010000000101LL,
+0x0101000000000001LL, 0x0101010000000001LL, 0x0101000000000101LL, 0x0101010000000101LL,
+0x0100000000010001LL, 0x0100010000010001LL, 0x0100000000010101LL, 0x0100010000010101LL,
+0x0101000000010001LL, 0x0101010000010001LL, 0x0101000000010101LL, 0x0101010000010101LL,
+0x0000000001000001LL, 0x0000010001000001LL, 0x0000000001000101LL, 0x0000010001000101LL,
+0x0001000001000001LL, 0x0001010001000001LL, 0x0001000001000101LL, 0x0001010001000101LL,
+0x0000000001010001LL, 0x0000010001010001LL, 0x0000000001010101LL, 0x0000010001010101LL,
+0x0001000001010001LL, 0x0001010001010001LL, 0x0001000001010101LL, 0x0001010001010101LL,
+0x0100000001000001LL, 0x0100010001000001LL, 0x0100000001000101LL, 0x0100010001000101LL,
+0x0101000001000001LL, 0x0101010001000001LL, 0x0101000001000101LL, 0x0101010001000101LL,
+0x0100000001010001LL, 0x0100010001010001LL, 0x0100000001010101LL, 0x0100010001010101LL,
+0x0101000001010001LL, 0x0101010001010001LL, 0x0101000001010101LL, 0x0101010001010101LL,
+0x0000000100000001LL, 0x0000010100000001LL, 0x0000000100000101LL, 0x0000010100000101LL,
+0x0001000100000001LL, 0x0001010100000001LL, 0x0001000100000101LL, 0x0001010100000101LL,
+0x0000000100010001LL, 0x0000010100010001LL, 0x0000000100010101LL, 0x0000010100010101LL,
+0x0001000100010001LL, 0x0001010100010001LL, 0x0001000100010101LL, 0x0001010100010101LL,
+0x0100000100000001LL, 0x0100010100000001LL, 0x0100000100000101LL, 0x0100010100000101LL,
+0x0101000100000001LL, 0x0101010100000001LL, 0x0101000100000101LL, 0x0101010100000101LL,
+0x0100000100010001LL, 0x0100010100010001LL, 0x0100000100010101LL, 0x0100010100010101LL,
+0x0101000100010001LL, 0x0101010100010001LL, 0x0101000100010101LL, 0x0101010100010101LL,
+0x0000000101000001LL, 0x0000010101000001LL, 0x0000000101000101LL, 0x0000010101000101LL,
+0x0001000101000001LL, 0x0001010101000001LL, 0x0001000101000101LL, 0x0001010101000101LL,
+0x0000000101010001LL, 0x0000010101010001LL, 0x0000000101010101LL, 0x0000010101010101LL,
+0x0001000101010001LL, 0x0001010101010001LL, 0x0001000101010101LL, 0x0001010101010101LL,
+0x0100000101000001LL, 0x0100010101000001LL, 0x0100000101000101LL, 0x0100010101000101LL,
+0x0101000101000001LL, 0x0101010101000001LL, 0x0101000101000101LL, 0x0101010101000101LL,
+0x0100000101010001LL, 0x0100010101010001LL, 0x0100000101010101LL, 0x0100010101010101LL,
+0x0101000101010001LL, 0x0101010101010001LL, 0x0101000101010101LL, 0x0101010101010101LL };
 
 const u64bit DES::FPTAB1[256] = {
-0x0000000000000000, 0x0000000100000000, 0x0000000004000000, 0x0000000104000000,
-0x0000000000040000, 0x0000000100040000, 0x0000000004040000, 0x0000000104040000,
-0x0000000000000400, 0x0000000100000400, 0x0000000004000400, 0x0000000104000400,
-0x0000000000040400, 0x0000000100040400, 0x0000000004040400, 0x0000000104040400,
-0x0000000000000004, 0x0000000100000004, 0x0000000004000004, 0x0000000104000004,
-0x0000000000040004, 0x0000000100040004, 0x0000000004040004, 0x0000000104040004,
-0x0000000000000404, 0x0000000100000404, 0x0000000004000404, 0x0000000104000404,
-0x0000000000040404, 0x0000000100040404, 0x0000000004040404, 0x0000000104040404,
-0x0400000000000000, 0x0400000100000000, 0x0400000004000000, 0x0400000104000000,
-0x0400000000040000, 0x0400000100040000, 0x0400000004040000, 0x0400000104040000,
-0x0400000000000400, 0x0400000100000400, 0x0400000004000400, 0x0400000104000400,
-0x0400000000040400, 0x0400000100040400, 0x0400000004040400, 0x0400000104040400,
-0x0400000000000004, 0x0400000100000004, 0x0400000004000004, 0x0400000104000004,
-0x0400000000040004, 0x0400000100040004, 0x0400000004040004, 0x0400000104040004,
-0x0400000000000404, 0x0400000100000404, 0x0400000004000404, 0x0400000104000404,
-0x0400000000040404, 0x0400000100040404, 0x0400000004040404, 0x0400000104040404,
-0x0004000000000000, 0x0004000100000000, 0x0004000004000000, 0x0004000104000000,
-0x0004000000040000, 0x0004000100040000, 0x0004000004040000, 0x0004000104040000,
-0x0004000000000400, 0x0004000100000400, 0x0004000004000400, 0x0004000104000400,
-0x0004000000040400, 0x0004000100040400, 0x0004000004040400, 0x0004000104040400,
-0x0004000000000004, 0x0004000100000004, 0x0004000004000004, 0x0004000104000004,
-0x0004000000040004, 0x0004000100040004, 0x0004000004040004, 0x0004000104040004,
-0x0004000000000404, 0x0004000100000404, 0x0004000004000404, 0x0004000104000404,
-0x0004000000040404, 0x0004000100040404, 0x0004000004040404, 0x0004000104040404,
-0x0404000000000000, 0x0404000100000000, 0x0404000004000000, 0x0404000104000000,
-0x0404000000040000, 0x0404000100040000, 0x0404000004040000, 0x0404000104040000,
-0x0404000000000400, 0x0404000100000400, 0x0404000004000400, 0x0404000104000400,
-0x0404000000040400, 0x0404000100040400, 0x0404000004040400, 0x0404000104040400,
-0x0404000000000004, 0x0404000100000004, 0x0404000004000004, 0x0404000104000004,
-0x0404000000040004, 0x0404000100040004, 0x0404000004040004, 0x0404000104040004,
-0x0404000000000404, 0x0404000100000404, 0x0404000004000404, 0x0404000104000404,
-0x0404000000040404, 0x0404000100040404, 0x0404000004040404, 0x0404000104040404,
-0x0000040000000000, 0x0000040100000000, 0x0000040004000000, 0x0000040104000000,
-0x0000040000040000, 0x0000040100040000, 0x0000040004040000, 0x0000040104040000,
-0x0000040000000400, 0x0000040100000400, 0x0000040004000400, 0x0000040104000400,
-0x0000040000040400, 0x0000040100040400, 0x0000040004040400, 0x0000040104040400,
-0x0000040000000004, 0x0000040100000004, 0x0000040004000004, 0x0000040104000004,
-0x0000040000040004, 0x0000040100040004, 0x0000040004040004, 0x0000040104040004,
-0x0000040000000404, 0x0000040100000404, 0x0000040004000404, 0x0000040104000404,
-0x0000040000040404, 0x0000040100040404, 0x0000040004040404, 0x0000040104040404,
-0x0400040000000000, 0x0400040100000000, 0x0400040004000000, 0x0400040104000000,
-0x0400040000040000, 0x0400040100040000, 0x0400040004040000, 0x0400040104040000,
-0x0400040000000400, 0x0400040100000400, 0x0400040004000400, 0x0400040104000400,
-0x0400040000040400, 0x0400040100040400, 0x0400040004040400, 0x0400040104040400,
-0x0400040000000004, 0x0400040100000004, 0x0400040004000004, 0x0400040104000004,
-0x0400040000040004, 0x0400040100040004, 0x0400040004040004, 0x0400040104040004,
-0x0400040000000404, 0x0400040100000404, 0x0400040004000404, 0x0400040104000404,
-0x0400040000040404, 0x0400040100040404, 0x0400040004040404, 0x0400040104040404,
-0x0004040000000000, 0x0004040100000000, 0x0004040004000000, 0x0004040104000000,
-0x0004040000040000, 0x0004040100040000, 0x0004040004040000, 0x0004040104040000,
-0x0004040000000400, 0x0004040100000400, 0x0004040004000400, 0x0004040104000400,
-0x0004040000040400, 0x0004040100040400, 0x0004040004040400, 0x0004040104040400,
-0x0004040000000004, 0x0004040100000004, 0x0004040004000004, 0x0004040104000004,
-0x0004040000040004, 0x0004040100040004, 0x0004040004040004, 0x0004040104040004,
-0x0004040000000404, 0x0004040100000404, 0x0004040004000404, 0x0004040104000404,
-0x0004040000040404, 0x0004040100040404, 0x0004040004040404, 0x0004040104040404,
-0x0404040000000000, 0x0404040100000000, 0x0404040004000000, 0x0404040104000000,
-0x0404040000040000, 0x0404040100040000, 0x0404040004040000, 0x0404040104040000,
-0x0404040000000400, 0x0404040100000400, 0x0404040004000400, 0x0404040104000400,
-0x0404040000040400, 0x0404040100040400, 0x0404040004040400, 0x0404040104040400,
-0x0404040000000004, 0x0404040100000004, 0x0404040004000004, 0x0404040104000004,
-0x0404040000040004, 0x0404040100040004, 0x0404040004040004, 0x0404040104040004,
-0x0404040000000404, 0x0404040100000404, 0x0404040004000404, 0x0404040104000404,
-0x0404040000040404, 0x0404040100040404, 0x0404040004040404, 0x0404040104040404 };
+0x0000000000000000LL, 0x0000000100000000LL, 0x0000000004000000LL, 0x0000000104000000LL,
+0x0000000000040000LL, 0x0000000100040000LL, 0x0000000004040000LL, 0x0000000104040000LL,
+0x0000000000000400LL, 0x0000000100000400LL, 0x0000000004000400LL, 0x0000000104000400LL,
+0x0000000000040400LL, 0x0000000100040400LL, 0x0000000004040400LL, 0x0000000104040400LL,
+0x0000000000000004LL, 0x0000000100000004LL, 0x0000000004000004LL, 0x0000000104000004LL,
+0x0000000000040004LL, 0x0000000100040004LL, 0x0000000004040004LL, 0x0000000104040004LL,
+0x0000000000000404LL, 0x0000000100000404LL, 0x0000000004000404LL, 0x0000000104000404LL,
+0x0000000000040404LL, 0x0000000100040404LL, 0x0000000004040404LL, 0x0000000104040404LL,
+0x0400000000000000LL, 0x0400000100000000LL, 0x0400000004000000LL, 0x0400000104000000LL,
+0x0400000000040000LL, 0x0400000100040000LL, 0x0400000004040000LL, 0x0400000104040000LL,
+0x0400000000000400LL, 0x0400000100000400LL, 0x0400000004000400LL, 0x0400000104000400LL,
+0x0400000000040400LL, 0x0400000100040400LL, 0x0400000004040400LL, 0x0400000104040400LL,
+0x0400000000000004LL, 0x0400000100000004LL, 0x0400000004000004LL, 0x0400000104000004LL,
+0x0400000000040004LL, 0x0400000100040004LL, 0x0400000004040004LL, 0x0400000104040004LL,
+0x0400000000000404LL, 0x0400000100000404LL, 0x0400000004000404LL, 0x0400000104000404LL,
+0x0400000000040404LL, 0x0400000100040404LL, 0x0400000004040404LL, 0x0400000104040404LL,
+0x0004000000000000LL, 0x0004000100000000LL, 0x0004000004000000LL, 0x0004000104000000LL,
+0x0004000000040000LL, 0x0004000100040000LL, 0x0004000004040000LL, 0x0004000104040000LL,
+0x0004000000000400LL, 0x0004000100000400LL, 0x0004000004000400LL, 0x0004000104000400LL,
+0x0004000000040400LL, 0x0004000100040400LL, 0x0004000004040400LL, 0x0004000104040400LL,
+0x0004000000000004LL, 0x0004000100000004LL, 0x0004000004000004LL, 0x0004000104000004LL,
+0x0004000000040004LL, 0x0004000100040004LL, 0x0004000004040004LL, 0x0004000104040004LL,
+0x0004000000000404LL, 0x0004000100000404LL, 0x0004000004000404LL, 0x0004000104000404LL,
+0x0004000000040404LL, 0x0004000100040404LL, 0x0004000004040404LL, 0x0004000104040404LL,
+0x0404000000000000LL, 0x0404000100000000LL, 0x0404000004000000LL, 0x0404000104000000LL,
+0x0404000000040000LL, 0x0404000100040000LL, 0x0404000004040000LL, 0x0404000104040000LL,
+0x0404000000000400LL, 0x0404000100000400LL, 0x0404000004000400LL, 0x0404000104000400LL,
+0x0404000000040400LL, 0x0404000100040400LL, 0x0404000004040400LL, 0x0404000104040400LL,
+0x0404000000000004LL, 0x0404000100000004LL, 0x0404000004000004LL, 0x0404000104000004LL,
+0x0404000000040004LL, 0x0404000100040004LL, 0x0404000004040004LL, 0x0404000104040004LL,
+0x0404000000000404LL, 0x0404000100000404LL, 0x0404000004000404LL, 0x0404000104000404LL,
+0x0404000000040404LL, 0x0404000100040404LL, 0x0404000004040404LL, 0x0404000104040404LL,
+0x0000040000000000LL, 0x0000040100000000LL, 0x0000040004000000LL, 0x0000040104000000LL,
+0x0000040000040000LL, 0x0000040100040000LL, 0x0000040004040000LL, 0x0000040104040000LL,
+0x0000040000000400LL, 0x0000040100000400LL, 0x0000040004000400LL, 0x0000040104000400LL,
+0x0000040000040400LL, 0x0000040100040400LL, 0x0000040004040400LL, 0x0000040104040400LL,
+0x0000040000000004LL, 0x0000040100000004LL, 0x0000040004000004LL, 0x0000040104000004LL,
+0x0000040000040004LL, 0x0000040100040004LL, 0x0000040004040004LL, 0x0000040104040004LL,
+0x0000040000000404LL, 0x0000040100000404LL, 0x0000040004000404LL, 0x0000040104000404LL,
+0x0000040000040404LL, 0x0000040100040404LL, 0x0000040004040404LL, 0x0000040104040404LL,
+0x0400040000000000LL, 0x0400040100000000LL, 0x0400040004000000LL, 0x0400040104000000LL,
+0x0400040000040000LL, 0x0400040100040000LL, 0x0400040004040000LL, 0x0400040104040000LL,
+0x0400040000000400LL, 0x0400040100000400LL, 0x0400040004000400LL, 0x0400040104000400LL,
+0x0400040000040400LL, 0x0400040100040400LL, 0x0400040004040400LL, 0x0400040104040400LL,
+0x0400040000000004LL, 0x0400040100000004LL, 0x0400040004000004LL, 0x0400040104000004LL,
+0x0400040000040004LL, 0x0400040100040004LL, 0x0400040004040004LL, 0x0400040104040004LL,
+0x0400040000000404LL, 0x0400040100000404LL, 0x0400040004000404LL, 0x0400040104000404LL,
+0x0400040000040404LL, 0x0400040100040404LL, 0x0400040004040404LL, 0x0400040104040404LL,
+0x0004040000000000LL, 0x0004040100000000LL, 0x0004040004000000LL, 0x0004040104000000LL,
+0x0004040000040000LL, 0x0004040100040000LL, 0x0004040004040000LL, 0x0004040104040000LL,
+0x0004040000000400LL, 0x0004040100000400LL, 0x0004040004000400LL, 0x0004040104000400LL,
+0x0004040000040400LL, 0x0004040100040400LL, 0x0004040004040400LL, 0x0004040104040400LL,
+0x0004040000000004LL, 0x0004040100000004LL, 0x0004040004000004LL, 0x0004040104000004LL,
+0x0004040000040004LL, 0x0004040100040004LL, 0x0004040004040004LL, 0x0004040104040004LL,
+0x0004040000000404LL, 0x0004040100000404LL, 0x0004040004000404LL, 0x0004040104000404LL,
+0x0004040000040404LL, 0x0004040100040404LL, 0x0004040004040404LL, 0x0004040104040404LL,
+0x0404040000000000LL, 0x0404040100000000LL, 0x0404040004000000LL, 0x0404040104000000LL,
+0x0404040000040000LL, 0x0404040100040000LL, 0x0404040004040000LL, 0x0404040104040000LL,
+0x0404040000000400LL, 0x0404040100000400LL, 0x0404040004000400LL, 0x0404040104000400LL,
+0x0404040000040400LL, 0x0404040100040400LL, 0x0404040004040400LL, 0x0404040104040400LL,
+0x0404040000000004LL, 0x0404040100000004LL, 0x0404040004000004LL, 0x0404040104000004LL,
+0x0404040000040004LL, 0x0404040100040004LL, 0x0404040004040004LL, 0x0404040104040004LL,
+0x0404040000000404LL, 0x0404040100000404LL, 0x0404040004000404LL, 0x0404040104000404LL,
+0x0404040000040404LL, 0x0404040100040404LL, 0x0404040004040404LL, 0x0404040104040404LL };
 
 const u64bit DES::FPTAB2[256] = {
-0x0000000000000000, 0x0000004000000000, 0x0000000001000000, 0x0000004001000000,
-0x0000000000010000, 0x0000004000010000, 0x0000000001010000, 0x0000004001010000,
-0x0000000000000100, 0x0000004000000100, 0x0000000001000100, 0x0000004001000100,
-0x0000000000010100, 0x0000004000010100, 0x0000000001010100, 0x0000004001010100,
-0x0000000000000001, 0x0000004000000001, 0x0000000001000001, 0x0000004001000001,
-0x0000000000010001, 0x0000004000010001, 0x0000000001010001, 0x0000004001010001,
-0x0000000000000101, 0x0000004000000101, 0x0000000001000101, 0x0000004001000101,
-0x0000000000010101, 0x0000004000010101, 0x0000000001010101, 0x0000004001010101,
-0x0100000000000000, 0x0100004000000000, 0x0100000001000000, 0x0100004001000000,
-0x0100000000010000, 0x0100004000010000, 0x0100000001010000, 0x0100004001010000,
-0x0100000000000100, 0x0100004000000100, 0x0100000001000100, 0x0100004001000100,
-0x0100000000010100, 0x0100004000010100, 0x0100000001010100, 0x0100004001010100,
-0x0100000000000001, 0x0100004000000001, 0x0100000001000001, 0x0100004001000001,
-0x0100000000010001, 0x0100004000010001, 0x0100000001010001, 0x0100004001010001,
-0x0100000000000101, 0x0100004000000101, 0x0100000001000101, 0x0100004001000101,
-0x0100000000010101, 0x0100004000010101, 0x0100000001010101, 0x0100004001010101,
-0x0001000000000000, 0x0001004000000000, 0x0001000001000000, 0x0001004001000000,
-0x0001000000010000, 0x0001004000010000, 0x0001000001010000, 0x0001004001010000,
-0x0001000000000100, 0x0001004000000100, 0x0001000001000100, 0x0001004001000100,
-0x0001000000010100, 0x0001004000010100, 0x0001000001010100, 0x0001004001010100,
-0x0001000000000001, 0x0001004000000001, 0x0001000001000001, 0x0001004001000001,
-0x0001000000010001, 0x0001004000010001, 0x0001000001010001, 0x0001004001010001,
-0x0001000000000101, 0x0001004000000101, 0x0001000001000101, 0x0001004001000101,
-0x0001000000010101, 0x0001004000010101, 0x0001000001010101, 0x0001004001010101,
-0x0101000000000000, 0x0101004000000000, 0x0101000001000000, 0x0101004001000000,
-0x0101000000010000, 0x0101004000010000, 0x0101000001010000, 0x0101004001010000,
-0x0101000000000100, 0x0101004000000100, 0x0101000001000100, 0x0101004001000100,
-0x0101000000010100, 0x0101004000010100, 0x0101000001010100, 0x0101004001010100,
-0x0101000000000001, 0x0101004000000001, 0x0101000001000001, 0x0101004001000001,
-0x0101000000010001, 0x0101004000010001, 0x0101000001010001, 0x0101004001010001,
-0x0101000000000101, 0x0101004000000101, 0x0101000001000101, 0x0101004001000101,
-0x0101000000010101, 0x0101004000010101, 0x0101000001010101, 0x0101004001010101,
-0x0000010000000000, 0x0000014000000000, 0x0000010001000000, 0x0000014001000000,
-0x0000010000010000, 0x0000014000010000, 0x0000010001010000, 0x0000014001010000,
-0x0000010000000100, 0x0000014000000100, 0x0000010001000100, 0x0000014001000100,
-0x0000010000010100, 0x0000014000010100, 0x0000010001010100, 0x0000014001010100,
-0x0000010000000001, 0x0000014000000001, 0x0000010001000001, 0x0000014001000001,
-0x0000010000010001, 0x0000014000010001, 0x0000010001010001, 0x0000014001010001,
-0x0000010000000101, 0x0000014000000101, 0x0000010001000101, 0x0000014001000101,
-0x0000010000010101, 0x0000014000010101, 0x0000010001010101, 0x0000014001010101,
-0x0100010000000000, 0x0100014000000000, 0x0100010001000000, 0x0100014001000000,
-0x0100010000010000, 0x0100014000010000, 0x0100010001010000, 0x0100014001010000,
-0x0100010000000100, 0x0100014000000100, 0x0100010001000100, 0x0100014001000100,
-0x0100010000010100, 0x0100014000010100, 0x0100010001010100, 0x0100014001010100,
-0x0100010000000001, 0x0100014000000001, 0x0100010001000001, 0x0100014001000001,
-0x0100010000010001, 0x0100014000010001, 0x0100010001010001, 0x0100014001010001,
-0x0100010000000101, 0x0100014000000101, 0x0100010001000101, 0x0100014001000101,
-0x0100010000010101, 0x0100014000010101, 0x0100010001010101, 0x0100014001010101,
-0x0001010000000000, 0x0001014000000000, 0x0001010001000000, 0x0001014001000000,
-0x0001010000010000, 0x0001014000010000, 0x0001010001010000, 0x0001014001010000,
-0x0001010000000100, 0x0001014000000100, 0x0001010001000100, 0x0001014001000100,
-0x0001010000010100, 0x0001014000010100, 0x0001010001010100, 0x0001014001010100,
-0x0001010000000001, 0x0001014000000001, 0x0001010001000001, 0x0001014001000001,
-0x0001010000010001, 0x0001014000010001, 0x0001010001010001, 0x0001014001010001,
-0x0001010000000101, 0x0001014000000101, 0x0001010001000101, 0x0001014001000101,
-0x0001010000010101, 0x0001014000010101, 0x0001010001010101, 0x0001014001010101,
-0x0101010000000000, 0x0101014000000000, 0x0101010001000000, 0x0101014001000000,
-0x0101010000010000, 0x0101014000010000, 0x0101010001010000, 0x0101014001010000,
-0x0101010000000100, 0x0101014000000100, 0x0101010001000100, 0x0101014001000100,
-0x0101010000010100, 0x0101014000010100, 0x0101010001010100, 0x0101014001010100,
-0x0101010000000001, 0x0101014000000001, 0x0101010001000001, 0x0101014001000001,
-0x0101010000010001, 0x0101014000010001, 0x0101010001010001, 0x0101014001010001,
-0x0101010000000101, 0x0101014000000101, 0x0101010001000101, 0x0101014001000101,
-0x0101010000010101, 0x0101014000010101, 0x0101010001010101, 0x0101014001010101 };
+0x0000000000000000LL, 0x0000004000000000LL, 0x0000000001000000LL, 0x0000004001000000LL,
+0x0000000000010000LL, 0x0000004000010000LL, 0x0000000001010000LL, 0x0000004001010000LL,
+0x0000000000000100LL, 0x0000004000000100LL, 0x0000000001000100LL, 0x0000004001000100LL,
+0x0000000000010100LL, 0x0000004000010100LL, 0x0000000001010100LL, 0x0000004001010100LL,
+0x0000000000000001LL, 0x0000004000000001LL, 0x0000000001000001LL, 0x0000004001000001LL,
+0x0000000000010001LL, 0x0000004000010001LL, 0x0000000001010001LL, 0x0000004001010001LL,
+0x0000000000000101LL, 0x0000004000000101LL, 0x0000000001000101LL, 0x0000004001000101LL,
+0x0000000000010101LL, 0x0000004000010101LL, 0x0000000001010101LL, 0x0000004001010101LL,
+0x0100000000000000LL, 0x0100004000000000LL, 0x0100000001000000LL, 0x0100004001000000LL,
+0x0100000000010000LL, 0x0100004000010000LL, 0x0100000001010000LL, 0x0100004001010000LL,
+0x0100000000000100LL, 0x0100004000000100LL, 0x0100000001000100LL, 0x0100004001000100LL,
+0x0100000000010100LL, 0x0100004000010100LL, 0x0100000001010100LL, 0x0100004001010100LL,
+0x0100000000000001LL, 0x0100004000000001LL, 0x0100000001000001LL, 0x0100004001000001LL,
+0x0100000000010001LL, 0x0100004000010001LL, 0x0100000001010001LL, 0x0100004001010001LL,
+0x0100000000000101LL, 0x0100004000000101LL, 0x0100000001000101LL, 0x0100004001000101LL,
+0x0100000000010101LL, 0x0100004000010101LL, 0x0100000001010101LL, 0x0100004001010101LL,
+0x0001000000000000LL, 0x0001004000000000LL, 0x0001000001000000LL, 0x0001004001000000LL,
+0x0001000000010000LL, 0x0001004000010000LL, 0x0001000001010000LL, 0x0001004001010000LL,
+0x0001000000000100LL, 0x0001004000000100LL, 0x0001000001000100LL, 0x0001004001000100LL,
+0x0001000000010100LL, 0x0001004000010100LL, 0x0001000001010100LL, 0x0001004001010100LL,
+0x0001000000000001LL, 0x0001004000000001LL, 0x0001000001000001LL, 0x0001004001000001LL,
+0x0001000000010001LL, 0x0001004000010001LL, 0x0001000001010001LL, 0x0001004001010001LL,
+0x0001000000000101LL, 0x0001004000000101LL, 0x0001000001000101LL, 0x0001004001000101LL,
+0x0001000000010101LL, 0x0001004000010101LL, 0x0001000001010101LL, 0x0001004001010101LL,
+0x0101000000000000LL, 0x0101004000000000LL, 0x0101000001000000LL, 0x0101004001000000LL,
+0x0101000000010000LL, 0x0101004000010000LL, 0x0101000001010000LL, 0x0101004001010000LL,
+0x0101000000000100LL, 0x0101004000000100LL, 0x0101000001000100LL, 0x0101004001000100LL,
+0x0101000000010100LL, 0x0101004000010100LL, 0x0101000001010100LL, 0x0101004001010100LL,
+0x0101000000000001LL, 0x0101004000000001LL, 0x0101000001000001LL, 0x0101004001000001LL,
+0x0101000000010001LL, 0x0101004000010001LL, 0x0101000001010001LL, 0x0101004001010001LL,
+0x0101000000000101LL, 0x0101004000000101LL, 0x0101000001000101LL, 0x0101004001000101LL,
+0x0101000000010101LL, 0x0101004000010101LL, 0x0101000001010101LL, 0x0101004001010101LL,
+0x0000010000000000LL, 0x0000014000000000LL, 0x0000010001000000LL, 0x0000014001000000LL,
+0x0000010000010000LL, 0x0000014000010000LL, 0x0000010001010000LL, 0x0000014001010000LL,
+0x0000010000000100LL, 0x0000014000000100LL, 0x0000010001000100LL, 0x0000014001000100LL,
+0x0000010000010100LL, 0x0000014000010100LL, 0x0000010001010100LL, 0x0000014001010100LL,
+0x0000010000000001LL, 0x0000014000000001LL, 0x0000010001000001LL, 0x0000014001000001LL,
+0x0000010000010001LL, 0x0000014000010001LL, 0x0000010001010001LL, 0x0000014001010001LL,
+0x0000010000000101LL, 0x0000014000000101LL, 0x0000010001000101LL, 0x0000014001000101LL,
+0x0000010000010101LL, 0x0000014000010101LL, 0x0000010001010101LL, 0x0000014001010101LL,
+0x0100010000000000LL, 0x0100014000000000LL, 0x0100010001000000LL, 0x0100014001000000LL,
+0x0100010000010000LL, 0x0100014000010000LL, 0x0100010001010000LL, 0x0100014001010000LL,
+0x0100010000000100LL, 0x0100014000000100LL, 0x0100010001000100LL, 0x0100014001000100LL,
+0x0100010000010100LL, 0x0100014000010100LL, 0x0100010001010100LL, 0x0100014001010100LL,
+0x0100010000000001LL, 0x0100014000000001LL, 0x0100010001000001LL, 0x0100014001000001LL,
+0x0100010000010001LL, 0x0100014000010001LL, 0x0100010001010001LL, 0x0100014001010001LL,
+0x0100010000000101LL, 0x0100014000000101LL, 0x0100010001000101LL, 0x0100014001000101LL,
+0x0100010000010101LL, 0x0100014000010101LL, 0x0100010001010101LL, 0x0100014001010101LL,
+0x0001010000000000LL, 0x0001014000000000LL, 0x0001010001000000LL, 0x0001014001000000LL,
+0x0001010000010000LL, 0x0001014000010000LL, 0x0001010001010000LL, 0x0001014001010000LL,
+0x0001010000000100LL, 0x0001014000000100LL, 0x0001010001000100LL, 0x0001014001000100LL,
+0x0001010000010100LL, 0x0001014000010100LL, 0x0001010001010100LL, 0x0001014001010100LL,
+0x0001010000000001LL, 0x0001014000000001LL, 0x0001010001000001LL, 0x0001014001000001LL,
+0x0001010000010001LL, 0x0001014000010001LL, 0x0001010001010001LL, 0x0001014001010001LL,
+0x0001010000000101LL, 0x0001014000000101LL, 0x0001010001000101LL, 0x0001014001000101LL,
+0x0001010000010101LL, 0x0001014000010101LL, 0x0001010001010101LL, 0x0001014001010101LL,
+0x0101010000000000LL, 0x0101014000000000LL, 0x0101010001000000LL, 0x0101014001000000LL,
+0x0101010000010000LL, 0x0101014000010000LL, 0x0101010001010000LL, 0x0101014001010000LL,
+0x0101010000000100LL, 0x0101014000000100LL, 0x0101010001000100LL, 0x0101014001000100LL,
+0x0101010000010100LL, 0x0101014000010100LL, 0x0101010001010100LL, 0x0101014001010100LL,
+0x0101010000000001LL, 0x0101014000000001LL, 0x0101010001000001LL, 0x0101014001000001LL,
+0x0101010000010001LL, 0x0101014000010001LL, 0x0101010001010001LL, 0x0101014001010001LL,
+0x0101010000000101LL, 0x0101014000000101LL, 0x0101010001000101LL, 0x0101014001000101LL,
+0x0101010000010101LL, 0x0101014000010101LL, 0x0101010001010101LL, 0x0101014001010101LL };
 
 }
============================================================
--- src/dh.cpp	d751f576b0d623a8842e974b7222a69609a31de2
+++ src/dh.cpp	490710a5579a5ae6e3c7c80e4274b6893e6e82fe
@@ -4,9 +4,12 @@
 *************************************************/
 
 #include <botan/dh.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/util.h>
 
+using namespace Botan::math;
+
+
 namespace Botan {
 
 /*************************************************
@@ -35,13 +38,6 @@ u32bit DH_PublicKey::max_input_bits() co
    return group_p().bits();
    }
 
-/*************************************************
-* Return the public value for key agreement      *
-*************************************************/
-MemoryVector<byte> DH_PublicKey::public_value() const
-   {
-   return BigInt::encode_1363(y, group_p().bytes());
-   }
 
 /*************************************************
 * Create a DH private key                        *
@@ -84,40 +80,29 @@ void DH_PrivateKey::PKCS8_load_hook(bool
       load_check();
    }
 
-/*************************************************
-* Return the public value for key agreement      *
-*************************************************/
-MemoryVector<byte> DH_PrivateKey::public_value() const
-   {
-   return DH_PublicKey::public_value();
-   }
 
 /*************************************************
 * Derive a key                                   *
 *************************************************/
-SecureVector<byte> DH_PrivateKey::derive_key(const byte w[],
-                                             u32bit w_len) const
+SecureVector<byte> DH_PrivateKey::derive_key(const Public_Key& key) const
+{
+  const DH_PublicKey* p_dh_pk = dynamic_cast<const DH_PublicKey*>(&key);
+  if(!p_dh_pk)
+  {
+   throw Invalid_Argument("DH_PrivateKey::derive_key(): argument must be a DH_PublicKey");
+  }
+  const BigInt& p = group_p();
+  BigInt w = p_dh_pk->get_y();
+  if(w <= 1 || w >= p-1)
+      throw Invalid_Argument(algo_name() + "::derive_key: Invalid key input");
+   return BigInt::encode_1363(core.agree(w), p.bytes());
+}
+/*SecureVector<byte> DH_PrivateKey::derive_key(const BigInt& w) const
    {
-   return derive_key(BigInt::decode(w, w_len));
-   }
-
-/*************************************************
-* Derive a key                                   *
-*************************************************/
-SecureVector<byte> DH_PrivateKey::derive_key(const DH_PublicKey& key) const
-   {
-   return derive_key(key.get_y());
-   }
-
-/*************************************************
-* Derive a key                                   *
-*************************************************/
-SecureVector<byte> DH_PrivateKey::derive_key(const BigInt& w) const
-   {
    const BigInt& p = group_p();
    if(w <= 1 || w >= p-1)
       throw Invalid_Argument(algo_name() + "::derive_key: Invalid key input");
    return BigInt::encode_1363(core.agree(w), p.bytes());
    }
-
+*/
 }
============================================================
--- src/dl_algo.cpp	625deb904170bae96d19fadc0d6ac5f4cc677d9d
+++ src/dl_algo.cpp	1944d7f0fb134fd0c2038780be348a1b522aeba3
@@ -4,16 +4,19 @@
 *************************************************/
 
 #include <botan/dl_algo.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/der_enc.h>
 #include <botan/ber_dec.h>
 
+using namespace Botan::math;
+
+
 namespace Botan {
 
 /*************************************************
 * Return the X.509 public key encoder            *
 *************************************************/
-X509_Encoder* DL_Scheme_PublicKey::x509_encoder() const
+std::auto_ptr<X509_Encoder> DL_Scheme_PublicKey::x509_encoder() const
    {
    class DL_Scheme_Encoder : public X509_Encoder
       {
@@ -36,20 +39,20 @@ X509_Encoder* DL_Scheme_PublicKey::x509_
          const DL_Scheme_PublicKey* key;
       };
 
-   return new DL_Scheme_Encoder(this);
+   return std::auto_ptr<X509_Encoder>(new DL_Scheme_Encoder(this));
    }
 
 /*************************************************
 * Return the X.509 public key decoder            *
 *************************************************/
-X509_Decoder* DL_Scheme_PublicKey::x509_decoder()
+std::auto_ptr<X509_Decoder> DL_Scheme_PublicKey::x509_decoder()
    {
    class DL_Scheme_Decoder : public X509_Decoder
       {
       public:
          void alg_id(const AlgorithmIdentifier& alg_id)
             {
-            DataSource_Memory source(alg_id.parameters);
+            std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(alg_id.parameters));
             key->group.BER_decode(source, key->group_format());
             }
 
@@ -64,13 +67,13 @@ X509_Decoder* DL_Scheme_PublicKey::x509_
          DL_Scheme_PublicKey* key;
       };
 
-   return new DL_Scheme_Decoder(this);
+   return std::auto_ptr<X509_Decoder>(new DL_Scheme_Decoder(this));
    }
 
 /*************************************************
 * Return the PKCS #8 private key encoder         *
 *************************************************/
-PKCS8_Encoder* DL_Scheme_PrivateKey::pkcs8_encoder() const
+std::auto_ptr<PKCS8_Encoder> DL_Scheme_PrivateKey::pkcs8_encoder() const
    {
    class DL_Scheme_Encoder : public PKCS8_Encoder
       {
@@ -93,20 +96,20 @@ PKCS8_Encoder* DL_Scheme_PrivateKey::pkc
          const DL_Scheme_PrivateKey* key;
       };
 
-   return new DL_Scheme_Encoder(this);
+   return std::auto_ptr<PKCS8_Encoder>(new DL_Scheme_Encoder(this));
    }
 
 /*************************************************
 * Return the PKCS #8 private key decoder         *
 *************************************************/
-PKCS8_Decoder* DL_Scheme_PrivateKey::pkcs8_decoder()
+std::auto_ptr<PKCS8_Decoder> DL_Scheme_PrivateKey::pkcs8_decoder()
    {
    class DL_Scheme_Decoder : public PKCS8_Decoder
       {
       public:
          void alg_id(const AlgorithmIdentifier& alg_id)
             {
-            DataSource_Memory source(alg_id.parameters);
+            std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(alg_id.parameters));
             key->group.BER_decode(source, key->group_format());
             }
 
@@ -121,7 +124,7 @@ PKCS8_Decoder* DL_Scheme_PrivateKey::pkc
          DL_Scheme_PrivateKey* key;
       };
 
-   return new DL_Scheme_Decoder(this);
+   return std::auto_ptr<PKCS8_Decoder>(new DL_Scheme_Decoder(this));
    }
 
 /*************************************************
============================================================
--- src/dl_group.cpp	6a5022b0c81f660c85b912ad3e0a6ebd78c4ae85
+++ src/dl_group.cpp	a0c470d7c1397c5ead79bb7131aab370db9d12e9
@@ -6,13 +6,16 @@
 #include <botan/dl_group.h>
 #include <botan/config.h>
 #include <botan/parsing.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/der_enc.h>
 #include <botan/ber_dec.h>
 #include <botan/pipe.h>
 #include <botan/util.h>
 #include <botan/pem.h>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
@@ -29,11 +32,11 @@ DL_Group::DL_Group(const std::string& ty
 DL_Group::DL_Group(const std::string& type)
    {
    std::string grp_contents = global_config().get("dl", type);
-
-   if(grp_contents == "")
+   if(grp_contents == "") {
       throw Invalid_Argument("DL_Group: Unknown group " + type);
+   }
+   std::tr1::shared_ptr<DataSource> pem(new DataSource_Memory(grp_contents));
 
-   DataSource_Memory pem(grp_contents);
    PEM_decode(pem);
    }
 
@@ -253,11 +256,11 @@ std::string DL_Group::PEM_encode(Format 
 /*************************************************
 * Decode BER encoded parameters                  *
 *************************************************/
-void DL_Group::BER_decode(DataSource& source, Format format)
+void DL_Group::BER_decode(SharedPtrConverter<DataSource> source, Format format)
    {
    BigInt new_p, new_q, new_g;
 
-   BER_Decoder decoder(source);
+   BER_Decoder decoder(source.get_shared());
    BER_Decoder ber = decoder.start_cons(SEQUENCE);
 
    if(format == ANSI_X9_57)
@@ -289,10 +292,10 @@ void DL_Group::BER_decode(DataSource& so
 /*************************************************
 * Decode PEM encoded parameters                  *
 *************************************************/
-void DL_Group::PEM_decode(DataSource& source)
+void DL_Group::PEM_decode(SharedPtrConverter<DataSource> source)
    {
    std::string label;
-   DataSource_Memory ber(PEM_Code::decode(source, label));
+   std::tr1::shared_ptr<DataSource> ber(new DataSource_Memory(PEM_Code::decode(source.get_shared(), label)));
 
    if(label == "DH PARAMETERS")
       BER_decode(ber, PKCS_3);
============================================================
--- src/dsa_gen.cpp	71213b478a52c337f6aad69d3942bdcb51193e3e
+++ src/dsa_gen.cpp	36fb316cb63d9d040ed49fc48c571a60766546ed
@@ -4,15 +4,18 @@
 *************************************************/
 
 #include <botan/dl_group.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
+#include <botan/bit_ops.h>
 #include <botan/libstate.h>
 #include <botan/lookup.h>
-#include <botan/bit_ops.h>
 #include <botan/parsing.h>
 #include <botan/rng.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 namespace {
@@ -54,7 +57,7 @@ bool DL_Group::generate_dsa_primes(BigIn
          "Generating a DSA parameter set with a " + to_string(qbits) +
          "long q requires a seed at least as many bits long");
 
-   std::auto_ptr<HashFunction> hash(get_hash("SHA-" + to_string(qbits)));
+   std::tr1::shared_ptr<HashFunction> hash(get_hash("SHA-" + to_string(qbits)).release());
 
    const u32bit HASH_SIZE = hash->OUTPUT_LENGTH;
 
@@ -79,8 +82,8 @@ bool DL_Group::generate_dsa_primes(BigIn
    Seed seed(seed_c);
 
    q.binary_decode(hash->process(seed));
-   q.set_bit(qbits-1);
-   q.set_bit(0);
+   q.set_bit(qbits-1,true);
+   q.set_bit(0,true);
 
    if(!is_prime(q))
       return false;
@@ -106,7 +109,7 @@ bool DL_Group::generate_dsa_primes(BigIn
 
       X.binary_decode(V + (HASH_SIZE - 1 - b/8),
                       V.size() - (HASH_SIZE - 1 - b/8));
-      X.set_bit(pbits-1);
+      X.set_bit(pbits-1,true);
 
       p = X - (X % (2*q) - 1);
 
============================================================
--- src/eax.cpp	f1e9e17e046aa6de0450fc4773faeb73d8f2b7e1
+++ src/eax.cpp	eea50d9831b6fb348023d2b1ead8f2a01731d33a
@@ -17,7 +17,7 @@ SecureVector<byte> eax_prf(byte tag, u32
 * EAX MAC-based PRF                              *
 *************************************************/
 SecureVector<byte> eax_prf(byte tag, u32bit BLOCK_SIZE,
-                           MessageAuthenticationCode* mac,
+		std::tr1::shared_ptr<MessageAuthenticationCode> mac,
                            const byte in[], u32bit length)
    {
    for(u32bit j = 0; j != BLOCK_SIZE - 1; ++j)
@@ -39,8 +39,8 @@ EAX_Base::EAX_Base(const std::string& ci
    {
    const std::string mac_name = "CMAC(" + cipher_name + ")";
 
-   cipher = get_block_cipher(cipher_name);
-   mac = get_mac(mac_name);
+   cipher = std::tr1::shared_ptr<BlockCipher>(get_block_cipher(cipher_name).release());
+   mac = std::tr1::shared_ptr<MessageAuthenticationCode>(get_mac(mac_name).release());
 
    if(tag_size % 8 != 0 || TAG_SIZE == 0 || TAG_SIZE > mac->OUTPUT_LENGTH)
       throw Invalid_Argument(name() + ": Bad tag size " + to_string(tag_size));
============================================================
--- src/eme1.cpp	118aad6ac2eb56ece214d5e209e761a436ef4e3a
+++ src/eme1.cpp	e3839889917163b2673934812751456e15c10122
@@ -7,7 +7,7 @@
 #include <botan/rng.h>
 #include <botan/lookup.h>
 #include <botan/look_pk.h>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -86,11 +86,9 @@ EME1::EME1(const std::string& hash_name,
 *************************************************/
 EME1::EME1(const std::string& hash_name, const std::string& mgf_name,
            const std::string& P) :
-   HASH_LENGTH(output_length_of(hash_name))
+   HASH_LENGTH(output_length_of(hash_name)), mgf(get_mgf(mgf_name + "(" + hash_name + ")").release())
    {
-   mgf = get_mgf(mgf_name + "(" + hash_name + ")");
-   std::auto_ptr<HashFunction> hash(get_hash(hash_name));
-   Phash = hash->process(P);
+   Phash = get_hash(hash_name)->process(P);
    }
 
 }
============================================================
--- src/emsa1.cpp	92d9d12b72d3fee612f979a9efe36f9da3af4996
+++ src/emsa1.cpp	e6921eebd8d648a6edde313b2dbe8dec448f3b85
@@ -70,11 +70,13 @@ bool EMSA1::verify(const MemoryRegion<by
       if(our_coding.size() <= coded.size()) return false;
 
       u32bit offset = 0;
+      // 'remove' leading zeros...
       while(our_coding[offset] == 0 && offset < our_coding.size())
          ++offset;
+      // is it equal size now?...
       if(our_coding.size() - offset != coded.size())
          return false;
-
+      // is it bytewise equal?...
       for(u32bit j = 0; j != coded.size(); ++j)
          if(coded[j] != our_coding[j+offset])
             return false;
@@ -91,7 +93,7 @@ EMSA1::EMSA1(const std::string& hash_nam
 * EMSA1 Constructor                              *
 *************************************************/
 EMSA1::EMSA1(const std::string& hash_name) :
-   hash(get_hash(hash_name))
+    hash((get_hash(hash_name)).release())
    {
    }
 
============================================================
--- src/emsa2.cpp	3031d2c440ea6f65983216ab222d4ff8da32099d
+++ src/emsa2.cpp	76a78f2e29188862a6125d9e018e5b8b054a7341
@@ -63,7 +63,7 @@ EMSA2::EMSA2(const std::string& hash_nam
    hash_id = ieee1363_hash_id(hash_name);
    if(hash_id == 0)
       throw Encoding_Error("EMSA2 cannot be used with " + hash->name());
-   hash = get_hash(hash_name);
+   hash = std::tr1::shared_ptr<HashFunction>(get_hash(hash_name).release());
    empty_hash = hash->final();
    }
 
============================================================
--- src/emsa3.cpp	31c1d39fbda1461462f686095b027fbc5662e1e8
+++ src/emsa3.cpp	d829c8ee3ed6cf059680d9d846a027e6dcdf1b05
@@ -53,10 +53,10 @@ SecureVector<byte> EMSA3::encoding_of(co
 /*************************************************
 * EMSA3 Constructor                              *
 *************************************************/
-EMSA3::EMSA3(const std::string& hash_name)
+EMSA3::EMSA3(const std::string& hash_name) :
+    hash(get_hash(hash_name).release())
    {
    hash_id = pkcs_hash_id(hash_name);
-   hash = get_hash(hash_name);
    }
 
 }
============================================================
--- src/emsa4.cpp	91e564eed0e820f8bc5e5dfd05c947f76eec4771
+++ src/emsa4.cpp	49bad9efcd4affb70a4285c6c4e059aff688d87b
@@ -125,20 +125,18 @@ EMSA4::EMSA4(const std::string& hash_nam
 * EMSA4 Constructor                              *
 *************************************************/
 EMSA4::EMSA4(const std::string& hash_name, const std::string& mgf_name) :
-   SALT_SIZE(output_length_of(hash_name))
+   SALT_SIZE(output_length_of(hash_name)), hash(get_hash(hash_name).release()),
+   mgf(get_mgf(mgf_name + "(" + hash_name + ")").release())
    {
-   hash = get_hash(hash_name);
-   mgf = get_mgf(mgf_name + "(" + hash_name + ")");
    }
 
 /*************************************************
 * EMSA4 Constructor                              *
 *************************************************/
 EMSA4::EMSA4(const std::string& hash_name, const std::string& mgf_name,
-             u32bit salt_size) : SALT_SIZE(salt_size)
+             u32bit salt_size) : SALT_SIZE(salt_size), hash(get_hash(hash_name).release()),
+             mgf(get_mgf(mgf_name + "(" + hash_name + ")").release())
    {
-   hash = get_hash(hash_name);
-   mgf = get_mgf(mgf_name + "(" + hash_name + ")");
    }
 
 }
============================================================
--- src/eng_base.cpp	0593563d982aaac2c01024c1dd6e29b1494843d7
+++ src/eng_base.cpp	3ee738f8de0d01fde7ceac457439b323d010a14f
@@ -7,7 +7,12 @@
 #include <botan/libstate.h>
 #include <botan/stl_util.h>
 #include <botan/lookup.h>
+#include <iostream>
 
+
+using namespace Botan::math;
+using namespace Botan::math::ec;
+
 namespace Botan {
 
 namespace {
@@ -19,13 +24,13 @@ class Algorithm_Cache_Impl : public Engi
 class Algorithm_Cache_Impl : public Engine::Algorithm_Cache<T>
    {
    public:
-      T* get(const std::string& name) const
+	 std::tr1::shared_ptr<T> get(const std::string& name) const
          {
          Mutex_Holder lock(mutex);
          return search_map(mappings, name);
          }
 
-      void add(T* algo, const std::string& index_name = "") const
+      void add(std::tr1::shared_ptr<T> const& algo, const std::string& index_name = "") const
          {
          if(!algo)
             return;
@@ -33,94 +38,106 @@ class Algorithm_Cache_Impl : public Engi
          Mutex_Holder lock(mutex);
 
          const std::string name =
-            (index_name != "" ? index_name : algo->name());
+           (index_name != "" ? index_name : algo->name());
 
          if(mappings.find(name) != mappings.end())
-            delete mappings[name];
+            mappings[name].reset();
          mappings[name] = algo;
          }
 
       Algorithm_Cache_Impl()
          {
-         mutex = global_state().get_mutex();
+         mutex = std::tr1::shared_ptr<Mutex>(global_state().get_mutex().release());
          }
 
       ~Algorithm_Cache_Impl()
          {
-         typename std::map<std::string, T*>::iterator i = mappings.begin();
-
-         while(i != mappings.end())
-            {
-            delete i->second;
-            ++i;
-            }
-         delete mutex;
          }
    private:
-      Mutex* mutex;
-      mutable std::map<std::string, T*> mappings;
+      std::tr1::shared_ptr<Mutex> mutex;
+      mutable std::map<std::string, std::tr1::shared_ptr<T> > mappings;
    };
 
+
 }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-IF_Operation* Engine::if_op(const BigInt&, const BigInt&, const BigInt&,
+std::tr1::shared_ptr<IF_Operation> Engine::if_op(const BigInt&, const BigInt&, const BigInt&,
                             const BigInt&, const BigInt&, const BigInt&,
                             const BigInt&, const BigInt&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<IF_Operation>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
+/*
 DSA_Operation* Engine::dsa_op(const DL_Group&, const BigInt&,
                               const BigInt&) const
    {
    return 0;
    }
-
+*/
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
+/*
 NR_Operation* Engine::nr_op(const DL_Group&, const BigInt&,
                             const BigInt&) const
    {
    return 0;
    }
-
+*/
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
+/*
 ELG_Operation* Engine::elg_op(const DL_Group&, const BigInt&,
                               const BigInt&) const
    {
    return 0;
    }
-
+*/
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-DH_Operation* Engine::dh_op(const DL_Group&, const BigInt&) const
+std::tr1::shared_ptr<DH_Operation> Engine::dh_op(const DL_Group&, const BigInt&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<DH_Operation>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-Modular_Exponentiator* Engine::mod_exp(const BigInt&,
+std::tr1::shared_ptr<ECDSA_Operation>
+    Engine::ecdsa_op(EC_Domain_Params const&, BigInt const&, PointGFp const&) const
+    {
+    return std::tr1::shared_ptr<ECDSA_Operation>();
+    }
+/*************************************************
+* Basic No-Op Engine Implementation              *
+*************************************************/
+std::tr1::shared_ptr<ECKAEG_Operation>
+   Engine::eckaeg_op(EC_Domain_Params const&, BigInt const& , PointGFp const& ) const
+   {
+   return std::tr1::shared_ptr<ECKAEG_Operation>();
+   }
+/*************************************************
+* Basic No-Op Engine Implementation              *
+*************************************************/
+std::auto_ptr<Modular_Exponentiator> Engine::mod_exp(const BigInt&,
                                        Power_Mod::Usage_Hints) const
    {
-   return 0;
+   return std::auto_ptr<Modular_Exponentiator>();
    }
 
 /*************************************************
 * Acquire a BlockCipher                          *
 *************************************************/
-const BlockCipher* Engine::block_cipher(const std::string& name) const
+std::tr1::shared_ptr<BlockCipher const> Engine::block_cipher(const std::string& name) const
    {
    return lookup_algo(cache_of_bc, deref_alias(name),
                       this, &Engine::find_block_cipher);
@@ -129,7 +146,7 @@ const BlockCipher* Engine::block_cipher(
 /*************************************************
 * Acquire a StreamCipher                         *
 *************************************************/
-const StreamCipher* Engine::stream_cipher(const std::string& name) const
+std::tr1::shared_ptr<StreamCipher const> Engine::stream_cipher(const std::string& name) const
    {
    return lookup_algo(cache_of_sc, deref_alias(name),
                       this, &Engine::find_stream_cipher);
@@ -138,7 +155,7 @@ const StreamCipher* Engine::stream_ciphe
 /*************************************************
 * Acquire a HashFunction                         *
 *************************************************/
-const HashFunction* Engine::hash(const std::string& name) const
+std::tr1::shared_ptr<HashFunction const>  Engine::hash(const std::string& name) const
    {
    return lookup_algo(cache_of_hf, deref_alias(name),
                       this, &Engine::find_hash);
@@ -147,7 +164,7 @@ const HashFunction* Engine::hash(const s
 /*************************************************
 * Acquire a MessageAuthenticationCode            *
 *************************************************/
-const MessageAuthenticationCode* Engine::mac(const std::string& name) const
+std::tr1::shared_ptr<MessageAuthenticationCode const> Engine::mac(const std::string& name) const
    {
    return lookup_algo(cache_of_mac, deref_alias(name),
                       this, &Engine::find_mac);
@@ -156,7 +173,8 @@ const MessageAuthenticationCode* Engine:
 /*************************************************
 * Acquire a S2K object                           *
 *************************************************/
-const S2K* Engine::s2k(const std::string& name) const
+
+std::tr1::shared_ptr<S2K const> Engine::s2k(const std::string& name) const
    {
    return lookup_algo(cache_of_s2k, deref_alias(name),
                       this, &Engine::find_s2k);
@@ -165,7 +183,7 @@ const S2K* Engine::s2k(const std::string
 /*************************************************
 * Acquire a cipher padding object                *
 *************************************************/
-const BlockCipherModePaddingMethod*
+std::tr1::shared_ptr<BlockCipherModePaddingMethod const>
 Engine::bc_pad(const std::string& name) const
    {
    return lookup_algo(cache_of_bc_pad, deref_alias(name),
@@ -175,49 +193,48 @@ Engine::bc_pad(const std::string& name) 
 /*************************************************
 * Add a block cipher to the lookup table         *
 *************************************************/
-void Engine::add_algorithm(BlockCipher* algo) const
+void Engine::add_algorithm_bc(SharedPtrConverter<BlockCipher> const& algo) const
    {
-   cache_of_bc->add(algo);
+   cache_of_bc->add(algo.get_shared());
    }
 
 /*************************************************
 * Add a stream cipher to the lookup table        *
 *************************************************/
-void Engine::add_algorithm(StreamCipher* algo) const
+void Engine::add_algorithm_sc(SharedPtrConverter<StreamCipher> const& algo) const
    {
-   cache_of_sc->add(algo);
+   cache_of_sc->add(algo.get_shared());
    }
 
 /*************************************************
 * Add a hash function to the lookup table        *
 *************************************************/
-void Engine::add_algorithm(HashFunction* algo) const
+void Engine::add_algorithm_hf(SharedPtrConverter<HashFunction> const& algo) const
    {
-   cache_of_hf->add(algo);
+   cache_of_hf->add(algo.get_shared());
    }
 
 /*************************************************
 * Add a MAC to the lookup table                  *
 *************************************************/
-void Engine::add_algorithm(MessageAuthenticationCode* algo) const
+void Engine::add_algorithm_mac(SharedPtrConverter<MessageAuthenticationCode> const& algo) const
    {
-   cache_of_mac->add(algo);
+   cache_of_mac->add(algo.get_shared());
    }
 
 /*************************************************
 * Add a S2K to the lookup table                  *
 *************************************************/
-void Engine::add_algorithm(S2K* algo) const
+void Engine::add_algorithm_s2k(SharedPtrConverter<S2K> const& algo) const
    {
-   cache_of_s2k->add(algo);
+   cache_of_s2k->add(algo.get_shared());
    }
-
 /*************************************************
 * Add a cipher pad method to the lookup table    *
 *************************************************/
-void Engine::add_algorithm(BlockCipherModePaddingMethod* algo) const
+void Engine::add_algorithm_bcmpm(SharedPtrConverter<BlockCipherModePaddingMethod> const& algo) const
    {
-   cache_of_bc_pad->add(algo);
+   cache_of_bc_pad->add(algo.get_shared());
    }
 
 /*************************************************
@@ -225,13 +242,14 @@ Engine::Engine()
 *************************************************/
 Engine::Engine()
    {
-   cache_of_bc = new Algorithm_Cache_Impl<BlockCipher>();
-   cache_of_sc = new Algorithm_Cache_Impl<StreamCipher>();
-   cache_of_hf = new Algorithm_Cache_Impl<HashFunction>();
-   cache_of_mac = new Algorithm_Cache_Impl<MessageAuthenticationCode>();
-   cache_of_s2k = new Algorithm_Cache_Impl<S2K>();
-   cache_of_bc_pad =
-      new Algorithm_Cache_Impl<BlockCipherModePaddingMethod>();
+   cache_of_bc = std::tr1::shared_ptr<Algorithm_Cache_Impl<BlockCipher> >(new Algorithm_Cache_Impl<BlockCipher>());
+   cache_of_sc = std::tr1::shared_ptr<Algorithm_Cache_Impl<StreamCipher> >(new Algorithm_Cache_Impl<StreamCipher>());
+   cache_of_hf = std::tr1::shared_ptr<Algorithm_Cache_Impl<HashFunction> >(new Algorithm_Cache_Impl<HashFunction>());
+   cache_of_mac = std::tr1::shared_ptr<Algorithm_Cache_Impl<MessageAuthenticationCode> >(
+			   new Algorithm_Cache_Impl<MessageAuthenticationCode>());
+   cache_of_s2k = std::tr1::shared_ptr<Algorithm_Cache_Impl<S2K> >(new Algorithm_Cache_Impl<S2K>());
+   cache_of_bc_pad = std::tr1::shared_ptr<Algorithm_Cache_Impl<BlockCipherModePaddingMethod> >(
+			   new Algorithm_Cache_Impl<BlockCipherModePaddingMethod>());
    }
 
 /*************************************************
@@ -239,68 +257,62 @@ Engine::~Engine()
 *************************************************/
 Engine::~Engine()
    {
-   delete cache_of_bc;
-   delete cache_of_sc;
-   delete cache_of_hf;
-   delete cache_of_mac;
-   delete cache_of_s2k;
-   delete cache_of_bc_pad;
+
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-BlockCipher* Engine::find_block_cipher(const std::string&) const
+std::tr1::shared_ptr<BlockCipher> Engine::find_block_cipher(const std::string&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<BlockCipher>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-StreamCipher* Engine::find_stream_cipher(const std::string&) const
+std::tr1::shared_ptr<StreamCipher> Engine::find_stream_cipher(const std::string&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<StreamCipher>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-HashFunction* Engine::find_hash(const std::string&) const
+std::tr1::shared_ptr<HashFunction> Engine::find_hash(const std::string&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<HashFunction>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-MessageAuthenticationCode* Engine::find_mac(const std::string&) const
+std::tr1::shared_ptr<MessageAuthenticationCode> Engine::find_mac(const std::string&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<MessageAuthenticationCode>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-S2K* Engine::find_s2k(const std::string&) const
+std::tr1::shared_ptr<S2K> Engine::find_s2k(const std::string&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<S2K>();
    }
-
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-BlockCipherModePaddingMethod* Engine::find_bc_pad(const std::string&) const
+std::tr1::shared_ptr<BlockCipherModePaddingMethod> Engine::find_bc_pad(const std::string&) const
    {
-   return 0;
+   return std::tr1::shared_ptr<BlockCipherModePaddingMethod>();
    }
 
 /*************************************************
 * Basic No-Op Engine Implementation              *
 *************************************************/
-Keyed_Filter* Engine::get_cipher(const std::string&, Cipher_Dir)
+std::tr1::shared_ptr<Keyed_Filter> Engine::get_cipher(const std::string&, Cipher_Dir)
    {
-   return 0;
+   return std::tr1::shared_ptr<Keyed_Filter>();
    }
 
 }
============================================================
--- src/engine.cpp	bf3c1acdcb480eb07013cebc9f03417730b1e01f
+++ src/engine.cpp	835ab3db17379899cd83c048ef5350a2b11793ad
@@ -6,7 +6,12 @@
 #include <botan/engine.h>
 #include <botan/libstate.h>
 #include <botan/eng_def.h>
+#include <iostream>
 
+using namespace Botan::math;
+using namespace Botan::math::ec;
+
+
 namespace Botan {
 
 namespace Engine_Core {
@@ -14,16 +19,16 @@ namespace Engine_Core {
 /*************************************************
 * Acquire an IF op                               *
 *************************************************/
-IF_Operation* if_op(const BigInt& e, const BigInt& n, const BigInt& d,
+std::tr1::shared_ptr<IF_Operation> if_op(const BigInt& e, const BigInt& n, const BigInt& d,
                     const BigInt& p, const BigInt& q, const BigInt& d1,
                     const BigInt& d2, const BigInt& c)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      IF_Operation* op = engine->if_op(e, n, d, p, q, d1, d2, c);
-      if(op)
+	  std::tr1::shared_ptr<IF_Operation> op = engine->if_op(e, n, d, p, q, d1, d2, c);
+      if(op.get()) // any pointer set?
          return op;
       }
 
@@ -33,6 +38,7 @@ IF_Operation* if_op(const BigInt& e, con
 /*************************************************
 * Acquire a DSA op                               *
 *************************************************/
+/*
 DSA_Operation* dsa_op(const DL_Group& group, const BigInt& y, const BigInt& x)
    {
    Library_State::Engine_Iterator i(global_state());
@@ -46,10 +52,11 @@ DSA_Operation* dsa_op(const DL_Group& gr
 
    throw Lookup_Error("Engine_Core::dsa_op: Unable to find a working engine");
    }
-
+*/
 /*************************************************
 * Acquire a NR op                                *
 *************************************************/
+/*
 NR_Operation* nr_op(const DL_Group& group, const BigInt& y, const BigInt& x)
    {
    Library_State::Engine_Iterator i(global_state());
@@ -63,10 +70,11 @@ NR_Operation* nr_op(const DL_Group& grou
 
    throw Lookup_Error("Engine_Core::nr_op: Unable to find a working engine");
    }
-
+*/
 /*************************************************
 * Acquire an ElGamal op                          *
 *************************************************/
+/*
 ELG_Operation* elg_op(const DL_Group& group, const BigInt& y, const BigInt& x)
    {
    Library_State::Engine_Iterator i(global_state());
@@ -80,36 +88,69 @@ ELG_Operation* elg_op(const DL_Group& gr
 
    throw Lookup_Error("Engine_Core::elg_op: Unable to find a working engine");
    }
-
+*/
 /*************************************************
 * Acquire a DH op                                *
 *************************************************/
-DH_Operation* dh_op(const DL_Group& group, const BigInt& x)
+std::tr1::shared_ptr<DH_Operation> dh_op(const DL_Group& group, const BigInt& x)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      DH_Operation* op = engine->dh_op(group, x);
-      if(op)
+	   std::tr1::shared_ptr<DH_Operation> op = engine->dh_op(group, x);
+      if(op.get())
          return op;
       }
 
-   throw Lookup_Error("Engine_Core::dh_op: Unable to find a working engine");
+   throw Lookup_Error("Engine_Core::ecdsa_op: Unable to find a working engine");
    }
 
 /*************************************************
+* Acquire an ECDSA op                            *
+*************************************************/
+   std::tr1::shared_ptr<ECDSA_Operation> ecdsa_op(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key)
+   {
+       Library_State::Engine_Iterator i(global_state());
+
+       while(const std::tr1::shared_ptr<Engine> engine = i.next())
+       {
+           std::tr1::shared_ptr<ECDSA_Operation> op = engine->ecdsa_op(dom_pars, priv_key, pub_key);
+           if(op.get())
+               return op;
+       }
+
+       throw Lookup_Error("Engine_Core::ecdsa_op: Unable to find a working engine");
+
+   }
+/*************************************************
+* Acquire a ECKAEG op                            *
+*************************************************/
+   std::tr1::shared_ptr<ECKAEG_Operation> eckaeg_op(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key)
+      {
+       Library_State::Engine_Iterator i(global_state());
+
+      while(const std::tr1::shared_ptr<Engine> engine = i.next())
+         {
+          std::tr1::shared_ptr<ECKAEG_Operation> op = engine->eckaeg_op(dom_pars, priv_key, pub_key);
+         if(op.get())
+            return op;
+         }
+      throw Lookup_Error("Engine_Core::eckaeg_op: Unable to find a working engine");
+      }
+
+/*************************************************
 * Acquire a modular exponentiator                *
 *************************************************/
-Modular_Exponentiator* mod_exp(const BigInt& n, Power_Mod::Usage_Hints hints)
+std::auto_ptr<Modular_Exponentiator> mod_exp(const BigInt& n, Power_Mod::Usage_Hints hints)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      Modular_Exponentiator* op = engine->mod_exp(n, hints);
+	  std::auto_ptr<Modular_Exponentiator> op = engine->mod_exp(n, hints);
 
-      if(op)
+      if(op.get())
          return op;
       }
 
@@ -121,118 +162,117 @@ Modular_Exponentiator* mod_exp(const Big
 /*************************************************
 * Acquire a block cipher                         *
 *************************************************/
-const BlockCipher* retrieve_block_cipher(const std::string& name)
+std::tr1::shared_ptr<BlockCipher const> retrieve_block_cipher(const std::string& name)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      const BlockCipher* algo = engine->block_cipher(name);
-      if(algo)
+      std::tr1::shared_ptr<BlockCipher const> algo = engine->block_cipher(name);
+      if(algo.get())
          return algo;
       }
 
-   return 0;
+   return std::tr1::shared_ptr<BlockCipher>();
    }
 
 /*************************************************
 * Acquire a stream cipher                        *
 *************************************************/
-const StreamCipher* retrieve_stream_cipher(const std::string& name)
+std::tr1::shared_ptr<StreamCipher const> retrieve_stream_cipher(const std::string& name)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      const StreamCipher* algo = engine->stream_cipher(name);
-      if(algo)
+      std::tr1::shared_ptr<StreamCipher const> algo = engine->stream_cipher(name);
+      if(algo.get())
          return algo;
       }
 
-   return 0;
+   return std::tr1::shared_ptr<StreamCipher>();
    }
 
 /*************************************************
 * Acquire a hash function                        *
 *************************************************/
-const HashFunction* retrieve_hash(const std::string& name)
+std::tr1::shared_ptr<HashFunction const> retrieve_hash(const std::string& name)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      const HashFunction* algo = engine->hash(name);
-      if(algo)
+      std::tr1::shared_ptr<HashFunction const> algo = engine->hash(name);
+      if(algo.get())
          return algo;
       }
 
-   return 0;
+   return std::tr1::shared_ptr<HashFunction>();
    }
 
 /*************************************************
 * Acquire an authentication code                 *
 *************************************************/
-const MessageAuthenticationCode* retrieve_mac(const std::string& name)
+std::tr1::shared_ptr<MessageAuthenticationCode const> retrieve_mac(const std::string& name)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      const MessageAuthenticationCode* algo = engine->mac(name);
-      if(algo)
+      std::tr1::shared_ptr<MessageAuthenticationCode const> algo = engine->mac(name);
+      if(algo.get())
          return algo;
       }
 
-   return 0;
+   return std::tr1::shared_ptr<MessageAuthenticationCode>();
    }
 
 /*************************************************
 * Acquire a string-to-key algorithm              *
 *************************************************/
-const S2K* retrieve_s2k(const std::string& name)
+std::tr1::shared_ptr<S2K const> retrieve_s2k(const std::string& name)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      const S2K* algo = engine->s2k(name);
-      if(algo)
+      std::tr1::shared_ptr<S2K const> algo = engine->s2k(name);
+      if(algo.get())
          return algo;
       }
 
-   return 0;
+   return std::tr1::shared_ptr<S2K>();
    }
-
 /*************************************************
 * Retrieve a block cipher padding method         *
 *************************************************/
-const BlockCipherModePaddingMethod* retrieve_bc_pad(const std::string& name)
+std::tr1::shared_ptr<BlockCipherModePaddingMethod const> retrieve_bc_pad(const std::string& name)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(const Engine* engine = i.next())
+   while(const std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      const BlockCipherModePaddingMethod* algo = engine->bc_pad(name);
-      if(algo)
+      std::tr1::shared_ptr<BlockCipherModePaddingMethod const> algo = engine->bc_pad(name);
+      if(algo.get())
          return algo;
       }
 
-   return 0;
+   return std::tr1::shared_ptr<BlockCipherModePaddingMethod>();
    }
 
 /*************************************************
 * Add a new block cipher                         *
 *************************************************/
-void add_algorithm(BlockCipher* algo)
+void add_algorithm_bc(SharedPtrConverter<BlockCipher> const& algo)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(Engine* engine_base = i.next())
+   while(std::tr1::shared_ptr<Engine> engine_base = i.next())
       {
-      Default_Engine* engine = dynamic_cast<Default_Engine*>(engine_base);
+      std::tr1::shared_ptr<Default_Engine> engine = std::tr1::dynamic_pointer_cast<Default_Engine>(engine_base);
       if(engine)
          {
-         engine->add_algorithm(algo);
+         engine->add_algorithm_bc(algo.get_shared());
          return;
          }
       }
@@ -243,16 +283,16 @@ void add_algorithm(BlockCipher* algo)
 /*************************************************
 * Add a new stream cipher                        *
 *************************************************/
-void add_algorithm(StreamCipher* algo)
+void add_algorithm_sc(SharedPtrConverter<StreamCipher> const& algo)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(Engine* engine_base = i.next())
+   while(std::tr1::shared_ptr<Engine> engine_base = i.next())
       {
-      Default_Engine* engine = dynamic_cast<Default_Engine*>(engine_base);
+      std::tr1::shared_ptr<Default_Engine> engine = std::tr1::dynamic_pointer_cast<Default_Engine>(engine_base);
       if(engine)
          {
-         engine->add_algorithm(algo);
+         engine->add_algorithm_sc(algo.get_shared());
          return;
          }
       }
@@ -263,16 +303,16 @@ void add_algorithm(StreamCipher* algo)
 /*************************************************
 * Add a new hash function                        *
 *************************************************/
-void add_algorithm(HashFunction* algo)
+void add_algorithm_hf(SharedPtrConverter<HashFunction> const& algo)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(Engine* engine_base = i.next())
+   while(std::tr1::shared_ptr<Engine> engine_base = i.next())
       {
-      Default_Engine* engine = dynamic_cast<Default_Engine*>(engine_base);
+      std::tr1::shared_ptr<Default_Engine> engine = std::tr1::dynamic_pointer_cast<Default_Engine>(engine_base);
       if(engine)
          {
-         engine->add_algorithm(algo);
+         engine->add_algorithm_hf(algo.get_shared());
          return;
          }
       }
@@ -283,16 +323,16 @@ void add_algorithm(HashFunction* algo)
 /*************************************************
 * Add a new authentication code                  *
 *************************************************/
-void add_algorithm(MessageAuthenticationCode* algo)
+void add_algorithm_mac(SharedPtrConverter<MessageAuthenticationCode> const& algo)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(Engine* engine_base = i.next())
+   while(std::tr1::shared_ptr<Engine> engine_base = i.next())
       {
-      Default_Engine* engine = dynamic_cast<Default_Engine*>(engine_base);
+      std::tr1::shared_ptr<Default_Engine> engine = std::tr1::dynamic_pointer_cast<Default_Engine>(engine_base);
       if(engine)
          {
-         engine->add_algorithm(algo);
+         engine->add_algorithm_mac(algo.get_shared());
          return;
          }
       }
@@ -303,16 +343,16 @@ void add_algorithm(MessageAuthentication
 /*************************************************
 * Add a padding method to the lookup table       *
 *************************************************/
-void add_algorithm(BlockCipherModePaddingMethod* algo)
+void add_algorithm_bcmpm(SharedPtrConverter<BlockCipherModePaddingMethod> const& algo)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(Engine* engine_base = i.next())
+   while(std::tr1::shared_ptr<Engine> engine_base = i.next())
       {
-      Default_Engine* engine = dynamic_cast<Default_Engine*>(engine_base);
+      std::tr1::shared_ptr<Default_Engine> engine = std::tr1::dynamic_pointer_cast<Default_Engine>(engine_base);
       if(engine)
          {
-         engine->add_algorithm(algo);
+         engine->add_algorithm_bcmpm(algo.get_shared());
          return;
          }
       }
@@ -323,14 +363,14 @@ void add_algorithm(BlockCipherModePaddin
 /*************************************************
 * Get a cipher object                            *
 *************************************************/
-Keyed_Filter* get_cipher(const std::string& algo_spec, Cipher_Dir direction)
+Engine::Keyed_Filter_Ptr get_cipher(const std::string& algo_spec, Cipher_Dir direction)
    {
    Library_State::Engine_Iterator i(global_state());
 
-   while(Engine* engine = i.next())
+   while(std::tr1::shared_ptr<Engine> engine = i.next())
       {
-      Keyed_Filter* algo = engine->get_cipher(algo_spec, direction);
-      if(algo)
+      Engine::Keyed_Filter_Ptr algo = engine->get_cipher(algo_spec, direction);
+      if(algo.get())
          return algo;
       }
 
@@ -340,10 +380,10 @@ Keyed_Filter* get_cipher(const std::stri
 /*************************************************
 * Get a cipher object                            *
 *************************************************/
-Keyed_Filter* get_cipher(const std::string& algo_spec, const SymmetricKey& key,
+Engine::Keyed_Filter_Ptr get_cipher(const std::string& algo_spec, const SymmetricKey& key,
                          const InitializationVector& iv, Cipher_Dir direction)
    {
-   Keyed_Filter* cipher = get_cipher(algo_spec, direction);
+   Engine::Keyed_Filter_Ptr cipher = get_cipher(algo_spec, direction);
    cipher->set_key(key);
    cipher->set_iv(iv);
    return cipher;
@@ -352,7 +392,7 @@ Keyed_Filter* get_cipher(const std::stri
 /*************************************************
 * Get a cipher object                            *
 *************************************************/
-Keyed_Filter* get_cipher(const std::string& algo_spec, const SymmetricKey& key,
+Engine::Keyed_Filter_Ptr get_cipher(const std::string& algo_spec, const SymmetricKey& key,
                          Cipher_Dir direction)
    {
    return get_cipher(algo_spec, key, InitializationVector(), direction);
============================================================
--- src/filter.cpp	bc1fe725d4b6869d279e64f7649988a8b6d8f51f
+++ src/filter.cpp	1eafd8bf373abae81ff1b7645205c70750d3bce0
@@ -6,6 +6,7 @@
 #include <botan/filter.h>
 #include <botan/secqueue.h>
 #include <botan/libstate.h>
+#include <iostream>
 
 namespace Botan {
 
@@ -13,11 +14,14 @@ Filter::Filter()
 * Filter Constructor                             *
 *************************************************/
 Filter::Filter()
+   : Freestore(),
+     write_queue(),
+     next(1),
+     port_num(0),
+     filter_owns(0),
+     owned(false)
    {
-   next.resize(1);
-   port_num = 0;
-   filter_owns = 0;
-   owned = false;
+   // nothing else to do
    }
 
 /*************************************************
@@ -29,7 +33,7 @@ void Filter::send(const byte input[], u3
 
    bool nothing_attached = true;
    for(u32bit j = 0; j != total_ports(); ++j)
-      if(next[j])
+      if(next[j].get())
          {
          if(write_queue.has_items())
             next[j]->write(write_queue, write_queue.size());
@@ -60,20 +64,23 @@ void Filter::finish_msg()
    {
    end_msg();
    for(u32bit j = 0; j != total_ports(); ++j)
-      if(next[j])
+      if(next[j].get())
          next[j]->finish_msg();
    }
 
 /*************************************************
 * Attach a filter to the current port            *
 *************************************************/
-void Filter::attach(Filter* new_filter)
+void Filter::attach(SharedFilterPtrConverter const& new_filter_converter)
    {
-   if(new_filter)
+   SharedFilterPtr const& new_filter(new_filter_converter.get_shared());
+   if(new_filter.get())
       {
+      // here it is safe to use raw pointers (and
+      // avoids the need for shared_from_this().)
       Filter* last = this;
-      while(last->get_next())
-         last = last->get_next();
+      while(last->get_next().get())
+        last = last->get_next().get();
       last->next[last->current_port()] = new_filter;
       }
    }
@@ -91,32 +98,14 @@ void Filter::set_port(u32bit new_port)
 /*************************************************
 * Return the next Filter in the logical chain    *
 *************************************************/
-Filter* Filter::get_next() const
+Filter::SharedFilterPtr const Filter::get_next() const
    {
    if(port_num < next.size())
       return next[port_num];
-   return 0;
+   return Filter::SharedFilterPtr();
    }
 
 /*************************************************
-* Set the next Filters                           *
-*************************************************/
-void Filter::set_next(Filter* filters[], u32bit size)
-   {
-   while(size && filters && filters[size-1] == 0)
-      --size;
-
-   next.clear();
-   next.resize(size);
-
-   port_num = 0;
-   filter_owns = 0;
-
-   for(u32bit j = 0; j != size; ++j)
-      next[j] = filters[j];
-   }
-
-/*************************************************
 * Return the total number of ports               *
 *************************************************/
 u32bit Filter::total_ports() const
============================================================
--- src/filters.cpp	698d1b8987f6963d2ba5c03bc95bf79047a94fa2
+++ src/filters.cpp	540b964979407ed9070655cd15c53148d41a52e6
@@ -15,7 +15,7 @@ StreamCipher_Filter::StreamCipher_Filter
 StreamCipher_Filter::StreamCipher_Filter(const std::string& sc_name) :
    buffer(DEFAULT_BUFFERSIZE)
    {
-   base_ptr = cipher = get_stream_cipher(sc_name);
+   base_ptr = cipher = std::tr1::shared_ptr<StreamCipher>(get_stream_cipher(sc_name).release());
    }
 
 /*************************************************
@@ -25,7 +25,7 @@ StreamCipher_Filter::StreamCipher_Filter
                                          const SymmetricKey& key) :
    buffer(DEFAULT_BUFFERSIZE)
    {
-   base_ptr = cipher = get_stream_cipher(sc_name);
+   base_ptr = cipher = std::tr1::shared_ptr<StreamCipher>(get_stream_cipher(sc_name).release());
    cipher->set_key(key);
    }
 
@@ -56,9 +56,8 @@ Hash_Filter::Hash_Filter(const std::stri
 * Hash_Filter Constructor                        *
 *************************************************/
 Hash_Filter::Hash_Filter(const std::string& hash_name, u32bit len) :
-   OUTPUT_LENGTH(len)
+   OUTPUT_LENGTH(len), hash(get_hash(hash_name).release())
    {
-   hash = get_hash(hash_name);
    }
 
 /*************************************************
@@ -79,7 +78,7 @@ MAC_Filter::MAC_Filter(const std::string
 MAC_Filter::MAC_Filter(const std::string& mac_name, u32bit len) :
    OUTPUT_LENGTH(len)
    {
-   base_ptr = mac = get_mac(mac_name);
+   base_ptr = mac = std::tr1::shared_ptr<MessageAuthenticationCode>(get_mac(mac_name).release());;
    }
 
 /*************************************************
@@ -88,7 +87,7 @@ MAC_Filter::MAC_Filter(const std::string
 MAC_Filter::MAC_Filter(const std::string& mac_name, const SymmetricKey& key,
                        u32bit len) : OUTPUT_LENGTH(len)
    {
-   base_ptr = mac = get_mac(mac_name);
+   base_ptr = mac = std::tr1::shared_ptr<MessageAuthenticationCode>(get_mac(mac_name).release());
    mac->set_key(key);
    }
 
============================================================
--- src/fips140.cpp	df549a1ac6d511cb6f5a9d9a801bfed4529569cb
+++ src/fips140.cpp	b544fbb24aced09e36fe0f7637b5b22e318f6a9e
@@ -6,6 +6,11 @@
 #include <botan/fips140.h>
 #include <botan/lookup.h>
 
+#include <iostream>
+using std::cin;
+using std::cout;
+using std::endl;
+
 namespace Botan {
 
 namespace FIPS140 {
@@ -16,11 +21,11 @@ void do_kat(const std::string& in, const
 * Perform a Known Answer Test                    *
 *************************************************/
 void do_kat(const std::string& in, const std::string& out,
-            const std::string& algo_name, Filter* filter)
+            const std::string& algo_name, Filter::SharedFilterPtrConverter filter)
    {
    if(out.length())
       {
-      Pipe pipe(new Hex_Decoder, filter, new Hex_Encoder);
+      Pipe pipe(create_shared_ptr<Hex_Decoder>(), filter.get_shared(), create_shared_ptr<Hex_Encoder>());
       pipe.process_msg(in);
 
       if(out != pipe.read_all_as_string())
@@ -66,7 +71,7 @@ void hash_kat(const std::string& hash, c
    {
    if(!have_hash(hash))
       return;
-   do_kat(in, out, hash, new Hash_Filter(hash));
+   do_kat(in, out, hash, create_shared_ptr<Hash_Filter>(hash));
    }
 
 /*************************************************
@@ -77,7 +82,7 @@ void mac_kat(const std::string& mac, con
    {
    if(!have_mac(mac))
       return;
-   do_kat(in, out, mac, new MAC_Filter(mac, key));
+   do_kat(in, out, mac, create_shared_ptr<MAC_Filter>(mac, key));
    }
 
 }
@@ -121,7 +126,6 @@ bool passes_self_tests()
                 "7789508D16918F03F53C52DAC54ED825",
                 "3B3FD92EB72DAD20333449F8E83CFB4A"
                 "010C041999E03F36448624483E582D0E");
-
      hash_kat("SHA-1", "", "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709");
      hash_kat("SHA-1", "616263", "A9993E364706816ABA3E25717850C26C9CD0D89D");
      hash_kat("SHA-1",
@@ -150,16 +154,16 @@ bool passes_self_tests()
              "BA0AA3F3D9AE3C1C7A3B1696A0B68CF7",
              "0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B"
              "0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B");
-
      mac_kat("X9.19-MAC",
              "31311C3931383237333634351C1C35383134333237361C1C3B3132333435"
              "36373839303132333435363D3939313231303030303F1C30303031323530"
              "301C393738363533343132343837363932331C", "C209CCB78EE1B606",
              "0123456789ABCDEFFEDCBA9876543210");
   }
-  catch(std::exception)
+  catch(std::exception &e)
      {
-     return false;
+      cout << e.what() << " (self-test exception)\n";
+      return false;
      }
 
   return true;
============================================================
--- src/get_algo.cpp	656661d877017c4dbf1a80eb5e23a558fe463ff5
+++ src/get_algo.cpp	e20a98a41a2ee0c3d87725e9fb8e99b96ed1298a
@@ -10,10 +10,10 @@ namespace Botan {
 /*************************************************
 * Get a block cipher by name                     *
 *************************************************/
-BlockCipher* get_block_cipher(const std::string& name)
+std::auto_ptr<BlockCipher> get_block_cipher(const std::string& name)
    {
-   const BlockCipher* cipher = retrieve_block_cipher(name);
-   if(cipher)
+   std::tr1::shared_ptr<BlockCipher const> cipher = retrieve_block_cipher(name);
+   if(cipher.get())
       return cipher->clone();
    throw Algorithm_Not_Found(name);
    }
@@ -21,10 +21,10 @@ BlockCipher* get_block_cipher(const std:
 /*************************************************
 * Get a stream cipher by name                    *
 *************************************************/
-StreamCipher* get_stream_cipher(const std::string& name)
+std::auto_ptr<StreamCipher> get_stream_cipher(const std::string& name)
    {
-   const StreamCipher* cipher = retrieve_stream_cipher(name);
-   if(cipher)
+   std::tr1::shared_ptr<StreamCipher const> cipher = retrieve_stream_cipher(name);
+   if(cipher.get())
       return cipher->clone();
    throw Algorithm_Not_Found(name);
    }
@@ -32,10 +32,10 @@ StreamCipher* get_stream_cipher(const st
 /*************************************************
 * Get a hash function by name                    *
 *************************************************/
-HashFunction* get_hash(const std::string& name)
+std::auto_ptr<HashFunction> get_hash(const std::string& name)
    {
-   const HashFunction* hash = retrieve_hash(name);
-   if(hash)
+   std::tr1::shared_ptr<HashFunction const> hash = retrieve_hash(name);
+   if(hash.get())
       return hash->clone();
    throw Algorithm_Not_Found(name);
    }
@@ -43,10 +43,10 @@ HashFunction* get_hash(const std::string
 /*************************************************
 * Get a MAC by name                              *
 *************************************************/
-MessageAuthenticationCode* get_mac(const std::string& name)
+std::auto_ptr<MessageAuthenticationCode> get_mac(const std::string& name)
    {
-   const MessageAuthenticationCode* mac = retrieve_mac(name);
-   if(mac)
+   std::tr1::shared_ptr<MessageAuthenticationCode const> mac = retrieve_mac(name);
+   if(mac.get())
       return mac->clone();
    throw Algorithm_Not_Found(name);
    }
@@ -54,21 +54,20 @@ MessageAuthenticationCode* get_mac(const
 /*************************************************
 * Get a S2K algorithm by name                    *
 *************************************************/
-S2K* get_s2k(const std::string& name)
+std::auto_ptr<S2K> get_s2k(const std::string& name)
    {
-   const S2K* s2k = retrieve_s2k(name);
-   if(s2k)
+   std::tr1::shared_ptr<S2K const> s2k = retrieve_s2k(name);
+   if(s2k.get())
       return s2k->clone();
    throw Algorithm_Not_Found(name);
    }
-
 /*************************************************
 * Get a block cipher padding method by name      *
 *************************************************/
-const BlockCipherModePaddingMethod* get_bc_pad(const std::string& name)
+std::tr1::shared_ptr<BlockCipherModePaddingMethod const> get_bc_pad(const std::string& name)
    {
-   const BlockCipherModePaddingMethod* pad = retrieve_bc_pad(name);
-   if(pad)
+   std::tr1::shared_ptr<BlockCipherModePaddingMethod const> pad = retrieve_bc_pad(name);
+   if(pad.get())
       return pad;
    throw Algorithm_Not_Found(name);
    }
@@ -78,13 +77,13 @@ bool have_algorithm(const std::string& n
 *************************************************/
 bool have_algorithm(const std::string& name)
    {
-   if(retrieve_block_cipher(name))
+   if(retrieve_block_cipher(name).get())
       return true;
-   if(retrieve_stream_cipher(name))
+   if(retrieve_stream_cipher(name).get())
       return true;
-   if(retrieve_hash(name))
+   if(retrieve_hash(name).get())
       return true;
-   if(retrieve_mac(name))
+   if(retrieve_mac(name).get())
       return true;
    return false;
    }
@@ -94,7 +93,7 @@ bool have_block_cipher(const std::string
 *************************************************/
 bool have_block_cipher(const std::string& name)
    {
-   return (retrieve_block_cipher(name) != 0);
+   return (retrieve_block_cipher(name).get() != 0);
    }
 
 /*************************************************
@@ -102,7 +101,7 @@ bool have_stream_cipher(const std::strin
 *************************************************/
 bool have_stream_cipher(const std::string& name)
    {
-   return (retrieve_stream_cipher(name) != 0);
+   return (retrieve_stream_cipher(name).get() != 0);
    }
 
 /*************************************************
@@ -110,7 +109,7 @@ bool have_hash(const std::string& name)
 *************************************************/
 bool have_hash(const std::string& name)
    {
-   return (retrieve_hash(name) != 0);
+   return (retrieve_hash(name).get() != 0);
    }
 
 /*************************************************
@@ -118,7 +117,7 @@ bool have_mac(const std::string& name)
 *************************************************/
 bool have_mac(const std::string& name)
    {
-   return (retrieve_mac(name) != 0);
+   return (retrieve_mac(name).get() != 0);
    }
 
 /*************************************************
@@ -126,12 +125,12 @@ u32bit block_size_of(const std::string& 
 *************************************************/
 u32bit block_size_of(const std::string& name)
    {
-   const BlockCipher* cipher = retrieve_block_cipher(name);
-   if(cipher)
+   std::tr1::shared_ptr<BlockCipher const> cipher = retrieve_block_cipher(name);
+   if(cipher.get())
       return cipher->BLOCK_SIZE;
 
-   const HashFunction* hash = retrieve_hash(name);
-   if(hash)
+   std::tr1::shared_ptr<HashFunction const> hash = retrieve_hash(name);
+   if(hash.get())
       return hash->HASH_BLOCK_SIZE;
 
    throw Algorithm_Not_Found(name);
@@ -142,12 +141,12 @@ u32bit output_length_of(const std::strin
 *************************************************/
 u32bit output_length_of(const std::string& name)
    {
-   const HashFunction* hash = retrieve_hash(name);
-   if(hash)
+   std::tr1::shared_ptr<HashFunction const> hash = retrieve_hash(name);
+   if(hash.get())
       return hash->OUTPUT_LENGTH;
 
-   const MessageAuthenticationCode* mac = retrieve_mac(name);
-   if(mac)
+   std::tr1::shared_ptr<MessageAuthenticationCode const> mac = retrieve_mac(name);
+   if(mac.get())
       return mac->OUTPUT_LENGTH;
 
    throw Algorithm_Not_Found(name);
@@ -158,16 +157,16 @@ bool valid_keylength_for(u32bit key_len,
 *************************************************/
 bool valid_keylength_for(u32bit key_len, const std::string& name)
    {
-   const BlockCipher* bc = retrieve_block_cipher(name);
-   if(bc)
+   std::tr1::shared_ptr<BlockCipher const> bc = retrieve_block_cipher(name);
+   if(bc.get())
       return bc->valid_keylength(key_len);
 
-   const StreamCipher* sc = retrieve_stream_cipher(name);
-   if(sc)
+   std::tr1::shared_ptr<StreamCipher const> sc = retrieve_stream_cipher(name);
+   if(sc.get())
       return sc->valid_keylength(key_len);
 
-   const MessageAuthenticationCode* mac = retrieve_mac(name);
-   if(mac)
+   std::tr1::shared_ptr<MessageAuthenticationCode const> mac = retrieve_mac(name);
+   if(mac.get())
       return mac->valid_keylength(key_len);
 
    throw Algorithm_Not_Found(name);
@@ -178,16 +177,16 @@ u32bit min_keylength_of(const std::strin
 *************************************************/
 u32bit min_keylength_of(const std::string& name)
    {
-   const BlockCipher* bc = retrieve_block_cipher(name);
-   if(bc)
+   std::tr1::shared_ptr<BlockCipher const> bc = retrieve_block_cipher(name);
+   if(bc.get())
       return bc->MINIMUM_KEYLENGTH;
 
-   const StreamCipher* sc = retrieve_stream_cipher(name);
-   if(sc)
+   std::tr1::shared_ptr<StreamCipher const> sc = retrieve_stream_cipher(name);
+   if(sc.get())
       return sc->MINIMUM_KEYLENGTH;
 
-   const MessageAuthenticationCode* mac = retrieve_mac(name);
-   if(mac)
+   std::tr1::shared_ptr<MessageAuthenticationCode const> mac = retrieve_mac(name);
+   if(mac.get())
       return mac->MINIMUM_KEYLENGTH;
 
    throw Algorithm_Not_Found(name);
@@ -198,16 +197,16 @@ u32bit max_keylength_of(const std::strin
 *************************************************/
 u32bit max_keylength_of(const std::string& name)
    {
-   const BlockCipher* bc = retrieve_block_cipher(name);
-   if(bc)
+   std::tr1::shared_ptr<BlockCipher const> bc = retrieve_block_cipher(name);
+   if(bc.get())
       return bc->MAXIMUM_KEYLENGTH;
 
-   const StreamCipher* sc = retrieve_stream_cipher(name);
-   if(sc)
+   std::tr1::shared_ptr<StreamCipher const> sc = retrieve_stream_cipher(name);
+   if(sc.get())
       return sc->MAXIMUM_KEYLENGTH;
 
-   const MessageAuthenticationCode* mac = retrieve_mac(name);
-   if(mac)
+   std::tr1::shared_ptr<MessageAuthenticationCode const> mac = retrieve_mac(name);
+   if(mac.get())
       return mac->MAXIMUM_KEYLENGTH;
 
    throw Algorithm_Not_Found(name);
@@ -218,16 +217,16 @@ u32bit keylength_multiple_of(const std::
 *************************************************/
 u32bit keylength_multiple_of(const std::string& name)
    {
-   const BlockCipher* bc = retrieve_block_cipher(name);
-   if(bc)
+   std::tr1::shared_ptr<BlockCipher const> bc = retrieve_block_cipher(name);
+   if(bc.get())
       return bc->KEYLENGTH_MULTIPLE;
 
-   const StreamCipher* sc = retrieve_stream_cipher(name);
-   if(sc)
+   std::tr1::shared_ptr<StreamCipher const> sc = retrieve_stream_cipher(name);
+   if(sc.get())
       return sc->KEYLENGTH_MULTIPLE;
 
-   const MessageAuthenticationCode* mac = retrieve_mac(name);
-   if(mac)
+   std::tr1::shared_ptr<MessageAuthenticationCode const> mac = retrieve_mac(name);
+   if(mac.get())
       return mac->KEYLENGTH_MULTIPLE;
 
    throw Algorithm_Not_Found(name);
============================================================
--- src/get_enc.cpp	18eeecb14af5921471c02ec78ac491badc74108b
+++ src/get_enc.cpp	2ca2fda0155a6cb127b556198dcde24ee911ef20
@@ -16,7 +16,7 @@ namespace Botan {
 /*************************************************
 * Get an EMSA by name                            *
 *************************************************/
-EMSA* get_emsa(const std::string& algo_spec)
+std::auto_ptr<EMSA> get_emsa(const std::string& algo_spec)
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    const std::string emsa_name = deref_alias(name[0]);
@@ -24,31 +24,36 @@ EMSA* get_emsa(const std::string& algo_s
    if(emsa_name == "Raw")
       {
       if(name.size() == 1)
-         return new EMSA_Raw;
+         return std::auto_ptr<EMSA>(new EMSA_Raw);
       }
    else if(emsa_name == "EMSA1")
       {
       if(name.size() == 2)
-         return new EMSA1(name[1]);
+         return std::auto_ptr<EMSA>(new EMSA1(name[1]));
       }
+    else if(emsa_name == "EMSA1_BSI")
+      {
+      if(name.size() == 2)
+         return std::auto_ptr<EMSA>(new EMSA1_BSI(name[1]));
+      }
    else if(emsa_name == "EMSA2")
       {
       if(name.size() == 2)
-         return new EMSA2(name[1]);
+         return std::auto_ptr<EMSA>(new EMSA2(name[1]));
       }
    else if(emsa_name == "EMSA3")
       {
       if(name.size() == 2)
-         return new EMSA3(name[1]);
+         return std::auto_ptr<EMSA>(new EMSA3(name[1]));
       }
    else if(emsa_name == "EMSA4")
       {
       if(name.size() == 2)
-         return new EMSA4(name[1], "MGF1");
+         return std::auto_ptr<EMSA>(new EMSA4(name[1], "MGF1"));
       if(name.size() == 3)
-         return new EMSA4(name[1], name[2]);
+         return std::auto_ptr<EMSA>(new EMSA4(name[1], name[2]));
       if(name.size() == 4)
-         return new EMSA4(name[1], name[2], to_u32bit(name[3]));
+         return std::auto_ptr<EMSA>(new EMSA4(name[1], name[2], to_u32bit(name[3])));
       }
    else
       throw Algorithm_Not_Found(algo_spec);
@@ -59,7 +64,7 @@ EMSA* get_emsa(const std::string& algo_s
 /*************************************************
 * Get an EME by name                             *
 *************************************************/
-EME* get_eme(const std::string& algo_spec)
+std::auto_ptr<EME> get_eme(const std::string& algo_spec)
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    const std::string eme_name = deref_alias(name[0]);
@@ -67,14 +72,14 @@ EME* get_eme(const std::string& algo_spe
    if(eme_name == "PKCS1v15")
       {
       if(name.size() == 1)
-         return new EME_PKCS1v15;
+         return std::auto_ptr<EME>(new EME_PKCS1v15);
       }
    else if(eme_name == "EME1")
       {
       if(name.size() == 2)
-         return new EME1(name[1], "MGF1");
+         return std::auto_ptr<EME>(new EME1(name[1], "MGF1"));
       if(name.size() == 3)
-         return new EME1(name[1], name[2]);
+         return std::auto_ptr<EME>(new EME1(name[1], name[2]));
       }
    else
       throw Algorithm_Not_Found(algo_spec);
@@ -85,7 +90,7 @@ EME* get_eme(const std::string& algo_spe
 /*************************************************
 * Get an KDF by name                             *
 *************************************************/
-KDF* get_kdf(const std::string& algo_spec)
+std::auto_ptr<KDF> get_kdf(const std::string& algo_spec)
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    const std::string kdf_name = deref_alias(name[0]);
@@ -93,17 +98,17 @@ KDF* get_kdf(const std::string& algo_spe
    if(kdf_name == "KDF1")
       {
       if(name.size() == 2)
-         return new KDF1(name[1]);
+         return std::auto_ptr<KDF>(new KDF1(name[1]));
       }
    else if(kdf_name == "KDF2")
       {
       if(name.size() == 2)
-         return new KDF2(name[1]);
+         return std::auto_ptr<KDF>(new KDF2(name[1]));
       }
    else if(kdf_name == "X9.42-PRF")
       {
       if(name.size() == 2)
-         return new X942_PRF(name[1]);
+         return std::auto_ptr<KDF>(new X942_PRF(name[1]));
       }
    else
       throw Algorithm_Not_Found(algo_spec);
@@ -114,7 +119,7 @@ KDF* get_kdf(const std::string& algo_spe
 /*************************************************
 * Get a MGF by name                              *
 *************************************************/
-MGF* get_mgf(const std::string& algo_spec)
+std::auto_ptr<MGF> get_mgf(const std::string& algo_spec)
    {
    std::vector<std::string> name = parse_algorithm_name(algo_spec);
    const std::string mgf_name = deref_alias(name[0]);
@@ -122,7 +127,7 @@ MGF* get_mgf(const std::string& algo_spe
    if(mgf_name == "MGF1")
       {
       if(name.size() == 2)
-         return new MGF1(name[1]);
+         return std::auto_ptr<MGF>(new MGF1(name[1]));
       }
    else
       throw Algorithm_Not_Found(algo_spec);
============================================================
--- src/get_pbe.cpp	6bb990b1f38d8ef62c0a6055dcfb8f8eb2142386
+++ src/get_pbe.cpp	555659c95937ff012c1d1dad17db4370c116890d
@@ -7,13 +7,14 @@
 #include <botan/lookup.h>
 #include <botan/pbe_pkcs.h>
 #include <botan/parsing.h>
+#include <iostream>
 
 namespace Botan {
 
 /*************************************************
 * Get an encryption PBE, set new parameters      *
 *************************************************/
-PBE* get_pbe(const std::string& pbe_name)
+std::tr1::shared_ptr<PBE> get_pbe(const std::string& pbe_name)
    {
    std::vector<std::string> algo_name;
    algo_name = parse_algorithm_name(pbe_name);
@@ -25,14 +26,14 @@ PBE* get_pbe(const std::string& pbe_name
    const std::string digest = algo_name[1];
    const std::string cipher = algo_name[2];
 
-   PBE* pbe_obj = 0;
+   std::tr1::shared_ptr<PBE> pbe_obj;
 
    if(pbe == "PBE-PKCS5v15")
-      pbe_obj = new PBE_PKCS5v15(digest, cipher, ENCRYPTION);
-   else if(pbe == "PBE-PKCS5v20")
-      pbe_obj = new PBE_PKCS5v20(digest, cipher);
-
-   if(!pbe_obj)
+      pbe_obj = create_shared_ptr<PBE_PKCS5v15>(digest, cipher, ENCRYPTION);
+   else if(pbe == "PBE-PKCS5v20") {
+      pbe_obj = create_shared_ptr<PBE_PKCS5v20>(digest, cipher);
+   }
+   if(!pbe_obj.get())
       throw Algorithm_Not_Found(pbe_name);
 
    pbe_obj->new_params();
@@ -40,10 +41,12 @@ PBE* get_pbe(const std::string& pbe_name
    return pbe_obj;
    }
 
+
+
 /*************************************************
 * Get a decryption PBE, decode parameters        *
 *************************************************/
-PBE* get_pbe(const OID& pbe_oid, DataSource& params)
+std::tr1::shared_ptr<PBE> get_pbe(const OID& pbe_oid, SharedPtrConverter<DataSource> params)
    {
    std::vector<std::string> algo_name;
    algo_name = parse_algorithm_name(OIDS::lookup(pbe_oid));
@@ -58,12 +61,14 @@ PBE* get_pbe(const OID& pbe_oid, DataSou
          throw Invalid_Algorithm_Name(pbe_oid.as_string());
       const std::string digest = algo_name[1];
       const std::string cipher = algo_name[2];
-      PBE* pbe = new PBE_PKCS5v15(digest, cipher, DECRYPTION);
-      pbe->decode_params(params);
+      std::tr1::shared_ptr<PBE> pbe = create_shared_ptr<PBE_PKCS5v15>(digest, cipher, DECRYPTION);
+      pbe->decode_params(params.get_shared());
       return pbe;
       }
    else if(pbe_algo == "PBE-PKCS5v20")
-      return new PBE_PKCS5v20(params);
+      {
+        return create_shared_ptr<PBE_PKCS5v20>(params.get_shared());
+      }
 
    throw Algorithm_Not_Found(pbe_oid.as_string());
    }
============================================================
--- src/hash_id.cpp	ff3e7496e25d811a0f001aa900aef51e1b96e9a1
+++ src/hash_id.cpp	818350268f3f9a80a85822bdde7558eee15e565b
@@ -10,6 +10,7 @@ namespace PKCS_IDS {
 
 namespace PKCS_IDS {
 
+/*
 const byte MD2_ID[] = {
 0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86,
 0xF7, 0x0D, 0x02, 0x02, 0x05, 0x00, 0x04, 0x10 };
@@ -21,7 +22,7 @@ 0x02, 0x05, 0x00, 0x04, 0x14 };
 const byte RIPEMD_128_ID[] = {
 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02,
 0x02, 0x05, 0x00, 0x04, 0x14 };
-
+*/
 const byte RIPEMD_160_ID[] = {
 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02,
 0x01, 0x05, 0x00, 0x04, 0x14 };
@@ -30,6 +31,10 @@ 0x1A, 0x05, 0x00, 0x04, 0x14 };
 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02,
 0x1A, 0x05, 0x00, 0x04, 0x14 };
 
+const byte SHA_224_ID[] = {
+0x30, 0x2d, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
+0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c };
+
 const byte SHA_256_ID[] = {
 0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20 };
@@ -41,13 +46,13 @@ 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00
 const byte SHA_512_ID[] = {
 0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40 };
-
+/*
 const byte TIGER_ID[] = {
 0x30, 0x29, 0x30, 0x0D, 0x06, 0x09, 0x2B, 0x06, 0x01, 0x04,
 0x01, 0xDA, 0x47, 0x0C, 0x02, 0x05, 0x00, 0x04, 0x18 };
 
+*/
 }
-
 /*************************************************
 * Return the HashID, as specified by PKCS        *
 *************************************************/
@@ -57,28 +62,35 @@ MemoryVector<byte> pkcs_hash_id(const st
 
    MemoryVector<byte> out;
 
+/*
    if(name == "Parallel(MD5,SHA-160)")
       return out;
-
+*/
+  /*
    if(name == "MD2")
       out.set(PKCS_IDS::MD2_ID, sizeof(PKCS_IDS::MD2_ID));
    else if(name == "MD5")
       out.set(PKCS_IDS::MD5_ID, sizeof(PKCS_IDS::MD5_ID));
    else if(name == "RIPEMD-128")
       out.set(PKCS_IDS::RIPEMD_128_ID, sizeof(PKCS_IDS::RIPEMD_128_ID));
-   else if(name == "RIPEMD-160")
+   else
+    */
+    if(name == "RIPEMD-160")
       out.set(PKCS_IDS::RIPEMD_160_ID, sizeof(PKCS_IDS::RIPEMD_160_ID));
    else if(name == "SHA-160")
       out.set(PKCS_IDS::SHA_160_ID, sizeof(PKCS_IDS::SHA_160_ID));
+   else if(name == "SHA-224")
+      out.set(PKCS_IDS::SHA_224_ID, sizeof(PKCS_IDS::SHA_224_ID));
    else if(name == "SHA-256")
       out.set(PKCS_IDS::SHA_256_ID, sizeof(PKCS_IDS::SHA_256_ID));
    else if(name == "SHA-384")
       out.set(PKCS_IDS::SHA_384_ID, sizeof(PKCS_IDS::SHA_384_ID));
    else if(name == "SHA-512")
       out.set(PKCS_IDS::SHA_512_ID, sizeof(PKCS_IDS::SHA_512_ID));
+      /*
    else if(name == "Tiger(24,3)")
       out.set(PKCS_IDS::TIGER_ID, sizeof(PKCS_IDS::TIGER_ID));
-
+	*/
    if(out.size())
       return out;
 
@@ -92,13 +104,10 @@ byte ieee1363_hash_id(const std::string&
    {
    const std::string name = deref_alias(name_or_alias);
 
-   if(name == "RIPEMD-160") return 0x31;
-   if(name == "RIPEMD-128") return 0x32;
    if(name == "SHA-160")    return 0x33;
    if(name == "SHA-256")    return 0x34;
    if(name == "SHA-512")    return 0x35;
    if(name == "SHA-384")    return 0x36;
-   if(name == "Whirlpool")  return 0x37;
    return 0;
    }
 
============================================================
--- src/hmac.cpp	c98153b4f8b5c4a3b2fafc05bb69a0c2aa43067f
+++ src/hmac.cpp	a3e2997bc78f68b5c92a1fbe5242cd9010e7ddce
@@ -38,17 +38,18 @@ void HMAC::key(const byte key[], u32bit 
    std::fill(i_key.begin(), i_key.end(), 0x36);
    std::fill(o_key.begin(), o_key.end(), 0x5C);
 
+
    if(length > hash->HASH_BLOCK_SIZE)
-      {
-      SecureVector<byte> hmac_key = hash->process(key, length);
-      xor_buf(i_key, hmac_key, hmac_key.size());
-      xor_buf(o_key, hmac_key, hmac_key.size());
-      }
+   {
+   	SecureVector<byte> hmac_key = hash->process(key, length);
+   	xor_buf(i_key, hmac_key, hmac_key.size());
+   	xor_buf(o_key, hmac_key, hmac_key.size());
+   }
    else
-      {
-      xor_buf(i_key, key, length);
-      xor_buf(o_key, key, length);
-      }
+   {
+    xor_buf(i_key, key, length);
+    xor_buf(o_key, key, length);
+   }
 
    hash->update(i_key);
    }
@@ -74,9 +75,9 @@ std::string HMAC::name() const
 /*************************************************
 * Return a clone of this object                  *
 *************************************************/
-MessageAuthenticationCode* HMAC::clone() const
+HMAC::AutoMACPtr HMAC::clone() const
    {
-   return new HMAC(hash->name());
+   return HMAC::AutoMACPtr(new HMAC(hash->name()));
    }
 
 /*************************************************
@@ -85,7 +86,7 @@ HMAC::HMAC(const std::string& hash_name)
 HMAC::HMAC(const std::string& hash_name) :
    MessageAuthenticationCode(output_length_of(hash_name),
                              1, 2*block_size_of(hash_name)),
-   hash(get_hash(hash_name))
+   hash(get_hash(hash_name).release())
    {
    if(hash->HASH_BLOCK_SIZE == 0)
       throw Invalid_Argument("HMAC cannot be used with " + hash->name());
============================================================
--- src/if_algo.cpp	d887e1ee1beae026a0cb02c893c882f3d464d4e9
+++ src/if_algo.cpp	1b3c8c0a0ddaf5f24c28ded27ec2c34b39eec88d
@@ -4,7 +4,7 @@
 *************************************************/
 
 #include <botan/if_algo.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/der_enc.h>
 #include <botan/ber_dec.h>
 
@@ -13,7 +13,7 @@ namespace Botan {
 /*************************************************
 * Return the X.509 public key encoder            *
 *************************************************/
-X509_Encoder* IF_Scheme_PublicKey::x509_encoder() const
+std::auto_ptr<X509_Encoder> IF_Scheme_PublicKey::x509_encoder() const
    {
    class IF_Scheme_Encoder : public X509_Encoder
       {
@@ -36,16 +36,16 @@ X509_Encoder* IF_Scheme_PublicKey::x509_
 
          IF_Scheme_Encoder(const IF_Scheme_PublicKey* k) : key(k) {}
       private:
-         const IF_Scheme_PublicKey* key;
+      	const IF_Scheme_PublicKey* key;
       };
 
-   return new IF_Scheme_Encoder(this);
+   return std::auto_ptr<X509_Encoder>(new IF_Scheme_Encoder(this));
    }
 
 /*************************************************
 * Return the X.509 public key decoder            *
 *************************************************/
-X509_Decoder* IF_Scheme_PublicKey::x509_decoder()
+std::auto_ptr<X509_Decoder> IF_Scheme_PublicKey::x509_decoder()
    {
    class IF_Scheme_Decoder : public X509_Decoder
       {
@@ -66,16 +66,16 @@ X509_Decoder* IF_Scheme_PublicKey::x509_
 
          IF_Scheme_Decoder(IF_Scheme_PublicKey* k) : key(k) {}
       private:
-         IF_Scheme_PublicKey* key;
+        IF_Scheme_PublicKey* key;
       };
 
-   return new IF_Scheme_Decoder(this);
+   return std::auto_ptr<X509_Decoder>(new IF_Scheme_Decoder(this));
    }
 
 /*************************************************
 * Return the PKCS #8 public key encoder          *
 *************************************************/
-PKCS8_Encoder* IF_Scheme_PrivateKey::pkcs8_encoder() const
+std::auto_ptr<PKCS8_Encoder> IF_Scheme_PrivateKey::pkcs8_encoder() const
    {
    class IF_Scheme_Encoder : public PKCS8_Encoder
       {
@@ -105,16 +105,16 @@ PKCS8_Encoder* IF_Scheme_PrivateKey::pkc
 
          IF_Scheme_Encoder(const IF_Scheme_PrivateKey* k) : key(k) {}
       private:
-         const IF_Scheme_PrivateKey* key;
+      	const IF_Scheme_PrivateKey* key;
       };
 
-   return new IF_Scheme_Encoder(this);
+   return std::auto_ptr<PKCS8_Encoder>(new IF_Scheme_Encoder(this));
    }
 
 /*************************************************
 * Return the PKCS #8 public key decoder          *
 *************************************************/
-PKCS8_Decoder* IF_Scheme_PrivateKey::pkcs8_decoder()
+std::auto_ptr<PKCS8_Decoder> IF_Scheme_PrivateKey::pkcs8_decoder()
    {
    class IF_Scheme_Decoder : public PKCS8_Decoder
       {
@@ -146,10 +146,10 @@ PKCS8_Decoder* IF_Scheme_PrivateKey::pkc
 
          IF_Scheme_Decoder(IF_Scheme_PrivateKey* k) : key(k) {}
       private:
-         IF_Scheme_PrivateKey* key;
+      	IF_Scheme_PrivateKey* key;
       };
 
-   return new IF_Scheme_Decoder(this);
+   return std::auto_ptr<PKCS8_Decoder>(new IF_Scheme_Decoder(this));
    }
 
 /*************************************************
============================================================
--- src/init_def.cpp	032c0a1f7bd132c86506da3f4756a1f39a49e6aa
+++ src/init_def.cpp	a6a95d8b8ffb07b8e065c55d73332860b54d85ca
@@ -6,22 +6,70 @@
 #include <botan/init.h>
 #include <botan/libstate.h>
 #include <botan/modules.h>
+#include <botan/config.h>
+#include <botan/defalloc.h>
 #include <botan/fips140.h>
+#include <botan/x931_rng.h>
+#include <botan/def_char.h>
 
 namespace Botan {
 
 /*************************************************
 * Library Initialization                         *
 *************************************************/
+void LibraryInitializer::initialize(const std::string& arg_string)
+   {
+   InitializerOptions args(arg_string);
+   initialize(args);
+   }
+
+/*************************************************
+* Library Initialization                         *
+*************************************************/
+void LibraryInitializer::initialize(const InitializerOptions& args)
+   {
+   Builtin_Modules modules(args);
+   initialize(args, modules);
+   }
+
+/*************************************************
+* Library Initialization                         *
+*************************************************/
 void LibraryInitializer::initialize(const InitializerOptions& args,
                                     Modules& modules)
    {
    try
       {
-      set_global_state(new Library_State);
+      set_global_state(
+        //  set_global_state(std::tr1::shared_ptr<Library_State>(
+         new Library_State(
+            args.thread_safe() ?
+               modules.mutex_factory() :
+               std::tr1::shared_ptr<Mutex_Factory>(new Default_Mutex_Factory)
+            )
+         );
+          //   ));
 
-      global_state().initialize(args, modules);
+      global_state().config().load_defaults();
+      if(args.config_file() != "")
+         global_config().load_inifile(args.config_file());
 
+      global_state().load(modules);
+      global_state().set_prng(new ANSI_X931_RNG);
+
+      if(args.seed_rng())
+         {
+         for(u32bit j = 0; j != 4; ++j)
+            {
+            global_state().seed_prng(true, 384);
+            if(global_state().rng_is_seeded())
+               break;
+            }
+
+         if(!global_state().rng_is_seeded())
+            throw PRNG_Unseeded("Unable to collect sufficient entropy");
+         }
+
       if(args.fips_mode() || args.self_test())
          {
          if(!FIPS140::passes_self_tests())
@@ -41,27 +89,7 @@ void LibraryInitializer::deinitialize()
 void LibraryInitializer::deinitialize()
    {
    set_global_state(0);
+       //set_global_state(std::tr1::shared_ptr<Library_State>());
    }
 
-/*************************************************
-* Library Initialization                         *
-*************************************************/
-void LibraryInitializer::initialize(const std::string& arg_string)
-   {
-   InitializerOptions args(arg_string);
-   Builtin_Modules modules(args);
-
-   initialize(args, modules);
-   }
-
-/*************************************************
-* Library Initialization                         *
-*************************************************/
-void LibraryInitializer::initialize(const InitializerOptions& args)
-   {
-   Builtin_Modules modules(args);
-
-   initialize(args, modules);
-   }
-
 }
============================================================
--- src/jacobi.cpp	699fd1d1712c1e22fbb3cc94cb919b709b49b7de
+++ src/jacobi.cpp	10db9f92a1b27fe83908560d7ec3978456d8915b
@@ -3,8 +3,11 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
============================================================
--- src/kdf.cpp	5a8a42038d9d402727e6ca1b11d0244954137a32
+++ src/kdf.cpp	2d719e6ee038079311947f5681eeb9b32127901e
@@ -7,7 +7,7 @@
 #include <botan/lookup.h>
 #include <botan/bit_ops.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -19,8 +19,7 @@ SecureVector<byte> KDF::derive_key(u32bi
                                    const std::string& salt) const
    {
    return derive_key(key_len, secret, secret.size(),
-                     reinterpret_cast<const byte*>(salt.data()),
-                     salt.length());
+                     (const byte*)salt.c_str(), salt.length());
    }
 
 /*************************************************
@@ -53,8 +52,7 @@ SecureVector<byte> KDF::derive_key(u32bi
                                    const std::string& salt) const
    {
    return derive_key(key_len, secret, secret_len,
-                     reinterpret_cast<const byte*>(salt.data()),
-                     salt.length());
+                     (const byte*)salt.c_str(), salt.length());
    }
 
 /*************************************************
@@ -74,7 +72,7 @@ SecureVector<byte> KDF1::derive(u32bit,
                                 const byte secret[], u32bit secret_len,
                                 const byte P[], u32bit P_len) const
    {
-   std::auto_ptr<HashFunction> hash(get_hash(hash_name));
+	HashFunction::AutoHashFunctionPtr hash(get_hash(hash_name));
 
    hash->update(secret, secret_len);
    hash->update(P, P_len);
@@ -100,7 +98,7 @@ SecureVector<byte> KDF2::derive(u32bit o
    SecureVector<byte> output;
    u32bit counter = 1;
 
-   std::auto_ptr<HashFunction> hash(get_hash(hash_name));
+   HashFunction::AutoHashFunctionPtr hash(get_hash(hash_name));
    while(out_len && counter)
       {
       hash->update(secret, secret_len);
============================================================
--- src/keypair.cpp	3b736d5aae521292b8e479ebe3b9b703d4265a99
+++ src/keypair.cpp	05e7cd17e7c014a1a98b0f3db69f3820b8176819
@@ -6,7 +6,7 @@
 #include <botan/keypair.h>
 #include <botan/look_pk.h>
 #include <botan/rng.h>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -15,7 +15,7 @@ namespace KeyPair {
 /*************************************************
 * Check an encryption key pair for consistency   *
 *************************************************/
-void check_key(PK_Encryptor* encryptor, PK_Decryptor* decryptor)
+void check_key(std::auto_ptr<PK_Encryptor> encryptor, std::auto_ptr<PK_Decryptor> decryptor)
    {
    if(encryptor->maximum_input_size() == 0)
       return;
@@ -38,7 +38,7 @@ void check_key(PK_Encryptor* encryptor, 
 /*************************************************
 * Check a signature key pair for consistency     *
 *************************************************/
-void check_key(PK_Signer* signer, PK_Verifier* verifier)
+void check_key(std::auto_ptr<PK_Signer> signer, std::auto_ptr<PK_Verifier> verifier)
    {
    std::auto_ptr<PK_Signer> sig(signer);
    std::auto_ptr<PK_Verifier> ver(verifier);
============================================================
--- src/libstate.cpp	233c9231a05eae79ae231f8136850b43c34914d3
+++ src/libstate.cpp	5808d3bac1d5f9974d933b4a7c46f7db17f1fb59
@@ -12,7 +12,6 @@
 #include <botan/mutex.h>
 #include <botan/timers.h>
 #include <botan/charset.h>
-#include <botan/x931_rng.h>
 #include <algorithm>
 
 namespace Botan {
@@ -23,7 +22,7 @@ Library_State* global_lib_state = 0;
 namespace {
 
 Library_State* global_lib_state = 0;
-
+ //   std::tr1::shared_ptr<Library_State> global_lib_state = std::tr1::shared_ptr<Library_State>();
 }
 
 /*************************************************
@@ -32,8 +31,10 @@ Library_State& global_state()
 Library_State& global_state()
    {
    if(!global_lib_state)
-      LibraryInitializer::initialize();
+   //    if(!global_lib_state.get())
+      throw Invalid_State("Library was not initialized correctly");
    return (*global_lib_state);
+   //    return (*(global_lib_state.get()));
    }
 
 /*************************************************
@@ -43,7 +44,10 @@ void set_global_state(Library_State* new
    {
    delete swap_global_state(new_state);
    }
-
+/*   void set_global_state(std::tr1::shared_ptr<Library_State> new_state)
+   {
+       global_lib_state = new_state;
+   }*/
 /*************************************************
 * Swap two global state objects                  *
 *************************************************/
@@ -57,7 +61,7 @@ Library_State* swap_global_state(Library
 /*************************************************
 * Increment the Engine iterator                  *
 *************************************************/
-Engine* Library_State::Engine_Iterator::next()
+std::tr1::shared_ptr<class Engine> Library_State::Engine_Iterator::next()
    {
    return lib.get_engine_n(n++);
    }
@@ -65,7 +69,7 @@ Engine* Library_State::Engine_Iterator::
 /*************************************************
 * Get a new mutex object                         *
 *************************************************/
-Mutex* Library_State::get_mutex() const
+std::auto_ptr<Mutex> Library_State::get_mutex() const
    {
    return mutex_factory->make();
    }
@@ -73,23 +77,25 @@ Mutex* Library_State::get_mutex() const
 /*************************************************
 * Get a persistent named mutex object            *
 *************************************************/
-Mutex* Library_State::get_named_mutex(const std::string& name)
+std::tr1::shared_ptr<Mutex> Library_State::get_named_mutex(const std::string& name)
    {
-   Mutex* mux = search_map<std::string, Mutex*>(locks, name, 0);
+   std::tr1::shared_ptr<Mutex> mux = search_map<std::string, std::tr1::shared_ptr<Mutex> >(locks, name,
+	   std::tr1::shared_ptr<Mutex>());
    if(mux)
       return mux;
-   return (locks[name] = get_mutex());
+   return (locks[name] = std::tr1::shared_ptr<Mutex>(get_mutex().release()));
    }
 
 /*************************************************
 * Get an allocator by its name                   *
 *************************************************/
-Allocator* Library_State::get_allocator(const std::string& type) const
+std::tr1::shared_ptr<Allocator> Library_State::get_allocator(const std::string& type) const
    {
    Named_Mutex_Holder lock("allocator");
 
    if(type != "")
-      return search_map<std::string, Allocator*>(alloc_factory, type, 0);
+      return search_map<std::string, std::tr1::shared_ptr<Allocator> >(alloc_factory, type,
+	      std::tr1::shared_ptr<Allocator>());
 
    if(!cached_default_allocator)
       {
@@ -99,7 +105,8 @@ Allocator* Library_State::get_allocator(
          chosen = "malloc";
 
       cached_default_allocator =
-         search_map<std::string, Allocator*>(alloc_factory, chosen, 0);
+         search_map<std::string, std::tr1::shared_ptr<Allocator> >(alloc_factory, chosen,
+        	 std::tr1::shared_ptr<Allocator>());
       }
 
    return cached_default_allocator;
@@ -108,14 +115,15 @@ Allocator* Library_State::get_allocator(
 /*************************************************
 * Create a new name to object mapping            *
 *************************************************/
-void Library_State::add_allocator(Allocator* allocator)
+void Library_State::add_allocator(SharedPtrConverter<Allocator> allocator)
    {
    Named_Mutex_Holder lock("allocator");
+   std::tr1::shared_ptr<Allocator> shared_alloc_ptr = allocator.get_shared();
 
-   allocator->init();
+   shared_alloc_ptr->init();
 
-   allocators.push_back(allocator);
-   alloc_factory[allocator->type()] = allocator;
+   allocators.push_back(shared_alloc_ptr);
+   alloc_factory[shared_alloc_ptr->type()] = shared_alloc_ptr;
    }
 
 /*************************************************
@@ -129,16 +137,18 @@ void Library_State::set_default_allocato
       return;
 
    config().set("conf", "base/default_allocator", type);
-   cached_default_allocator = 0;
+   cached_default_allocator = std::tr1::shared_ptr<Allocator>();
    }
 
 /*************************************************
 * Set the high resolution clock implementation   *
 *************************************************/
-void Library_State::set_timer(Timer* new_timer)
+void Library_State::set_timer(SharedPtrConverter<Timer> new_timer)
    {
-   delete timer;
-   timer = new_timer;
+   if(new_timer.get_shared().get())
+      {
+      timer = new_timer.get_shared();
+      }
    }
 
 /*************************************************
@@ -158,6 +168,8 @@ void Library_State::set_prng(RandomNumbe
 
    delete rng;
    rng = new_rng;
+  // rng = std::tr1::shared_ptr<RandomNumberGenerator>(new_rng);
+
    }
 
 /*************************************************
@@ -173,14 +185,14 @@ void Library_State::randomize(byte out[]
 /*************************************************
 * Add a new entropy source to use                *
 *************************************************/
-void Library_State::add_entropy_source(EntropySource* src, bool last_in_list)
+void Library_State::add_entropy_source(SharedPtrConverter<EntropySource> src, bool last_in_list)
    {
    Named_Mutex_Holder lock("rng");
 
    if(last_in_list)
-      entropy_sources.push_back(src);
+      entropy_sources.push_back(src.get_shared());
    else
-      entropy_sources.insert(entropy_sources.begin(), src);
+      entropy_sources.insert(entropy_sources.begin(), src.get_shared());
    }
 
 /*************************************************
@@ -225,32 +237,30 @@ u32bit Library_State::seed_prng(bool slo
 /*************************************************
 * Get an engine out of the list                  *
 *************************************************/
-Engine* Library_State::get_engine_n(u32bit n) const
+std::tr1::shared_ptr<Engine> Library_State::get_engine_n(u32bit n) const
    {
    Named_Mutex_Holder lock("engine");
 
    if(n >= engines.size())
-      return 0;
+      return std::tr1::shared_ptr<Engine>();
    return engines[n];
    }
 
 /*************************************************
 * Add a new engine to the list                   *
 *************************************************/
-void Library_State::add_engine(Engine* engine)
+void Library_State::add_engine(SharedPtrConverter<Engine> engine)
    {
    Named_Mutex_Holder lock("engine");
-   engines.insert(engines.begin(), engine);
+   engines.insert(engines.begin(), engine.get_shared());
    }
 
 /*************************************************
 * Set the character set transcoder object        *
 *************************************************/
-void Library_State::set_transcoder(class Charset_Transcoder* transcoder)
+void Library_State::set_transcoder(SharedPtrConverter<class Charset_Transcoder> transcoder)
    {
-   if(this->transcoder)
-      delete this->transcoder;
-   this->transcoder = transcoder;
+   this->transcoder = transcoder.get_shared();
    }
 
 /*************************************************
@@ -269,30 +279,28 @@ std::string Library_State::transcode(con
 /*************************************************
 * Set the X509 global state class                *
 *************************************************/
-void Library_State::set_x509_state(X509_GlobalState* new_x509_state_obj)
+void Library_State::set_x509_state(SharedPtrConverter<X509_GlobalState> new_x509_state_obj)
    {
-   delete x509_state_obj;
-   x509_state_obj = new_x509_state_obj;
+   x509_state_obj = new_x509_state_obj.get_shared();
    }
 
 /*************************************************
 * Get the X509 global state class                *
 *************************************************/
-X509_GlobalState& Library_State::x509_state()
+std::tr1::shared_ptr<X509_GlobalState> Library_State::x509_state()
    {
    if(!x509_state_obj)
-      x509_state_obj = new X509_GlobalState();
+      x509_state_obj = std::tr1::shared_ptr<X509_GlobalState>(new X509_GlobalState());
 
-   return (*x509_state_obj);
+   return x509_state_obj;
    }
 
 /*************************************************
 * Set the UI object state                        *
 *************************************************/
-void Library_State::set_ui(UI* new_ui)
+void Library_State::set_ui(SharedPtrConverter<UI> new_ui)
    {
-   delete ui;
-   ui = new_ui;
+   ui = new_ui.get_shared();
    }
 
 /*************************************************
@@ -310,92 +318,59 @@ Config& Library_State::config() const
 Config& Library_State::config() const
    {
    if(!config_obj)
-      {
-      config_obj = new Config();
-      config_obj->load_defaults();
-      }
+      throw Invalid_State("Library_State::config(): No config set");
 
-   return (*config_obj);
+   return (*(config_obj.get()));
    }
 
 /*************************************************
-* Load a set of modules                          *
+* Load modules                                   *
 *************************************************/
-void Library_State::initialize(const InitializerOptions& args,
-                               Modules& modules)
+void Library_State::load(Modules& modules)
    {
-   if(mutex_factory)
-      throw Invalid_State("Library_State has already been initialized");
+   set_timer(modules.timer());
+   set_transcoder(modules.transcoder());
 
-   if(args.thread_safe())
-      mutex_factory = modules.mutex_factory();
-   else
-      mutex_factory = new Default_Mutex_Factory;
-
-   cached_default_allocator = 0;
-   x509_state_obj = 0;
-   ui = 0;
-
-   timer = modules.timer();
-   transcoder = modules.transcoder();
-
-   if(args.config_file() != "")
-      config().load_inifile(args.config_file());
-
-   locks["settings"] = get_mutex();
-   locks["allocator"] = get_mutex();
-   locks["rng"] = get_mutex();
-   locks["engine"] = get_mutex();
-
-   std::vector<Allocator*> mod_allocs = modules.allocators();
+   std::vector<std::tr1::shared_ptr<Allocator> > mod_allocs = modules.allocators();
    for(u32bit j = 0; j != mod_allocs.size(); ++j)
       add_allocator(mod_allocs[j]);
 
    set_default_allocator(modules.default_allocator());
 
-   std::vector<Engine*> mod_engines = modules.engines();
+   std::vector<std::tr1::shared_ptr<Engine> > mod_engines = modules.engines();
    for(u32bit j = 0; j != mod_engines.size(); ++j)
       {
       Named_Mutex_Holder lock("engine");
       engines.push_back(mod_engines[j]);
       }
 
-   std::vector<EntropySource*> sources = modules.entropy_sources();
+   std::vector<std::tr1::shared_ptr<EntropySource> > sources = modules.entropy_sources();
    for(u32bit j = 0; j != sources.size(); ++j)
       add_entropy_source(sources[j]);
-
-   set_prng(new ANSI_X931_RNG);
-
-   if(args.seed_rng())
-      {
-      for(u32bit j = 0; j != 4; ++j)
-         {
-         seed_prng(true, 384);
-         if(rng_is_seeded())
-            break;
-         }
-
-      if(!rng_is_seeded())
-         throw PRNG_Unseeded("Unable to collect sufficient entropy");
-      }
    }
 
 /*************************************************
 * Library_State Constructor                      *
 *************************************************/
-Library_State::Library_State()
+Library_State::Library_State(SharedPtrConverter<Mutex_Factory> mutex_factory)
    {
-   mutex_factory = 0;
+   if(!mutex_factory.get_shared().get())
+      throw Exception("Library_State: no mutex found");
 
-   timer = 0;
-   config_obj = 0;
-   x509_state_obj = 0;
+   this->mutex_factory = mutex_factory.get_shared();
+   this->timer = std::tr1::shared_ptr<Timer>(new Timer());
+   this->transcoder = std::tr1::shared_ptr<Charset_Transcoder>();
+   this->config_obj = std::tr1::shared_ptr<Config>(new Config());
 
-   ui = 0;
-   transcoder = 0;
+   locks["settings"] = std::tr1::shared_ptr<Mutex>(get_mutex().release());
+   locks["allocator"] = std::tr1::shared_ptr<Mutex>(get_mutex().release());
+   locks["rng"] = std::tr1::shared_ptr<Mutex>(get_mutex().release());
+   locks["engine"] = std::tr1::shared_ptr<Mutex>(get_mutex().release());
    rng = 0;
-   cached_default_allocator = 0;
-   ui = 0;
+   //rng = std::tr1::shared_ptr<RandomNumberGenerator>(); //0;
+   cached_default_allocator = std::tr1::shared_ptr<Allocator>();
+   x509_state_obj = std::tr1::shared_ptr<X509_GlobalState>();
+   ui = std::tr1::shared_ptr<UI>();
    }
 
 /*************************************************
@@ -403,29 +378,24 @@ Library_State::~Library_State()
 *************************************************/
 Library_State::~Library_State()
    {
-   delete x509_state_obj;
-   delete transcoder;
    delete rng;
-   delete timer;
-   delete config_obj;
-   delete ui;
 
-   std::for_each(entropy_sources.begin(), entropy_sources.end(),
-                 del_fun<EntropySource>());
-   std::for_each(engines.begin(), engines.end(), del_fun<Engine>());
+//   std::for_each(entropy_sources.begin(), entropy_sources.end(),
+//                 del_fun<EntropySource>());
+//   std::for_each(engines.begin(), engines.end(), del_fun<Engine>());
+   entropy_sources.clear();
+   engines.clear();
 
-   cached_default_allocator = 0;
+   cached_default_allocator.reset();
 
    for(u32bit j = 0; j != allocators.size(); ++j)
       {
       allocators[j]->destroy();
-      delete allocators[j];
       }
 
-   std::for_each(locks.begin(), locks.end(),
-                 delete2nd<std::map<std::string, Mutex*>::value_type>);
+//   std::for_each(locks.begin(), locks.end(),
+//                 delete2nd<std::map<std::string, Mutex*>::value_type>);
 
-   delete mutex_factory;
    }
 
 }
============================================================
--- src/look_pk.cpp	80288c7dbe76f809b37a6e2189b32d45a2eab344
+++ src/look_pk.cpp	13a90c93d5ce74a7f50e9291fbb21ccedf11e145
@@ -11,29 +11,29 @@ namespace Botan {
 /*************************************************
 * Get a PK_Encryptor object                      *
 *************************************************/
-PK_Encryptor* get_pk_encryptor(const PK_Encrypting_Key& key,
+std::auto_ptr<PK_Encryptor> get_pk_encryptor(const PK_Encrypting_Key& key,
                                const std::string& eme)
    {
-   return new PK_Encryptor_MR_with_EME(key, eme);
+   return std::auto_ptr<PK_Encryptor>(new PK_Encryptor_MR_with_EME(key, eme));
    }
 
 /*************************************************
 * Get a PK_Decryptor object                      *
 *************************************************/
-PK_Decryptor* get_pk_decryptor(const PK_Decrypting_Key& key,
+std::auto_ptr<PK_Decryptor> get_pk_decryptor(const PK_Decrypting_Key& key,
                                const std::string& eme)
    {
-   return new PK_Decryptor_MR_with_EME(key, eme);
+   return std::auto_ptr<PK_Decryptor>(new PK_Decryptor_MR_with_EME(key, eme));
    }
 
 /*************************************************
 * Get a PK_Signer object                         *
 *************************************************/
-PK_Signer* get_pk_signer(const PK_Signing_Key& key,
+std::auto_ptr<PK_Signer> get_pk_signer(const PK_Signing_Key& key,
                          const std::string& encoding,
                          Signature_Format sig_format)
    {
-   PK_Signer* signer = new PK_Signer(key, encoding);
+   std::auto_ptr<PK_Signer> signer(new PK_Signer(key, encoding));
    signer->set_output_format(sig_format);
    return signer;
    }
@@ -41,11 +41,11 @@ PK_Signer* get_pk_signer(const PK_Signin
 /*************************************************
 * Get a PK_Verifier object                       *
 *************************************************/
-PK_Verifier* get_pk_verifier(const PK_Verifying_with_MR_Key& key,
+std::auto_ptr<PK_Verifier> get_pk_verifier(const PK_Verifying_with_MR_Key& key,
                              const std::string& encoding,
                              Signature_Format sig_format)
    {
-   PK_Verifier* verifier = new PK_Verifier_with_MR(key, encoding);
+   std::auto_ptr<PK_Verifier> verifier(new PK_Verifier_with_MR(key, encoding));
    verifier->set_input_format(sig_format);
    return verifier;
    }
@@ -53,11 +53,11 @@ PK_Verifier* get_pk_verifier(const PK_Ve
 /*************************************************
 * Get a PK_Verifier object                       *
 *************************************************/
-PK_Verifier* get_pk_verifier(const PK_Verifying_wo_MR_Key& key,
+std::auto_ptr<PK_Verifier> get_pk_verifier(const PK_Verifying_wo_MR_Key& key,
                              const std::string& encoding,
                              Signature_Format sig_format)
    {
-   PK_Verifier* verifier = new PK_Verifier_wo_MR(key, encoding);
+   std::auto_ptr<PK_Verifier> verifier(new PK_Verifier_wo_MR(key, encoding));
    verifier->set_input_format(sig_format);
    return verifier;
    }
@@ -65,10 +65,10 @@ PK_Verifier* get_pk_verifier(const PK_Ve
 /*************************************************
 * Get a PK_Key_Agreement object                  *
 *************************************************/
-PK_Key_Agreement* get_pk_kas(const PK_Key_Agreement_Key& key,
+std::auto_ptr<PK_Key_Agreement> get_pk_kas(const PK_Key_Agreement_Key& key,
                              const std::string& kdf)
    {
-   return new PK_Key_Agreement(key, kdf);
+   return std::auto_ptr<PK_Key_Agreement>(new PK_Key_Agreement(key, kdf));
    }
 
 }
============================================================
--- src/make_prm.cpp	d665482d002305b15dd878616f4c78fdb76cf76a
+++ src/make_prm.cpp	f8173bbeed5315fc5b12e0fb891538e1af3051d9
@@ -3,11 +3,14 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/parsing.h>
 #include <botan/libstate.h>
 #include <algorithm>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
@@ -32,8 +35,8 @@ BigInt random_prime(u32bit bits, const B
       global_state().pulse(PRIME_SEARCHING);
 
       BigInt p = random_integer(bits);
-      p.set_bit(bits - 2);
-      p.set_bit(0);
+      p.set_bit(bits - 2,true);
+      p.set_bit(0,true);
 
       if(p % modulo != equiv)
          p += (modulo - p % modulo) + equiv;
============================================================
--- src/mdx_hash.cpp	7e90baec5a8465c7405841bc2d1075fde1165797
+++ src/mdx_hash.cpp	631dfce3ecb73075326869abd960ae1f0b0a3a3e
@@ -90,13 +90,12 @@ void MDx_HashFunction::write_count(byte 
    {
    if(COUNT_SIZE < 8)
       throw Invalid_State("MDx_HashFunction::write_count: COUNT_SIZE < 8");
-
+   
    const u64bit bit_count = count * 8;
-
+   
    if(BIG_BYTE_ENDIAN)
-      store_be(bit_count, out + COUNT_SIZE - 8);
+	    store_be(bit_count, out + COUNT_SIZE - 8);
    else
-      store_le(bit_count, out + COUNT_SIZE - 8);
+   		store_le(bit_count, out + COUNT_SIZE - 8);
    }
-
 }
============================================================
--- src/mem_pool.cpp	399aa8cd9dac6bce28a803b11a262d5e6d1b3fcb
+++ src/mem_pool.cpp	c2dc35b5090c6b768beb28e2926e174e5045dbd2
@@ -9,7 +9,7 @@
 #include <botan/bit_ops.h>
 #include <botan/util.h>
 #include <algorithm>
-
+#include <sstream>
 namespace Botan {
 
 namespace {
@@ -115,7 +115,7 @@ Pooling_Allocator::Pooling_Allocator(u32
 Pooling_Allocator::Pooling_Allocator(u32bit p_size, bool) :
    PREF_SIZE(choose_pref_size(p_size))
    {
-   mutex = global_state().get_mutex();
+   mutex = std::tr1::shared_ptr<Mutex>(global_state().get_mutex().release());
    last_used = blocks.begin();
    }
 
@@ -124,7 +124,6 @@ Pooling_Allocator::~Pooling_Allocator()
 *************************************************/
 Pooling_Allocator::~Pooling_Allocator()
    {
-   delete mutex;
    if(blocks.size())
       throw Invalid_State("Pooling_Allocator: Never released memory");
    }
@@ -182,6 +181,20 @@ void Pooling_Allocator::deallocate(void*
 *************************************************/
 void Pooling_Allocator::deallocate(void* ptr, u32bit n)
    {
+       if(blocks.empty())
+       {
+        // *this is probably already destroyed
+        // (an pooling allocator holding zero blocks cannot have
+        // any allocation anymore)
+        // If we don't return here, the "wrong allocator..."
+        // excpetion below will be thrown if a botan object
+        // with allocation in this allocator gets destroyed after
+        // the LibraryInitializer.
+        // This would happen for
+        //   - global smart pointers to such objects
+        //   - static objects inside functions.
+        return;
+       }
    const u32bit BITMAP_SIZE = Memory_Block::bitmap_size();
    const u32bit BLOCK_SIZE = Memory_Block::block_size();
 
@@ -200,8 +213,15 @@ void Pooling_Allocator::deallocate(void*
          std::lower_bound(blocks.begin(), blocks.end(), Memory_Block(ptr));
 
       if(i == blocks.end() || !i->contains(ptr, block_no))
-         throw Invalid_State("Pointer released to the wrong allocator");
-
+      {
+        std::string message("Pointer released to the wrong allocator, pointer value = ");
+         std::stringstream ss;
+        std::string str_is;
+        ss << std::hex << ptr;
+        ss >> str_is;
+        message.append(str_is);
+         throw Invalid_State(message);
+      }
       i->free(ptr, block_no);
       }
    }
============================================================
--- src/mgf1.cpp	833bdd2150cc0db702b39bc4d799426504dda7d5
+++ src/mgf1.cpp	a140509006083243a96ab87ffa6d8030a221bf80
@@ -7,7 +7,7 @@
 #include <botan/lookup.h>
 #include <botan/bit_ops.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -19,7 +19,7 @@ void MGF1::mask(const byte in[], u32bit 
    {
    u32bit counter = 0;
 
-   std::auto_ptr<HashFunction> hash(get_hash(hash_name));
+   HashFunction::AutoHashFunctionPtr  hash(get_hash(hash_name));
 
    while(out_len)
       {
============================================================
--- src/modebase.cpp	1c98d29fa318a766f53c87ded0f18c6b80fbcbb1
+++ src/modebase.cpp	b575a37a58098e7be2c38db89cf0d56680ee535d
@@ -18,7 +18,7 @@ BlockCipherMode::BlockCipherMode(const s
    BLOCK_SIZE(block_size_of(cipher_name)), BUFFER_SIZE(buf_mult * BLOCK_SIZE),
    IV_METHOD(iv_meth), mode_name(cipher_mode_name)
    {
-   base_ptr = cipher = get_block_cipher(cipher_name);
+   base_ptr = cipher = std::tr1::shared_ptr<BlockCipher>(get_block_cipher(cipher_name).release());
    buffer.create(BUFFER_SIZE);
    state.create(iv_size);
    position = 0;
============================================================
--- src/modules.cpp	310f410a77f14f2b559a24a0a00821880205b6c8
+++ src/modules.cpp	452f861c9ad2622ad188781c1df79ce012692750
@@ -77,54 +77,56 @@ namespace Botan {
 /*************************************************
 * Return a mutex factory, if available           *
 *************************************************/
-Mutex_Factory* Builtin_Modules::mutex_factory() const
+std::tr1::shared_ptr<Mutex_Factory> Builtin_Modules::mutex_factory() const
    {
 #if defined(BOTAN_EXT_MUTEX_PTHREAD)
-   return new Pthread_Mutex_Factory;
+   return std::tr1::shared_ptr<Mutex_Factory>(new Pthread_Mutex_Factory);
 #elif defined(BOTAN_EXT_MUTEX_WIN32)
-   return new Win32_Mutex_Factory;
+   return std::tr1::shared_ptr<Mutex_Factory>(new Win32_Mutex_Factory);
 #elif defined(BOTAN_EXT_MUTEX_QT)
-   return new Qt_Mutex_Factory;
+   return std::tr1::shared_ptr<Mutex_Factory>(new Qt_Mutex_Factory);
 #else
-   return 0;
+   return std::tr1::shared_ptr<Mutex_Factory>();
 #endif
    }
 
 /*************************************************
 * Find a high resolution timer, if possible      *
 *************************************************/
-Timer* Builtin_Modules::timer() const
+std::tr1::shared_ptr<Timer> Builtin_Modules::timer() const
    {
 #if defined(BOTAN_EXT_TIMER_HARDWARE)
-   return new Hardware_Timer;
+   return std::tr1::shared_ptr<Timer>(new Hardware_Timer);
 #elif defined(BOTAN_EXT_TIMER_POSIX)
-   return new POSIX_Timer;
+   return std::tr1::shared_ptr<Timer>(new POSIX_Timer);
 #elif defined(BOTAN_EXT_TIMER_UNIX)
-   return new Unix_Timer;
+   return std::tr1::shared_ptr<Timer>(new Unix_Timer);
 #elif defined(BOTAN_EXT_TIMER_WIN32)
-   return new Win32_Timer;
+   return std::tr1::shared_ptr<Timer>(new Win32_Timer);
 #else
-   return new Timer;
+   return std::tr1::shared_ptr<Timer>(new Timer);
 #endif
    }
 
 /*************************************************
 * Find any usable allocators                     *
 *************************************************/
-std::vector<Allocator*> Builtin_Modules::allocators() const
+std::vector<std::tr1::shared_ptr<Allocator> > Builtin_Modules::allocators() const
    {
-   std::vector<Allocator*> allocators;
+   std::vector<std::tr1::shared_ptr<Allocator> > allocators;
 
 #if defined(BOTAN_EXT_ALLOC_MMAP)
-   allocators.push_back(new MemoryMapping_Allocator);
+   allocators.push_back(std::tr1::shared_ptr<Allocator>(new MemoryMapping_Allocator));
 #endif
 
-   allocators.push_back(new Locking_Allocator);
-   allocators.push_back(new Malloc_Allocator);
+   allocators.push_back(std::tr1::shared_ptr<Allocator>(new Locking_Allocator));
+   allocators.push_back(std::tr1::shared_ptr<Allocator>(new Malloc_Allocator));
 
    return allocators;
    }
 
+
+
 /*************************************************
 * Return the default allocator                   *
 *************************************************/
@@ -145,38 +147,38 @@ std::string Builtin_Modules::default_all
 /*************************************************
 * Register any usable entropy sources            *
 *************************************************/
-std::vector<EntropySource*> Builtin_Modules::entropy_sources() const
+std::vector<std::tr1::shared_ptr<EntropySource> > Builtin_Modules::entropy_sources() const
    {
-   std::vector<EntropySource*> sources;
+   std::vector<std::tr1::shared_ptr<EntropySource> > sources;
 
-   sources.push_back(new File_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new File_EntropySource));
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_AEP)
-   sources.push_back(new AEP_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new AEP_EntropySource));
 #endif
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_EGD)
-   sources.push_back(new EGD_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new EGD_EntropySource));
 #endif
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_CAPI)
-   sources.push_back(new Win32_CAPI_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new Win32_CAPI_EntropySource));
 #endif
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_WIN32)
-   sources.push_back(new Win32_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new Win32_EntropySource));
 #endif
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_UNIX)
-   sources.push_back(new Unix_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new Unix_EntropySource));
 #endif
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_BEOS)
-   sources.push_back(new BeOS_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new BeOS_EntropySource));
 #endif
 
 #if defined(BOTAN_EXT_ENTROPY_SRC_FTW)
-   sources.push_back(new FTW_EntropySource);
+   sources.push_back(std::tr1::shared_ptr<EntropySource>(new FTW_EntropySource));
 #endif
 
    return sources;
@@ -185,26 +187,26 @@ std::vector<EntropySource*> Builtin_Modu
 /*************************************************
 * Find any usable engines                        *
 *************************************************/
-std::vector<Engine*> Builtin_Modules::engines() const
+std::vector<std::tr1::shared_ptr<Engine> > Builtin_Modules::engines() const
    {
-   std::vector<Engine*> engines;
+   std::vector<std::tr1::shared_ptr<Engine> > engines;
 
    if(use_engines)
       {
 #if defined(BOTAN_EXT_ENGINE_AEP)
-      engines.push_back(new AEP_Engine);
+      engines.push_back(std::tr1::shared_ptr<Engine>(new AEP_Engine));
 #endif
 
 #if defined(BOTAN_EXT_ENGINE_GNU_MP)
-      engines.push_back(new GMP_Engine);
+      engines.push_back(std::tr1::shared_ptr<Engine>(new GMP_Engine));
 #endif
 
 #if defined(BOTAN_EXT_ENGINE_OPENSSL)
-      engines.push_back(new OpenSSL_Engine);
+      engines.push_back(std::tr1::shared_ptr<Engine>(new OpenSSL_Engine));
 #endif
       }
 
-   engines.push_back(new Default_Engine);
+   engines.push_back(std::tr1::shared_ptr<Engine>(new Default_Engine));
 
    return engines;
    }
@@ -212,9 +214,9 @@ std::vector<Engine*> Builtin_Modules::en
 /*************************************************
 * Find the best transcoder option                *
 *************************************************/
-Charset_Transcoder* Builtin_Modules::transcoder() const
+std::tr1::shared_ptr<Charset_Transcoder> Builtin_Modules::transcoder() const
    {
-   return new Default_Charset_Transcoder;
+   return std::tr1::shared_ptr<Charset_Transcoder>(new Default_Charset_Transcoder);
    }
 
 /*************************************************
============================================================
--- src/mp_asm.cpp	84dd140ff3a56889afd6b026b0ee40e40120cd83
+++ src/mp_asm.cpp	2100e46f84bba81c9b9e873476bb5152630c9143
@@ -5,7 +5,7 @@
 
 #include <botan/mp_asm.h>
 #include <botan/mp_asmi.h>
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/mem_ops.h>
 
 namespace Botan {
============================================================
--- src/mp_comba.cpp	b6e3cf9668bfeebad0695e1062409cc358ce39d6
+++ src/mp_comba.cpp	574771dbfaceaa4f5fc3974838cd7a2346c6d152
@@ -3,7 +3,7 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/mp_asmi.h>
 
 namespace Botan {
============================================================
--- src/mp_misc.cpp	1602f6ca6969f4c503be6f203b5442b2ae0c1c0a
+++ src/mp_misc.cpp	29ffd85a5fb1b50be8f3935a142f1f121f80ddc7
@@ -3,7 +3,7 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/mp_asm.h>
 
 namespace Botan {
============================================================
--- src/mp_mul.cpp	dafb1262e69f06c17fe781aea9c7ed04ef789829
+++ src/mp_mul.cpp	16e2ea8b58df94ff3036038668a50bf3c1e86fdb
@@ -3,8 +3,9 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/mem_ops.h>
+#include <botan/mp_asm.h>
 
 namespace Botan {
 
============================================================
--- src/mp_mulop.cpp	cfaafb643d3d5960509ca07f8370a044c291730d
+++ src/mp_mulop.cpp	b1e4523a8dfac1d513acf5650d6a6066c09b8df9
@@ -5,7 +5,7 @@
 
 #include <botan/mp_asm.h>
 #include <botan/mp_asmi.h>
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 
 namespace Botan {
 
============================================================
--- src/mp_numth.cpp	1f30af2cd34fe5b7692e984bc9f32e8fecb8fc40
+++ src/mp_numth.cpp	1f77a6614f0bb588b238ed06dcf36a406ce6272d
@@ -3,11 +3,14 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/numthry.h>
-#include <botan/mp_core.h>
+#include <botan/bigintfuncs.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/util.h>
 #include <algorithm>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
@@ -66,4 +69,19 @@ BigInt sub_mul(const BigInt& a, const Bi
    return r;
    }
 
+/*************************************************
+* xor Operation                    *
+*************************************************/
+BigInt exlusive_or(const BigInt& a, const BigInt& b)
+    {
+    int m = std::max(a.bits(),b.bits());
+    BigInt r = a;
+    for (int i=0;i<m;i++)
+        {
+        r.set_bit(i,(a.get_bit(i) && !b.get_bit(i)) || (!a.get_bit(i) && b.get_bit(i)));
+        }
+    return r;
+    }
+
+
 }
============================================================
--- src/mp_shift.cpp	91e212e741dcd78df0619afad5539f779f4684c3
+++ src/mp_shift.cpp	2a1e25e81d0dbfb9020964834bdcc9207a01a758
@@ -3,7 +3,7 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/mem_ops.h>
 
 namespace Botan {
============================================================
--- src/mp_sqr.cpp	de1f9715b8b1420092525f08c1f37428734fce19
+++ src/mp_sqr.cpp	ca128254cff4e7b6ef467cbad8979d51d94dc0ed
@@ -3,7 +3,7 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/mp_core.h>
+#include <botan/bigint/mp_core.h>
 #include <botan/mem_ops.h>
 
 namespace Botan {
============================================================
--- src/mutex.cpp	3e01e31f664f2e669206c92788212288a29ed1e9
+++ src/mutex.cpp	4d7fb694836ade2963f4d6e9c79709d7a0a84e5d
@@ -11,7 +11,7 @@ namespace Botan {
 /*************************************************
 * Mutex_Holder Constructor                       *
 *************************************************/
-Mutex_Holder::Mutex_Holder(Mutex* m) : mux(m)
+Mutex_Holder::Mutex_Holder(SharedPtrConverter<Mutex> m) : mux(m.get_shared())
    {
    if(!mux)
       throw Invalid_Argument("Mutex_Holder: Argument was NULL");
@@ -46,7 +46,7 @@ Named_Mutex_Holder::~Named_Mutex_Holder(
 /*************************************************
 * Default Mutex Factory                          *
 *************************************************/
-Mutex* Default_Mutex_Factory::make()
+std::auto_ptr<Mutex> Default_Mutex_Factory::make()
    {
    class Default_Mutex : public Mutex
       {
@@ -78,7 +78,7 @@ Mutex* Default_Mutex_Factory::make()
          bool locked;
       };
 
-   return new Default_Mutex;
+   return std::auto_ptr<Mutex>(new Default_Mutex);
    }
 
 }
============================================================
--- src/oids.cpp	469aad470e7ec8f275bee3ad392a675828b40aeb
+++ src/oids.cpp	bf5f569d7fe80b0494bbef4d49f4c2d1959bb4de
@@ -6,69 +6,93 @@
 #include <botan/oids.h>
 #include <botan/config.h>
 
-namespace Botan {
+namespace Botan
+  {
 
-namespace OIDS {
+  namespace OIDS
+    {
 
-/*************************************************
-* Register an OID to string mapping              *
-*************************************************/
-void add_oid(const OID& oid, const std::string& name)
-   {
-   const std::string oid_str = oid.as_string();
+    /*************************************************
+    * Register an OID to string mapping              *
+    *************************************************/
+    void add_oid(const OID& oid, const std::string& name)
+    {
+      const std::string oid_str = oid.as_string();
 
-   if(!global_config().is_set("oid2str", oid_str))
-      global_config().set("oid2str", oid_str, name);
-   if(!global_config().is_set("str2oid", name))
-      global_config().set("str2oid", name, oid_str);
-   }
+      if(!global_config().is_set("oid2str", oid_str))
+        global_config().set("oid2str", oid_str, name);
+      if(!global_config().is_set("str2oid", name))
+        global_config().set("str2oid", name, oid_str);
+    }
 
-/*************************************************
-* Do an OID to string lookup                     *
-*************************************************/
-std::string lookup(const OID& oid)
-   {
-   std::string name = global_config().get("oid2str", oid.as_string());
-   if(name == "")
-      return oid.as_string();
-   return name;
-   }
+    /*************************************************
+    * Do an OID to string lookup                     *
+    *************************************************/
+    std::string lookup(const OID& oid)
+    {
+      std::string name = global_config().get("oid2str", oid.as_string());
+      if(name == "")
+        return oid.as_string();
+      return name;
+    }
 
-/*************************************************
-* Do a string to OID lookup                      *
-*************************************************/
-OID lookup(const std::string& name)
-   {
-   std::string value = global_config().get("str2oid", name);
-   if(value != "")
-      return OID(value);
+    /*************************************************
+    * Do a string to OID lookup                      *
+    *************************************************/
+    OID lookup_section(const std::string section, const std::string& name)
+    {
+      std::string value = global_config().get(section, name);
+      if(value != "")
+        return OID(value);
 
-   try
-      {
-      return OID(name);
-      }
-   catch(Exception)
-      {
-      throw Lookup_Error("No object identifier found for " + name);
-      }
-   }
+      try
+        {
+          return OID(name);
+        }
+      catch(Exception)
+        {
+          throw Lookup_Error("No object identifier found for " + name);
+        }
+    }
+    /*OID lookup(const std::string& name)
+    {
+    std::string value = global_config().get("str2oid", name);
+    if(value != "")
+       return OID(value);
 
-/*************************************************
-* Check to see if an OID exists in the table     *
-*************************************************/
-bool have_oid(const std::string& name)
-   {
-   return global_config().is_set("str2oid", name);
-   }
+    try
+       {
+       return OID(name);
+       }
+    catch(Exception)
+       {
+       throw Lookup_Error("No object identifier found for " + name);
+       }
+    }*/
+    OID lookup(const std::string& name)
+    {
+      return lookup_section("str2oid", name);
+    }
+    OID lookup_bsi(const std::string& name)
+    {
+      return lookup_section("str2oid_bsi", name);
+    }
+    /*************************************************
+    * Check to see if an OID exists in the table     *
+    *************************************************/
+    bool have_oid(const std::string& name)
+    {
+      return global_config().is_set("str2oid", name);
+    }
 
-/*************************************************
-* Check to see if an OID exists in the table     *
-*************************************************/
-bool name_of(const OID& oid, const std::string& name)
-   {
-   return (oid == lookup(name));
-   }
+    /*************************************************
+    * Check to see if an OID exists in the table     *
+    *************************************************/
+    bool name_of(const OID& oid, const std::string& name)
+    {
+      return (oid == lookup(name));
+    }
 
-}
+  }
 
 }
============================================================
--- src/out_buf.cpp	c5071a9eb97054a9bb82f5f9ebe48ac01c380a3c
+++ src/out_buf.cpp	23c44c7e44f5d2d17f03fea569c494a0f51851dc
@@ -5,6 +5,7 @@
 
 #include <botan/out_buf.h>
 #include <botan/secqueue.h>
+#include <iostream>
 
 namespace Botan {
 
@@ -13,8 +14,8 @@ u32bit Output_Buffers::read(byte output[
 *************************************************/
 u32bit Output_Buffers::read(byte output[], u32bit length, u32bit msg)
    {
-   SecureQueue* q = get(msg);
-   if(q)
+   std::tr1::shared_ptr<SecureQueue> q = get(msg);
+   if(q.get())
       return q->read(output, length);
    return 0;
    }
@@ -25,8 +26,8 @@ u32bit Output_Buffers::peek(byte output[
 u32bit Output_Buffers::peek(byte output[], u32bit length,
                             u32bit stream_offset, u32bit msg) const
    {
-   SecureQueue* q = get(msg);
-   if(q)
+   std::tr1::shared_ptr<SecureQueue> q = get(msg);
+   if(q.get())
       return q->peek(output, length, stream_offset);
    return 0;
    }
@@ -36,24 +37,25 @@ u32bit Output_Buffers::remaining(u32bit 
 *************************************************/
 u32bit Output_Buffers::remaining(u32bit msg) const
    {
-   SecureQueue* q = get(msg);
-   if(q)
+   std::tr1::shared_ptr<SecureQueue> q = get(msg);
+   if(q.get()) {
       return q->size();
+   }
    return 0;
    }
 
 /*************************************************
 * Add a new output queue                         *
 *************************************************/
-void Output_Buffers::add(SecureQueue* queue)
+void Output_Buffers::add(SharedPtrConverter<SecureQueue> queue)
    {
-   if(!queue)
+   if(!queue.get_shared().get())
       throw Internal_Error("Output_Buffers::add: Argument was NULL");
 
    if(buffers.size() == buffers.max_size())
       throw Internal_Error("Output_Buffers::add: No more room in container");
 
-   buffers.push_back(queue);
+   buffers.push_back(queue.get_shared());
    }
 
 /*************************************************
@@ -63,9 +65,9 @@ void Output_Buffers::retire()
    {
    while(buffers.size())
       {
-      if(buffers[0] == 0 || buffers[0]->size() == 0)
+      if(buffers[0].get() == 0 || buffers[0]->size() == 0)
          {
-         delete buffers[0];
+         buffers[0].reset();
          buffers.pop_front();
          ++offset;
          }
@@ -77,10 +79,10 @@ void Output_Buffers::retire()
 /*************************************************
 * Get a particular output queue                  *
 *************************************************/
-SecureQueue* Output_Buffers::get(u32bit msg) const
+std::tr1::shared_ptr<SecureQueue> Output_Buffers::get(u32bit msg) const
    {
    if(msg < offset)
-      return 0;
+      return std::tr1::shared_ptr<SecureQueue>();
    if(msg > message_count())
       throw Internal_Error("Output_Buffers::get: msg > size");
 
@@ -108,8 +110,7 @@ Output_Buffers::~Output_Buffers()
 *************************************************/
 Output_Buffers::~Output_Buffers()
    {
-   for(u32bit j = 0; j != buffers.size(); ++j)
-      delete buffers[j];
+
    }
 
 }
============================================================
--- src/par_hash.cpp	5a4195295bd429573b4f93dbf0dc62c4eb7f810d
+++ src/par_hash.cpp	b9972eb378866f0f325d5dc1469b11c9b3260aaa
@@ -63,12 +63,12 @@ std::string Parallel::name() const
 /*************************************************
 * Return a clone of this object                  *
 *************************************************/
-HashFunction* Parallel::clone() const
+HashFunction::AutoHashFunctionPtr Parallel::clone() const
    {
    std::vector<std::string> names;
    for(u32bit j = 0; j != hashes.size(); ++j)
       names.push_back(hashes[j]->name());
-   return new Parallel(names);
+   return AutoHashFunctionPtr(new Parallel(names));
    }
 
 /*************************************************
@@ -87,7 +87,7 @@ Parallel::Parallel(const std::vector<std
    HashFunction(sum_of_hash_lengths(names))
    {
    for(u32bit j = 0; j != names.size(); ++j)
-      hashes.push_back(get_hash(names[j]));
+      hashes.push_back(SharedHashFunctionPtr(get_hash(names[j]).release()));
    }
 
 /*************************************************
@@ -95,8 +95,5 @@ Parallel::~Parallel()
 *************************************************/
 Parallel::~Parallel()
    {
-   for(u32bit j = 0; j != hashes.size(); ++j)
-      delete hashes[j];
    }
-
 }
============================================================
--- src/pbes1.cpp	3285313a3d998f049c48d73817a98b548d2c4990
+++ src/pbes1.cpp	9be895fad03767a75857f56c3de14dd44f78e544
@@ -10,7 +10,7 @@
 #include <botan/lookup.h>
 #include <botan/rng.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -70,7 +70,7 @@ void PBE_PKCS5v15::set_key(const std::st
 *************************************************/
 void PBE_PKCS5v15::set_key(const std::string& passphrase)
    {
-   std::auto_ptr<S2K> pbkdf(get_s2k("PBKDF1(" + digest + ")"));
+   std::tr1::shared_ptr<S2K> pbkdf(get_s2k("PBKDF1(" + digest + ")").release());
    pbkdf->set_iterations(iterations);
    pbkdf->change_salt(salt, salt.size());
    SymmetricKey key_and_iv = pbkdf->derive_key(16, passphrase);
@@ -105,9 +105,9 @@ MemoryVector<byte> PBE_PKCS5v15::encode_
 /*************************************************
 * Decode PKCS#5 PBES1 parameters                 *
 *************************************************/
-void PBE_PKCS5v15::decode_params(DataSource& source)
+void PBE_PKCS5v15::decode_params(SharedPtrConverter<DataSource> source)
    {
-   BER_Decoder(source)
+   BER_Decoder(source.get_shared())
       .start_cons(SEQUENCE)
          .decode(salt, OCTET_STRING)
          .decode(iterations)
@@ -126,16 +126,20 @@ OID PBE_PKCS5v15::get_oid() const
    const OID base_pbes1_oid("1.2.840.113549.1.5");
    if(cipher == "DES/CBC" && digest == "MD2")
       return (base_pbes1_oid + 1);
+      /*
    else if(cipher == "DES/CBC" && digest == "MD5")
       return (base_pbes1_oid + 3);
+      */
    else if(cipher == "DES/CBC" && digest == "SHA-160")
       return (base_pbes1_oid + 10);
+      /*
    else if(cipher == "RC2/CBC" && digest == "MD2")
       return (base_pbes1_oid + 4);
    else if(cipher == "RC2/CBC" && digest == "MD5")
       return (base_pbes1_oid + 6);
    else if(cipher == "RC2/CBC" && digest == "SHA-160")
       return (base_pbes1_oid + 11);
+      */
    else
       throw Internal_Error("PBE-PKCS5 v1.5: get_oid() has run out of options");
    }
============================================================
--- src/pbes2.cpp	b30dfcb03d8bd7642027a2ae878c95087ac8a572
+++ src/pbes2.cpp	a29bb46832a9de2d7fa03d636c04fe5f70ec164d
@@ -12,7 +12,7 @@
 #include <botan/asn1_obj.h>
 #include <botan/oids.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -72,7 +72,7 @@ void PBE_PKCS5v20::set_key(const std::st
 *************************************************/
 void PBE_PKCS5v20::set_key(const std::string& passphrase)
    {
-   std::auto_ptr<S2K> pbkdf(get_s2k("PBKDF2(" + digest + ")"));
+   std::tr1::shared_ptr<S2K> pbkdf(get_s2k("PBKDF2(" + digest + ")").release());
    pbkdf->set_iterations(iterations);
    pbkdf->change_salt(salt, salt.size());
    key = pbkdf->derive_key(key_length, passphrase).bits_of();
@@ -123,11 +123,11 @@ MemoryVector<byte> PBE_PKCS5v20::encode_
 /*************************************************
 * Decode PKCS#5 PBES2 parameters                 *
 *************************************************/
-void PBE_PKCS5v20::decode_params(DataSource& source)
+void PBE_PKCS5v20::decode_params(SharedPtrConverter<DataSource> source)
    {
    AlgorithmIdentifier kdf_algo, enc_algo;
 
-   BER_Decoder(source)
+   BER_Decoder(source.get_shared())
       .start_cons(SEQUENCE)
          .decode(kdf_algo)
          .decode(enc_algo)
@@ -218,9 +218,9 @@ PBE_PKCS5v20::PBE_PKCS5v20(const std::st
 /*************************************************
 * PKCS#5 v2.0 PBE Constructor                    *
 *************************************************/
-PBE_PKCS5v20::PBE_PKCS5v20(DataSource& params) : direction(DECRYPTION)
+PBE_PKCS5v20::PBE_PKCS5v20(SharedPtrConverter<DataSource> params) : direction(DECRYPTION)
    {
-   decode_params(params);
+   decode_params(params.get_shared());
    }
 
 }
============================================================
--- src/pem.cpp	502e34643de00820f3dbd8da75c65dd6b62ad056
+++ src/pem.cpp	dc481f6560c2c37a51d85e7ff5e73dc25a7e95cd
@@ -25,7 +25,7 @@ std::string encode(const byte der[], u32
    const std::string PEM_HEADER = "-----BEGIN " + label + "-----\n";
    const std::string PEM_TRAILER = "-----END " + label + "-----\n";
 
-   Pipe pipe(new Base64_Encoder(true, PEM_WIDTH));
+   Pipe pipe(create_shared_ptr<Base64_Encoder>(true, PEM_WIDTH));
    pipe.process_msg(der, length);
    return (PEM_HEADER + pipe.read_all_as_string() + PEM_TRAILER);
    }
@@ -41,11 +41,11 @@ std::string encode(const MemoryRegion<by
 /*************************************************
 * Decode PEM down to raw BER/DER                 *
 *************************************************/
-SecureVector<byte> decode_check_label(DataSource& source,
+SecureVector<byte> decode_check_label(SharedPtrConverter<DataSource> source,
                                       const std::string& label_want)
    {
    std::string label_got;
-   SecureVector<byte> ber = decode(source, label_got);
+   SecureVector<byte> ber = decode(source.get_shared(), label_got);
    if(label_got != label_want)
       throw Decoding_Error("PEM: Label mismatch, wanted " + label_want +
                            ", got " + label_got);
@@ -55,7 +55,7 @@ SecureVector<byte> decode_check_label(Da
 /*************************************************
 * Decode PEM down to raw BER/DER                 *
 *************************************************/
-SecureVector<byte> decode(DataSource& source, std::string& label)
+SecureVector<byte> decode(SharedPtrConverter<DataSource> source, std::string& label)
    {
    const u32bit RANDOM_CHAR_LIMIT =
       global_config().option_as_u32bit("pem/forgive");
@@ -67,7 +67,7 @@ SecureVector<byte> decode(DataSource& so
    while(position != PEM_HEADER1.length())
       {
       byte b;
-      if(!source.read_byte(b))
+      if(!source.get_shared()->read_byte(b))
          throw Decoding_Error("PEM: No PEM header found");
       if(b == PEM_HEADER1[position])
          ++position;
@@ -80,7 +80,7 @@ SecureVector<byte> decode(DataSource& so
    while(position != PEM_HEADER2.length())
       {
       byte b;
-      if(!source.read_byte(b))
+      if(!source.get_shared()->read_byte(b))
          throw Decoding_Error("PEM: No PEM header found");
       if(b == PEM_HEADER2[position])
          ++position;
@@ -91,7 +91,7 @@ SecureVector<byte> decode(DataSource& so
          label += static_cast<char>(b);
       }
 
-   Pipe base64(new Base64_Decoder);
+   Pipe base64(create_shared_ptr<Base64_Decoder>());
    base64.start_msg();
 
    const std::string PEM_TRAILER = "-----END " + label + "-----";
@@ -99,7 +99,7 @@ SecureVector<byte> decode(DataSource& so
    while(position != PEM_TRAILER.length())
       {
       byte b;
-      if(!source.read_byte(b))
+      if(!source.get_shared()->read_byte(b))
          throw Decoding_Error("PEM: No PEM trailer found");
       if(b == PEM_TRAILER[position])
          ++position;
@@ -116,7 +116,7 @@ SecureVector<byte> decode(DataSource& so
 /*************************************************
 * Search for a PEM signature                     *
 *************************************************/
-bool matches(DataSource& source, const std::string& extra)
+bool matches(SharedPtrConverter<DataSource> source, const std::string& extra)
    {
    const u32bit PEM_SEARCH_RANGE =
       global_config().option_as_u32bit("pem/search");
@@ -124,7 +124,7 @@ bool matches(DataSource& source, const s
    const std::string PEM_HEADER = "-----BEGIN " + extra;
 
    SecureVector<byte> search_buf(PEM_SEARCH_RANGE);
-   u32bit got = source.peek(search_buf, search_buf.size(), 0);
+   u32bit got = source.get_shared()->peek(search_buf, search_buf.size(), 0);
 
    if(got < PEM_HEADER.length())
       return false;
============================================================
--- src/pipe.cpp	945e1ff54a457469193ea353a6a51ae7888a167e
+++ src/pipe.cpp	d5b488649d847568434b18a9edb1e1e78e8ad01f
@@ -6,6 +6,7 @@
 #include <botan/pipe.h>
 #include <botan/out_buf.h>
 #include <botan/secqueue.h>
+#include <iostream>
 
 namespace Botan {
 
@@ -26,7 +27,14 @@ class Null_Filter : public Filter
 /*************************************************
 * Pipe Constructor                               *
 *************************************************/
-Pipe::Pipe(Filter* f1, Filter* f2, Filter* f3, Filter* f4)
+Pipe::Pipe(SharedFilterPtrConverter const& f1,
+           SharedFilterPtrConverter const& f2,
+           SharedFilterPtrConverter const& f3,
+           SharedFilterPtrConverter const& f4)
+  : pipe(),
+    outputs(),
+    default_read(0),
+    inside_msg(false)
    {
    init();
    append(f1);
@@ -36,22 +44,11 @@ Pipe::Pipe(Filter* f1, Filter* f2, Filte
    }
 
 /*************************************************
-* Pipe Constructor                               *
-*************************************************/
-Pipe::Pipe(Filter* filter_array[], u32bit count)
-   {
-   init();
-   for(u32bit j = 0; j != count; ++j)
-      append(filter_array[j]);
-   }
-
-/*************************************************
 * Pipe Destructor                                *
 *************************************************/
 Pipe::~Pipe()
    {
    destruct(pipe);
-   delete outputs;
    }
 
 /*************************************************
@@ -59,10 +56,10 @@ void Pipe::init()
 *************************************************/
 void Pipe::init()
    {
-   outputs = new Output_Buffers;
-   pipe = 0;
-   default_read = 0;
-   inside_msg = false;
+     outputs.reset(new Output_Buffers);
+     pipe.reset();
+     default_read = 0;
+     inside_msg = false;
    }
 
 /*************************************************
@@ -73,28 +70,29 @@ void Pipe::reset()
    if(inside_msg)
       throw Invalid_State("Pipe cannot be reset while it is processing");
    destruct(pipe);
-   pipe = 0;
    inside_msg = false;
    }
 
 /*************************************************
 * Destroy the Pipe                               *
 *************************************************/
-void Pipe::destruct(Filter* to_kill)
+void Pipe::destruct(Filter::SharedFilterPtr& to_kill)
    {
-   if(!to_kill || dynamic_cast<SecureQueue*>(to_kill))
+   if(!to_kill.get() || dynamic_cast<SecureQueue*>(to_kill.get()))
       return;
-   for(u32bit j = 0; j != to_kill->total_ports(); ++j)
+   for(u32bit j = 0; j != to_kill->total_ports(); ++j) {
       destruct(to_kill->next[j]);
-   delete to_kill;
    }
+   to_kill->owned = false;
+   to_kill.reset();
+   }
 
 /*************************************************
 * Test if the Pipe has any data in it            *
 *************************************************/
 bool Pipe::end_of_data() const
    {
-   return (remaining() == 0);
+   return (remaining() == 0); // remaining(u32bit = DEFAULT_MESSAGE)
    }
 
 /*************************************************
@@ -150,8 +148,8 @@ void Pipe::start_msg()
    {
    if(inside_msg)
       throw Invalid_State("Pipe::start_msg: Message was already started");
-   if(pipe == 0)
-      pipe = new Null_Filter;
+   if(!pipe.get())
+      pipe = create_shared_ptr<Null_Filter>();
    find_endpoints(pipe);
    pipe->new_msg();
    inside_msg = true;
@@ -166,10 +164,11 @@ void Pipe::end_msg()
       throw Invalid_State("Pipe::end_msg: Message was already ended");
    pipe->finish_msg();
    clear_endpoints(pipe);
-   if(dynamic_cast<Null_Filter*>(pipe))
+//   if(std::tr1::dynamic_pointer_cast<Null_Filter>(pipe))
+   if(dynamic_cast<Null_Filter*>(pipe.get()))
       {
-      delete pipe;
-      pipe = 0;
+      pipe->owned = false; // really necessary?
+      pipe.reset();
       }
    inside_msg = false;
 
@@ -179,14 +178,15 @@ void Pipe::end_msg()
 /*************************************************
 * Find the endpoints of the Pipe                 *
 *************************************************/
-void Pipe::find_endpoints(Filter* f)
+void Pipe::find_endpoints(const Filter::SharedFilterPtr& f)
    {
    for(u32bit j = 0; j != f->total_ports(); ++j)
-      if(f->next[j] && !dynamic_cast<SecureQueue*>(f->next[j]))
+     //if((f->next[j]).get() && !std::tr1::dynamic_pointer_cast<SecureQueue>(f->next[j]))
+     if((f->next[j]).get() && !dynamic_cast<SecureQueue*>((f->next[j]).get()))
          find_endpoints(f->next[j]);
       else
          {
-         SecureQueue* q = new SecureQueue;
+         std::tr1::shared_ptr<SecureQueue> q = create_shared_ptr<SecureQueue>();
          f->next[j] = q;
          outputs->add(q);
          }
@@ -195,13 +195,14 @@ void Pipe::find_endpoints(Filter* f)
 /*************************************************
 * Remove the SecureQueues attached to the Filter *
 *************************************************/
-void Pipe::clear_endpoints(Filter* f)
+void Pipe::clear_endpoints(const Filter::SharedFilterPtr& f)
    {
-   if(!f) return;
+   if(!f.get()) return;
    for(u32bit j = 0; j != f->total_ports(); ++j)
       {
-      if(f->next[j] && dynamic_cast<SecureQueue*>(f->next[j]))
-         f->next[j] = 0;
+      //if((f->next[j]).get() && std::tr1::dynamic_pointer_cast<SecureQueue>(f->next[j]))
+      if((f->next[j]).get() && dynamic_cast<SecureQueue*>((f->next[j]).get()))
+        f->next[j] = Filter::SharedFilterPtr();
       clear_endpoints(f->next[j]);
       }
    }
@@ -209,40 +210,44 @@ void Pipe::clear_endpoints(Filter* f)
 /*************************************************
 * Append a Filter to the Pipe                    *
 *************************************************/
-void Pipe::append(Filter* filter)
+void Pipe::append(SharedFilterPtrConverter const& filter_converter)
    {
+   SharedFilterPtr filter(filter_converter.get_shared());
    if(inside_msg)
       throw Invalid_State("Cannot append to a Pipe while it is processing");
-   if(!filter)
+   if(!filter.get())
       return;
-   if(dynamic_cast<SecureQueue*>(filter))
+   //if(std::tr1::dynamic_pointer_cast<SecureQueue>(filter))
+   if( dynamic_cast<SecureQueue*>(filter.get()))
       throw Invalid_Argument("Pipe::append: SecureQueue cannot be used");
    if(filter->owned)
       throw Invalid_Argument("Filters cannot be shared among multiple Pipes");
 
    filter->owned = true;
 
-   if(!pipe) pipe = filter;
+   if(!pipe.get()) pipe = filter;
    else      pipe->attach(filter);
    }
 
 /*************************************************
 * Prepend a Filter to the Pipe                   *
 *************************************************/
-void Pipe::prepend(Filter* filter)
+void Pipe::prepend(SharedFilterPtrConverter const& filter_converter)
    {
+   SharedFilterPtr filter(filter_converter.get_shared());
    if(inside_msg)
       throw Invalid_State("Cannot prepend to a Pipe while it is processing");
-   if(!filter)
+   if(!filter.get())
       return;
-   if(dynamic_cast<SecureQueue*>(filter))
+   //if(std::tr1::dynamic_pointer_cast<SecureQueue>(filter))
+   if( dynamic_cast<SecureQueue*>(filter.get()))
       throw Invalid_Argument("Pipe::prepend: SecureQueue cannot be used");
    if(filter->owned)
       throw Invalid_Argument("Filters cannot be shared among multiple Pipes");
 
    filter->owned = true;
 
-   if(pipe) filter->attach(pipe);
+   if(pipe.get()) filter->attach(pipe);
    pipe = filter;
    }
 
@@ -254,22 +259,22 @@ void Pipe::pop()
    if(inside_msg)
       throw Invalid_State("Cannot pop off a Pipe while it is processing");
 
-   if(!pipe)
+   if(!pipe.get())
       return;
 
    if(pipe->total_ports() > 1)
       throw Invalid_State("Cannot pop off a Filter with multiple ports");
 
-   Filter* f = pipe;
+   Filter::SharedFilterPtr f = pipe;
    u32bit owns = f->owns();
    pipe = pipe->next[0];
-   delete f;
+   f->owned = false; // really necessary?
 
    while(owns--)
       {
       f = pipe;
       pipe = pipe->next[0];
-      delete f;
+      f->owned = false; // really necessary?
       }
    }
 
============================================================
--- src/pipe_io.cpp	0ac139738c9b5f02e1efc95f746b170922297e7a
+++ src/pipe_io.cpp	0be76612df3854bf235daca77962b8dd9ca670bf
@@ -5,7 +5,7 @@
 
 #include <botan/pipe.h>
 #include <iostream>
-
+#include <botan/util.h>
 namespace Botan {
 
 /*************************************************
@@ -17,7 +17,7 @@ std::ostream& operator<<(std::ostream& s
    while(stream.good() && pipe.remaining())
       {
       u32bit got = pipe.read(buffer, buffer.size());
-      stream.write(reinterpret_cast<const char*>(buffer.begin()), got);
+      stream.write(pointer_cast<const char, const byte>(buffer.begin()), got);
       }
    if(!stream.good())
       throw Stream_IO_Error("Pipe output operator (iostream) has failed");
@@ -32,7 +32,8 @@ std::istream& operator>>(std::istream& s
    SecureVector<byte> buffer(DEFAULT_BUFFERSIZE);
    while(stream.good())
       {
-      stream.read(reinterpret_cast<char*>(buffer.begin()), buffer.size());
+      //stream.read(reinterpret_cast<char*>(buffer.begin()), buffer.size());
+      stream.read(pointer_cast<char, const byte>(buffer.begin()), buffer.size());
       pipe.write(buffer, stream.gcount());
       }
    if(stream.bad() || (stream.fail() && !stream.eof()))
============================================================
--- src/pk_algs.cpp	ffddb4b9ede9d795bbf8aebe0b01b0871fb8dc97
+++ src/pk_algs.cpp	b1c82f967c7553c7ba7cadebb76e2564f9098e6a
@@ -5,42 +5,33 @@
 
 #include <botan/pk_algs.h>
 #include <botan/rsa.h>
-#include <botan/dsa.h>
 #include <botan/dh.h>
-#include <botan/nr.h>
-#include <botan/rw.h>
-#include <botan/elgamal.h>
+#include <botan/ec.h>
 
 namespace Botan {
 
 /*************************************************
 * Get an PK public key object                    *
 *************************************************/
-Public_Key* get_public_key(const std::string& alg_name)
+std::auto_ptr<Public_Key> get_public_key(const std::string& alg_name)
    {
-   if(alg_name == "RSA")      return new RSA_PublicKey;
-   else if(alg_name == "DSA") return new DSA_PublicKey;
-   else if(alg_name == "DH")  return new DH_PublicKey;
-   else if(alg_name == "NR")  return new NR_PublicKey;
-   else if(alg_name == "RW")  return new RW_PublicKey;
-   else if(alg_name == "ELG") return new ElGamal_PublicKey;
+   if(alg_name == "RSA")      return std::auto_ptr<Public_Key>(new RSA_PublicKey);
+   else if(alg_name == "DH")  return std::auto_ptr<Public_Key>(new DH_PublicKey);
+   else if(alg_name == "ECDSA") return std::auto_ptr<Public_Key>(new ECDSA_PublicKey);
    else
-      return 0;
+      return std::auto_ptr<Public_Key>();
    }
 
 /*************************************************
 * Get an PK private key object                   *
 *************************************************/
-Private_Key* get_private_key(const std::string& alg_name)
+std::auto_ptr<Private_Key> get_private_key(const std::string& alg_name)
    {
-   if(alg_name == "RSA")      return new RSA_PrivateKey;
-   else if(alg_name == "DSA") return new DSA_PrivateKey;
-   else if(alg_name == "DH")  return new DH_PrivateKey;
-   else if(alg_name == "NR")  return new NR_PrivateKey;
-   else if(alg_name == "RW")  return new RW_PrivateKey;
-   else if(alg_name == "ELG") return new ElGamal_PrivateKey;
+   if(alg_name == "RSA")      return std::auto_ptr<Private_Key>(new RSA_PrivateKey);
+   else if(alg_name == "DH")  return std::auto_ptr<Private_Key>(new DH_PrivateKey);
+   else if(alg_name == "ECDSA") return std::auto_ptr<Private_Key>(new ECDSA_PrivateKey);
    else
-      return 0;
+      return std::auto_ptr<Private_Key>();
    }
 
 }
============================================================
--- src/pk_core.cpp	e451087382e2c3ab0d8f3624f07891afe1fb22aa
+++ src/pk_core.cpp	b0e02b33b90acc039c36b0cec0bb73404686db55
@@ -4,11 +4,16 @@
 *************************************************/
 
 #include <botan/pk_core.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/engine.h>
 #include <botan/config.h>
 #include <algorithm>
+#include <assert.h>
 
+
+using namespace Botan::math;
+using namespace Botan::math::ec;
+
 namespace Botan {
 
 namespace {
@@ -50,9 +55,9 @@ IF_Core::IF_Core(const IF_Core& core)
 *************************************************/
 IF_Core::IF_Core(const IF_Core& core)
    {
-   op = 0;
-   if(core.op)
-      op = core.op->clone();
+   op.reset();
+   if(core.op.get())
+      op = std::tr1::shared_ptr<IF_Operation>(core.op->clone().release());
    blinder = core.blinder;
    }
 
@@ -61,9 +66,9 @@ IF_Core& IF_Core::operator=(const IF_Cor
 *************************************************/
 IF_Core& IF_Core::operator=(const IF_Core& core)
    {
-   delete op;
-   if(core.op)
-      op = core.op->clone();
+   op.reset();
+   if(core.op.get())
+      op = std::tr1::shared_ptr<IF_Operation>(core.op->clone().release());
    blinder = core.blinder;
    return (*this);
    }
@@ -87,24 +92,27 @@ BigInt IF_Core::private_op(const BigInt&
 /*************************************************
 * DSA_Core Constructor                           *
 *************************************************/
+/*
 DSA_Core::DSA_Core(const DL_Group& group, const BigInt& y, const BigInt& x)
    {
    op = Engine_Core::dsa_op(group, y, x);
    }
-
+*/
 /*************************************************
 * DSA_Core Copy Constructor                      *
 *************************************************/
-DSA_Core::DSA_Core(const DSA_Core& core)
+/*
+ DSA_Core::DSA_Core(const DSA_Core& core)
    {
    op = 0;
    if(core.op)
       op = core.op->clone();
    }
-
+*/
 /*************************************************
 * DSA_Core Assignment Operator                   *
 *************************************************/
+/*
 DSA_Core& DSA_Core::operator=(const DSA_Core& core)
    {
    delete op;
@@ -112,46 +120,51 @@ DSA_Core& DSA_Core::operator=(const DSA_
       op = core.op->clone();
    return (*this);
    }
-
+*/
 /*************************************************
 * DSA Verification Operation                     *
 *************************************************/
+/*
 bool DSA_Core::verify(const byte msg[], u32bit msg_length,
                       const byte sig[], u32bit sig_length) const
    {
    return op->verify(msg, msg_length, sig, sig_length);
    }
-
+*/
 /*************************************************
 * DSA Signature Operation                        *
 *************************************************/
+/*
 SecureVector<byte> DSA_Core::sign(const byte in[], u32bit length,
                                   const BigInt& k) const
    {
    return op->sign(in, length, k);
    }
-
+*/
 /*************************************************
 * NR_Core Constructor                            *
 *************************************************/
+/*
 NR_Core::NR_Core(const DL_Group& group, const BigInt& y, const BigInt& x)
    {
    op = Engine_Core::nr_op(group, y, x);
    }
-
+*/
 /*************************************************
 * NR_Core Copy Constructor                       *
 *************************************************/
+/*
 NR_Core::NR_Core(const NR_Core& core)
    {
    op = 0;
    if(core.op)
       op = core.op->clone();
    }
-
+*/
 /*************************************************
 * NR_Core Assignment Operator                    *
 *************************************************/
+/*
 NR_Core& NR_Core::operator=(const NR_Core& core)
    {
    delete op;
@@ -159,27 +172,30 @@ NR_Core& NR_Core::operator=(const NR_Cor
       op = core.op->clone();
    return (*this);
    }
-
+*/
 /*************************************************
 * NR Verification Operation                      *
 *************************************************/
+/*
 SecureVector<byte> NR_Core::verify(const byte in[], u32bit length) const
    {
    return op->verify(in, length);
    }
-
+*/
 /*************************************************
 * NR Signature Operation                         *
 *************************************************/
+/*
 SecureVector<byte> NR_Core::sign(const byte in[], u32bit length,
                                  const BigInt& k) const
    {
    return op->sign(in, length, k);
    }
-
+*/
 /*************************************************
 * ELG_Core Constructor                           *
 *************************************************/
+/*
 ELG_Core::ELG_Core(const DL_Group& group, const BigInt& y, const BigInt& x)
    {
    op = Engine_Core::elg_op(group, y, x);
@@ -195,10 +211,11 @@ ELG_Core::ELG_Core(const DL_Group& group
          blinder = Blinder(k, power_mod(k, x, p), p);
       }
    }
-
+*/
 /*************************************************
 * ELG_Core Copy Constructor                      *
 *************************************************/
+/*
 ELG_Core::ELG_Core(const ELG_Core& core)
    {
    op = 0;
@@ -207,10 +224,11 @@ ELG_Core::ELG_Core(const ELG_Core& core)
    blinder = core.blinder;
    p_bytes = core.p_bytes;
    }
-
+*/
 /*************************************************
 * ELG_Core Assignment Operator                   *
 *************************************************/
+/*
 ELG_Core& ELG_Core::operator=(const ELG_Core& core)
    {
    delete op;
@@ -220,19 +238,21 @@ ELG_Core& ELG_Core::operator=(const ELG_
    p_bytes = core.p_bytes;
    return (*this);
    }
-
+*/
 /*************************************************
 * ElGamal Encrypt Operation                      *
 *************************************************/
+/*
 SecureVector<byte> ELG_Core::encrypt(const byte in[], u32bit length,
                                      const BigInt& k) const
    {
    return op->encrypt(in, length, k);
    }
-
+*/
 /*************************************************
 * ElGamal Decrypt Operation                      *
 *************************************************/
+/*
 SecureVector<byte> ELG_Core::decrypt(const byte in[], u32bit length) const
    {
    if(length != 2*p_bytes)
@@ -243,7 +263,7 @@ SecureVector<byte> ELG_Core::decrypt(con
 
    return BigInt::encode(blinder.unblind(op->decrypt(blinder.blind(a), b)));
    }
-
+*/
 /*************************************************
 * DH_Core Constructor                            *
 *************************************************/
@@ -262,9 +282,9 @@ DH_Core::DH_Core(const DH_Core& core)
 *************************************************/
 DH_Core::DH_Core(const DH_Core& core)
    {
-   op = 0;
-   if(core.op)
-      op = core.op->clone();
+   op.reset();
+   if(core.op.get())
+       op = std::tr1::shared_ptr<DH_Operation>(core.op->clone().release());
    blinder = core.blinder;
    }
 
@@ -273,9 +293,9 @@ DH_Core& DH_Core::operator=(const DH_Cor
 *************************************************/
 DH_Core& DH_Core::operator=(const DH_Core& core)
    {
-   delete op;
-   if(core.op)
-      op = core.op->clone();
+   op.reset();
+   if(core.op.get())
+      op = std::tr1::shared_ptr<DH_Operation>(core.op->clone().release());
    blinder = core.blinder;
    return (*this);
    }
@@ -288,4 +308,97 @@ BigInt DH_Core::agree(const BigInt& i) c
    return blinder.unblind(op->agree(blinder.blind(i)));
    }
 
+/*************************************************
+* ECKAEG Operation                               *
+*************************************************/
+/*************************************************
+* ECKAEG_Core Constructor                        *
+*************************************************/
+ECKAEG_Core::ECKAEG_Core(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key)
+{
+    op = Engine_Core::eckaeg_op(dom_pars, priv_key, pub_key);
 }
+
+/*
+ECKAEG_Core::ECKAEG_Core(const DL_Group& group, const BigInt& x)
+   {
+   op = Engine_Core::eckaeg_op();
+
+   const BigInt& p = group.get_p();
+   BigInt k = blinding_factor(p.bits());
+   if(k != 0)
+      blinder = Blinder(k, power_mod(inverse_mod(k, p), x, p), p);
+   }
+*/
+/*************************************************
+* ECKAEG_Core Copy Constructor                   *
+*************************************************/
+ECKAEG_Core::ECKAEG_Core(const ECKAEG_Core& core)
+   {
+   op.reset();
+   if(core.op.get())
+       op = std::tr1::shared_ptr<ECKAEG_Operation>(core.op->clone().release());
+   blinder = core.blinder;
+   }
+
+/*************************************************
+* ECKAEG_Core Assignment Operator                *
+*************************************************/
+ECKAEG_Core& ECKAEG_Core::operator=(const ECKAEG_Core& core)
+   {
+   op.reset();
+   if(core.op.get())
+       {
+       op = std::tr1::shared_ptr<ECKAEG_Operation>(core.op->clone().release());
+       }
+   blinder = core.blinder;
+   return (*this);
+   }
+
+/*************************************************
+* ECKAEG Operation                               *
+*************************************************/
+SecureVector<byte> ECKAEG_Core::agree(const PointGFp& otherKey) const
+   {
+   assert(op.get());
+   return op->agree(otherKey);
+   }
+
+
+
+/*************************************************
+* ECDSA Operation                                *
+*************************************************/
+bool const ECDSA_Core::verify(const byte signature[], u32bit sig_len, const byte message[], u32bit mess_len) const
+{
+    assert(op.get());
+    return op->verify(signature, sig_len, message, mess_len);
+}
+SecureVector<byte> const ECDSA_Core::sign(const byte message[], u32bit mess_len) const
+{
+    assert(op.get());
+    return op->sign(message, mess_len);
+}
+ECDSA_Core& ECDSA_Core::operator=(const ECDSA_Core& core)
+{
+    op.reset();
+    if(core.op.get())
+    {
+    op = std::tr1::shared_ptr<ECDSA_Operation>(core.op->clone().release());
+    }
+    return (*this);
+}
+ECDSA_Core::ECDSA_Core(const ECDSA_Core& core)
+{
+    op.reset();
+    if(core.op.get())
+    {
+    op = std::tr1::shared_ptr<ECDSA_Operation>(core.op->clone().release());
+    }
+}
+ECDSA_Core::ECDSA_Core(EC_Domain_Params const& dom_pars, BigInt const& priv_key, PointGFp const& pub_key)
+{
+    op = Engine_Core::ecdsa_op(dom_pars, priv_key, pub_key);
+}
+
+}
============================================================
--- src/pk_filts.cpp	4007d826375c8f84ddf27f83b857c16f619a288c
+++ src/pk_filts.cpp	212c704b8116ff92d230ca282df9027663724df8
@@ -95,18 +95,18 @@ void PK_Verifier_Filter::set_signature(c
 /*************************************************
 * PK_Verifier_Filter Constructor                 *
 *************************************************/
-PK_Verifier_Filter::PK_Verifier_Filter(PK_Verifier* v, const byte sig[],
+PK_Verifier_Filter::PK_Verifier_Filter(SharedPtrConverter<PK_Verifier> const& v, const byte sig[],
                                        u32bit length) :
-   verifier(v), signature(sig, length)
+   verifier(v.get_shared()), signature(sig, length)
    {
    }
 
 /*************************************************
 * PK_Verifier_Filter Constructor                 *
 *************************************************/
-PK_Verifier_Filter::PK_Verifier_Filter(PK_Verifier* v,
+PK_Verifier_Filter::PK_Verifier_Filter(SharedPtrConverter<PK_Verifier> const& v,
                                        const MemoryRegion<byte>& sig) :
-   verifier(v), signature(sig)
+   verifier(v.get_shared()), signature(sig)
    {
    }
 
============================================================
--- src/pk_keys.cpp	5b7fa873a16d72e3a111cb658a8d33a47bebb05b
+++ src/pk_keys.cpp	b2bb937f506ec78b57e3df0350c48b5bebc906c8
@@ -6,6 +6,8 @@
 #include <botan/pk_keys.h>
 #include <botan/config.h>
 #include <botan/oids.h>
+#include <botan/x509_key.h>
+#include <botan/pkcs8.h>
 
 namespace Botan {
 
@@ -25,6 +27,36 @@ bool key_check_level(const std::string& 
 }
 
 /*************************************************
+* Factories for Public Key x509 En-/Decoder      *
+*************************************************/
+
+std::auto_ptr<X509_Encoder> Public_Key::x509_encoder() const 
+   { 
+   return std::auto_ptr<X509_Encoder>(); 
+   }
+
+std::auto_ptr<X509_Decoder> Public_Key::x509_decoder() 
+   { 
+   return std::auto_ptr<X509_Decoder>(); 
+   }
+
+
+/*************************************************
+* Factories for Private Key PKCS8 En-/Decoder    *
+*************************************************/
+
+std::auto_ptr<PKCS8_Encoder> Private_Key::pkcs8_encoder() const 
+   { 
+   return std::auto_ptr<PKCS8_Encoder>(); 
+   }
+
+std::auto_ptr<PKCS8_Decoder> Private_Key::pkcs8_decoder() 
+   { 
+   return std::auto_ptr<PKCS8_Decoder>(); 
+   }
+
+
+/*************************************************
 * Default OID access                             *
 *************************************************/
 OID Public_Key::get_oid() const
============================================================
--- src/pkcs10.cpp	9c89f3e653afd0c819a468514a81de9fd2c23079
+++ src/pkcs10.cpp	a0f74f7fda726c421b371dacdf26b98ff54c0946
@@ -17,8 +17,8 @@ namespace Botan {
 /*************************************************
 * PKCS10_Request Constructor                     *
 *************************************************/
-PKCS10_Request::PKCS10_Request(DataSource& in) :
-   X509_Object(in, "CERTIFICATE REQUEST/NEW CERTIFICATE REQUEST")
+PKCS10_Request::PKCS10_Request(SharedPtrConverter<DataSource> in) :
+   X509_Object(in.get_shared(), "CERTIFICATE REQUEST/NEW CERTIFICATE REQUEST")
    {
    do_decode();
    }
@@ -137,16 +137,16 @@ MemoryVector<byte> PKCS10_Request::raw_p
 *************************************************/
 MemoryVector<byte> PKCS10_Request::raw_public_key() const
    {
-   DataSource_Memory source(info.get1("X509.Certificate.public_key"));
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(info.get1("X509.Certificate.public_key")));
    return PEM_Code::decode_check_label(source, "PUBLIC KEY");
    }
 
 /*************************************************
 * Return the public key of the requestor         *
 *************************************************/
-Public_Key* PKCS10_Request::subject_public_key() const
+std::auto_ptr<Public_Key> PKCS10_Request::subject_public_key() const
    {
-   DataSource_Memory source(info.get1("X509.Certificate.public_key"));
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(info.get1("X509.Certificate.public_key")));
    return X509::load_key(source);
    }
 
============================================================
--- src/pkcs5.cpp	74572fee997b93c59ca6e747e0d7f14b1ca47a46
+++ src/pkcs5.cpp	31e3530688cf7e9036de47581536962c7c545749
@@ -8,7 +8,7 @@
 #include <botan/bit_ops.h>
 #include <botan/hmac.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -23,7 +23,7 @@ OctetString PKCS5_PBKDF1::derive(u32bit 
    if(iterations == 0)
       throw Invalid_Argument("PKCS#5 PBKDF1: Invalid iteration count");
 
-   std::auto_ptr<HashFunction> hash(get_hash(hash_name));
+   HashFunction::AutoHashFunctionPtr hash(get_hash(hash_name));
    if(key_len > hash->OUTPUT_LENGTH)
       throw Exception("PKCS#5 PBKDF1: Requested output length too long");
 
@@ -72,9 +72,8 @@ OctetString PKCS5_PBKDF2::derive(u32bit 
       throw Invalid_Argument("PKCS#5 PBKDF2: Empty passphrase is invalid");
 
    HMAC hmac(hash_name);
-
    hmac.set_key(reinterpret_cast<const byte*>(passphrase.data()),
-                passphrase.length());
+                    passphrase.length());
 
    SecureVector<byte> key(key_len);
 
============================================================
--- src/pkcs8.cpp	733a303d5cbf22ad09fcb583943de7120358add9
+++ src/pkcs8.cpp	c62cd9e5cf984b6c4c0a8f520948978c0ffc1e25
@@ -12,7 +12,7 @@
 #include <botan/oids.h>
 #include <botan/pem.h>
 #include <botan/pbe.h>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -23,12 +23,12 @@ namespace {
 /*************************************************
 * Get info from an EncryptedPrivateKeyInfo       *
 *************************************************/
-SecureVector<byte> PKCS8_extract(DataSource& source,
+SecureVector<byte> PKCS8_extract(SharedPtrConverter<DataSource> source,
                                  AlgorithmIdentifier& pbe_alg_id)
    {
    SecureVector<byte> key_data;
 
-   BER_Decoder(source)
+   BER_Decoder(source.get_shared())
       .start_cons(SEQUENCE)
          .decode(pbe_alg_id)
          .decode(key_data, OCTET_STRING)
@@ -41,7 +41,7 @@ SecureVector<byte> PKCS8_extract(DataSou
 /*************************************************
 * PEM decode and/or decrypt a private key        *
 *************************************************/
-SecureVector<byte> PKCS8_decode(DataSource& source, const User_Interface& ui,
+SecureVector<byte> PKCS8_decode(SharedPtrConverter<DataSource> source, const User_Interface& ui,
                                 AlgorithmIdentifier& pk_alg_id)
    {
    AlgorithmIdentifier pbe_alg_id;
@@ -49,17 +49,17 @@ SecureVector<byte> PKCS8_decode(DataSour
    bool is_encrypted = true;
 
    try {
-      if(ASN1::maybe_BER(source) && !PEM_Code::matches(source))
-         key_data = PKCS8_extract(source, pbe_alg_id);
+      if(ASN1::maybe_BER(source.get_shared()) && !PEM_Code::matches(source.get_shared()))
+         key_data = PKCS8_extract(source.get_shared(), pbe_alg_id);
       else
          {
          std::string label;
-         key_data = PEM_Code::decode(source, label);
+         key_data = PEM_Code::decode(source.get_shared(), label);
          if(label == "PRIVATE KEY")
             is_encrypted = false;
          else if(label == "ENCRYPTED PRIVATE KEY")
             {
-            DataSource_Memory key_source(key_data);
+            std::tr1::shared_ptr<DataSource> key_source(new DataSource_Memory(key_data));
             key_data = PKCS8_extract(key_source, pbe_alg_id);
             }
          else
@@ -89,12 +89,12 @@ SecureVector<byte> PKCS8_decode(DataSour
 
          if(is_encrypted)
             {
-            DataSource_Memory params(pbe_alg_id.parameters);
-            PBE* pbe = get_pbe(pbe_alg_id.oid, params);
+            std::tr1::shared_ptr<DataSource> params(new DataSource_Memory(pbe_alg_id.parameters));
+            std::tr1::shared_ptr<PBE> pbe = get_pbe(pbe_alg_id.oid, params);
 
             User_Interface::UI_Result result = User_Interface::OK;
             const std::string passphrase =
-               ui.get_passphrase("PKCS #8 private key", source.id(), result);
+               ui.get_passphrase("PKCS #8 private key", source.get_shared()->id(), result);
 
             if(result == User_Interface::CANCEL_ACTION)
                break;
@@ -173,7 +173,7 @@ void encrypt_key(const Private_Key& key,
    encode(key, raw_key, RAW_BER);
    raw_key.end_msg();
 
-   PBE* pbe = get_pbe(((pbe_algo != "") ? pbe_algo : DEFAULT_PBE));
+   std::tr1::shared_ptr<PBE> pbe = get_pbe(((pbe_algo != "") ? pbe_algo : DEFAULT_PBE));
    pbe->set_key(pass);
 
    Pipe key_encrytor(pbe);
@@ -224,7 +224,7 @@ std::string PEM_encode(const Private_Key
 /*************************************************
 * Extract a private key and return it            *
 *************************************************/
-Private_Key* load_key(DataSource& source, const User_Interface& ui)
+std::auto_ptr<Private_Key> load_key(std::tr1::shared_ptr<DataSource> source, const User_Interface& ui)
    {
    AlgorithmIdentifier alg_id;
    SecureVector<byte> pkcs8_key = PKCS8_decode(source, ui, alg_id);
@@ -247,22 +247,22 @@ Private_Key* load_key(DataSource& source
    decoder->alg_id(alg_id);
    decoder->key_bits(pkcs8_key);
 
-   return key.release();
+   return key;
    }
 
 /*************************************************
 * Extract a private key and return it            *
 *************************************************/
-Private_Key* load_key(const std::string& fsname, const User_Interface& ui)
+std::auto_ptr<Private_Key> load_key(const std::string& fsname, const User_Interface& ui)
    {
-   DataSource_Stream source(fsname, true);
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Stream(fsname, true));
    return PKCS8::load_key(source, ui);
    }
 
 /*************************************************
 * Extract a private key and return it            *
 *************************************************/
-Private_Key* load_key(DataSource& source, const std::string& pass)
+std::auto_ptr<Private_Key> load_key(std::tr1::shared_ptr<DataSource> source, const std::string& pass)
    {
    return PKCS8::load_key(source, User_Interface(pass));
    }
@@ -270,7 +270,7 @@ Private_Key* load_key(DataSource& source
 /*************************************************
 * Extract a private key and return it            *
 *************************************************/
-Private_Key* load_key(const std::string& fsname, const std::string& pass)
+std::auto_ptr<Private_Key> load_key(const std::string& fsname, const std::string& pass)
    {
    return PKCS8::load_key(fsname, User_Interface(pass));
    }
@@ -278,7 +278,7 @@ Private_Key* load_key(const std::string&
 /*************************************************
 * Make a copy of this private key                *
 *************************************************/
-Private_Key* copy_key(const Private_Key& key)
+std::auto_ptr<Private_Key> copy_key(const Private_Key& key)
    {
    Pipe bits;
 
@@ -286,7 +286,7 @@ Private_Key* copy_key(const Private_Key&
    PKCS8::encode(key, bits);
    bits.end_msg();
 
-   DataSource_Memory source(bits.read_all());
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(bits.read_all()));
    return PKCS8::load_key(source);
    }
 
============================================================
--- src/policy.cpp	979a989d26dd9cbc7a01e489136831c7c8ea5bc2
+++ src/policy.cpp	5abd1fbeff636a90a3de4182f65829847e70504d
@@ -1,6 +1,8 @@
 /*************************************************
 * Default Policy Source File                     *
 * (C) 1999-2007 The Botan Project                *
+* (C) 2008  Falko Strenzke                       *
+*           strenzke@flexsecure.de               *
 *************************************************/
 
 #include <botan/config.h>
@@ -10,51 +12,96 @@ namespace {
 namespace {
 
 /*************************************************
-* OID loading helper function                    *
+* OID loading helper functions                   *
 *************************************************/
-void add_oid(Config& config,
+void add_oid_to_section(const std::string& section_oid2str, const std::string section_str2oid, Config& config,
              const std::string& oid_str,
              const std::string& name)
-   {
-   if(!config.is_set("oid2str", oid_str))
-      config.set("oid2str", oid_str, name);
-   if(!config.is_set("str2oid", name))
-      config.set("str2oid", name, oid_str);
-   }
+{
+    if(!config.is_set(section_oid2str, oid_str))
+        config.set(section_oid2str, oid_str, name);
+    if(!config.is_set(section_str2oid, name))
+        config.set(section_str2oid, name, oid_str);
+}
+    void add_oid(Config& config,
+                 const std::string& oid_str,
+                 const std::string& name)
+    {
+        add_oid_to_section("oid2str", "str2oid", config, oid_str, name);
+    }
+    void add_oid_bsi(Config& config,
+                     const std::string& oid_str,
+                     const std::string& name)
+    {
+        add_oid_to_section("oid2str", "str2oid_bsi", config, oid_str, name);
+        //NOTE: lookup of oid is generally applicable in all cases
+        // whereas for the lookup of oids the domain ("normal"/bsi) has to be specified
+    }
 
 /*************************************************
 * Load all of the default OIDs                   *
 *************************************************/
 void set_default_oids(Config& config)
    {
+   add_oid(config, "0.4.0.127.0.7.3.1.2.1", "CertificateHolderAuthorizationTemplate");
+
    add_oid(config, "1.2.840.113549.1.1.1", "RSA");
    add_oid(config, "2.5.8.1.1", "RSA");
+
+   /*
    add_oid(config, "1.2.840.10040.4.1", "DSA");
+   */
    add_oid(config, "1.2.840.10046.2.1", "DH");
+
+   add_oid(config, "1.2.840.10045.2.1", "ECDSA");
+   add_oid(config, "1.2.840.10045.4.1", "ECDSA/EMSA1_BSI(SHA-1)");
+   add_oid(config, "1.2.840.10045.4.3.1", "ECDSA/EMSA1_BSI(SHA-224)");
+   add_oid(config, "1.2.840.10045.4.3.2", "ECDSA/EMSA1_BSI(SHA-256)");
+   add_oid(config, "1.2.840.10045.4.3.3", "ECDSA/EMSA1_BSI(SHA-384)");
+   add_oid(config, "1.2.840.10045.4.3.4", "ECDSA/EMSA1_BSI(SHA-512)");
+
+   add_oid_bsi(config, "0.4.0.127.0.7.2.2.2.2.1", "ECDSA/EMSA1_BSI(SHA-1)");
+   add_oid_bsi(config, "0.4.0.127.0.7.2.2.2.2.2", "ECDSA/EMSA1_BSI(SHA-224)");
+   add_oid_bsi(config, "0.4.0.127.0.7.2.2.2.2.3", "ECDSA/EMSA1_BSI(SHA-256)");
+
+
+   add_oid(config, "0.4.0.127.0.7.1.1.5.1", "ECKAEG"); // in the normal domain use the bsi oid as well
+   add_oid_bsi(config, "0.4.0.127.0.7.1.1.5.1", "ECKAEG");
+   /*
    add_oid(config, "1.3.6.1.4.1.3029.1.2.1", "ELG");
    add_oid(config, "1.3.6.1.4.1.25258.1.1", "RW");
    add_oid(config, "1.3.6.1.4.1.25258.1.2", "NR");
+   */
 
    add_oid(config, "1.3.14.3.2.7", "DES/CBC");
    add_oid(config, "1.2.840.113549.3.7", "TripleDES/CBC");
+   /*
    add_oid(config, "1.2.840.113549.3.2", "RC2/CBC");
    add_oid(config, "1.2.840.113533.7.66.10", "CAST-128/CBC");
+   */
    add_oid(config, "2.16.840.1.101.3.4.1.2", "AES-128/CBC");
    add_oid(config, "2.16.840.1.101.3.4.1.22", "AES-192/CBC");
    add_oid(config, "2.16.840.1.101.3.4.1.42", "AES-256/CBC");
 
+	/*
    add_oid(config, "1.2.840.113549.2.5", "MD5");
-   add_oid(config, "1.3.6.1.4.1.11591.12.2", "Tiger(24,3)");
-
+   */
    add_oid(config, "1.3.14.3.2.26", "SHA-160");
    add_oid(config, "2.16.840.1.101.3.4.2.4", "SHA-224");
    add_oid(config, "2.16.840.1.101.3.4.2.1", "SHA-256");
    add_oid(config, "2.16.840.1.101.3.4.2.2", "SHA-384");
    add_oid(config, "2.16.840.1.101.3.4.2.3", "SHA-512");
 
+
+   /*
+   add_oid(config, "1.3.6.1.4.1.11591.12.2", "Tiger(24,3)");
+   */
+
    add_oid(config, "1.2.840.113549.1.9.16.3.6", "KeyWrap.TripleDES");
+   /*
    add_oid(config, "1.2.840.113549.1.9.16.3.7", "KeyWrap.RC2");
    add_oid(config, "1.2.840.113533.7.66.15", "KeyWrap.CAST-128");
+   */
    add_oid(config, "2.16.840.1.101.3.4.1.5", "KeyWrap.AES-128");
    add_oid(config, "2.16.840.1.101.3.4.1.25", "KeyWrap.AES-192");
    add_oid(config, "2.16.840.1.101.3.4.1.45", "KeyWrap.AES-256");
@@ -62,18 +109,21 @@ void set_default_oids(Config& config)
    add_oid(config, "1.2.840.113549.1.9.16.3.8", "Compression.Zlib");
 
    add_oid(config, "1.2.840.113549.1.1.1", "RSA/EME-PKCS1-v1_5");
+   /*
    add_oid(config, "1.2.840.113549.1.1.2", "RSA/EMSA3(MD2)");
    add_oid(config, "1.2.840.113549.1.1.4", "RSA/EMSA3(MD5)");
+   */
    add_oid(config, "1.2.840.113549.1.1.5", "RSA/EMSA3(SHA-160)");
    add_oid(config, "1.2.840.113549.1.1.11", "RSA/EMSA3(SHA-256)");
    add_oid(config, "1.2.840.113549.1.1.12", "RSA/EMSA3(SHA-384)");
    add_oid(config, "1.2.840.113549.1.1.13", "RSA/EMSA3(SHA-512)");
    add_oid(config, "1.3.36.3.3.1.2", "RSA/EMSA3(RIPEMD-160)");
-
    add_oid(config, "1.2.840.10040.4.3", "DSA/EMSA1(SHA-160)");
    add_oid(config, "2.16.840.1.101.3.4.3.1", "DSA/EMSA1(SHA-224)");
    add_oid(config, "2.16.840.1.101.3.4.3.2", "DSA/EMSA1(SHA-256)");
 
+
+	/*
    add_oid(config, "1.3.6.1.4.1.25258.2.1.1.1", "RW/EMSA2(RIPEMD-160)");
    add_oid(config, "1.3.6.1.4.1.25258.2.1.1.2", "RW/EMSA2(SHA-160)");
    add_oid(config, "1.3.6.1.4.1.25258.2.1.1.3", "RW/EMSA2(SHA-224)");
@@ -94,7 +144,7 @@ void set_default_oids(Config& config)
    add_oid(config, "1.3.6.1.4.1.25258.2.2.1.4", "NR/EMSA2(SHA-256)");
    add_oid(config, "1.3.6.1.4.1.25258.2.2.1.5", "NR/EMSA2(SHA-384)");
    add_oid(config, "1.3.6.1.4.1.25258.2.2.1.6", "NR/EMSA2(SHA-512)");
-
+	*/
    add_oid(config, "2.5.4.3",  "X520.CommonName");
    add_oid(config, "2.5.4.4",  "X520.Surname");
    add_oid(config, "2.5.4.5",  "X520.SerialNumber");
@@ -111,10 +161,12 @@ void set_default_oids(Config& config)
    add_oid(config, "2.5.4.65", "X520.Pseudonym");
 
    add_oid(config, "1.2.840.113549.1.5.12", "PKCS5.PBKDF2");
+	/*
    add_oid(config, "1.2.840.113549.1.5.1",  "PBE-PKCS5v15(MD2,DES/CBC)");
    add_oid(config, "1.2.840.113549.1.5.4",  "PBE-PKCS5v15(MD2,RC2/CBC)");
    add_oid(config, "1.2.840.113549.1.5.3",  "PBE-PKCS5v15(MD5,DES/CBC)");
    add_oid(config, "1.2.840.113549.1.5.6",  "PBE-PKCS5v15(MD5,RC2/CBC)");
+   */
    add_oid(config, "1.2.840.113549.1.5.10", "PBE-PKCS5v15(SHA-160,DES/CBC)");
    add_oid(config, "1.2.840.113549.1.5.11", "PBE-PKCS5v15(SHA-160,RC2/CBC)");
    add_oid(config, "1.2.840.113549.1.5.13", "PBE-PKCS5v20");
@@ -244,6 +296,7 @@ void set_default_config(Config& config)
    config.set_option("x509/ca/default_expire", "1y");
    config.set_option("x509/ca/signing_offset", "30s");
    config.set_option("x509/ca/rsa_hash", "SHA-1");
+   config.set_option("x509/ca/ecdsa_hash", "SHA-224");
    config.set_option("x509/ca/str_type", "latin1");
 
    config.set_option("x509/crl/unknown_critical", "ignore");
@@ -257,6 +310,10 @@ void set_default_config(Config& config)
    config.set_option("x509/exts/key_usage", "critical");
    config.set_option("x509/exts/extended_key_usage", "yes");
    config.set_option("x509/exts/crl_number", "yes");
+
+   config.set_option("eac/ca/cvca_validity_months", "12");
+   config.set_option("eac/ca/dvca_validity_months", "3");
+   config.set_option("eac/ca/is_validity_months", "1");
    }
 
 /*************************************************
@@ -387,8 +444,417 @@ void set_default_dl_groups(Config& confi
       "-----END DSA PARAMETERS-----");
    }
 
-}
 
+	/*************************************************
+	* Set the built-in EC domain parameters          *
+	*************************************************/
+
+	void set_default_ec_dompar(Config& config)
+	{
+		{
+		    /* secp160r1; source:
+		    GEC 2: Test Vectors for SEC 1
+		    Certicom Research
+		            Working Draft
+		            September, 1999
+		            Version 0.3;
+		            section 2.1.2*/
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffff7fffffff"); //p
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffff7ffffffc"); // a
+		    dom_par.push_back("0x1c97befc54bd7a8b65acf89f81d4d4adc565fa45"); // b
+		    dom_par.push_back("024a96b5688ef573284664698968c38bb913cbfc82"); // G
+		    dom_par.push_back("0x0100000000000000000001f4c8f927aed3ca752257"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.8", dom_par);
+		}
+
+		{
+		    /* prime192v1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffeffffffffffffffff"); //p
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffefffffffffffffffc"); // a
+		    dom_par.push_back("0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1"); // b
+		    dom_par.push_back("03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012"); // G
+		    dom_par.push_back("0xffffffffffffffffffffffff99def836146bc9b1b4d22831"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.1", dom_par);
+		}
+
+		{
+		    /* prime192v2; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffeffffffffffffffff"); //p
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffFeffffffffffffffFC"); // a
+		    dom_par.push_back("0xcc22d6dfb95c6b25e49c0d6364a4e5980c393aa21668d953"); // b
+		    dom_par.push_back("03eea2bae7e1497842f2de7769cfe9c989c072ad696f48034a"); // G
+		    dom_par.push_back("0xfffffffffffffffffffffffe5fb1a724dc80418648d8dd31"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.2", dom_par);
+		}
+
+		{
+		    /* prime192v3; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffeffffffffffffffff"); //p
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffefffffffffffffffc"); // a
+		    dom_par.push_back("0x22123dc2395a05caa7423daeccc94760a7d462256bd56916"); // b
+		    dom_par.push_back("027d29778100c65a1da1783716588dce2b8b4aee8e228f1896"); // G
+		    dom_par.push_back("0xffffffffffffffffffffffff7a62d031c83f4294f640ec13"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.3", dom_par);
+		}
+
+		{
+		    /* prime239v1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0x7fffffffffffffffffffffff7fffffffffff8000000000007fffffffffff"); //p
+		    dom_par.push_back("0x7ffFffffffffffffffffffff7fffffffffff8000000000007ffffffffffc"); // a
+		    dom_par.push_back("0x6B016C3BDCF18941D0D654921475CA71A9DB2FB27D1D37796185C2942C0A"); // b
+		    dom_par.push_back("020ffA963CDCA8816CCC33B8642BEDF905C3D358573D3F27FBBD3B3CB9AAAF"); // G
+		    dom_par.push_back("0x7fffffffffffffffffffffff7fffff9e5e9a9f5d9071fbd1522688909d0b"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.4", dom_par);
+		}
+
+		{
+		    /* prime239v2; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0x7fffffffffffffffffffffff7fffffffffff8000000000007fffffffffff"); //p
+		    dom_par.push_back("0x7ffFffffffffffffffffffff7ffFffffffff8000000000007ffFffffffFC"); // a
+		    dom_par.push_back("0x617FAB6832576CBBFED50D99F0249C3FEE58B94BA0038C7AE84C8C832F2C"); // b
+		    dom_par.push_back("0238AF09D98727705120C921BB5E9E26296A3CDCF2F35757A0EAFD87B830E7"); // G
+		    dom_par.push_back("0x7fffffffffffffffffffffff800000CFA7E8594377D414C03821BC582063"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.5", dom_par);
+		}
+
+		{
+		    /* prime239v3; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0x7fffffffffffffffffffffff7fffffffffff8000000000007fffffffffff"); //p
+		    dom_par.push_back("0x7ffFffffffffffffffffffff7ffFffffffff8000000000007ffFffffffFC"); // a
+		    dom_par.push_back("0x255705FA2A306654B1F4CB03D6A750A30C250102D4988717D9BA15AB6D3E"); // b
+		    dom_par.push_back("036768AE8E18BB92CFCF005C949AA2C6D94853D0E660BBF854B1C9505FE95A"); // G
+		    dom_par.push_back("0x7fffffffffffffffffffffff7fffff975DEB41B3A6057C3C432146526551"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.6", dom_par);
+		}
+
+		{
+		    /* prime256v1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"); //p
+		    dom_par.push_back("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffFC"); // a
+		    dom_par.push_back("0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B"); // b
+		    dom_par.push_back("036B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"); // G
+		    dom_par.push_back("0xffffffff00000000ffffffffffffffffBCE6FAADA7179E84F3B9CAC2FC632551"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.2.840.10045.3.1.7", dom_par);
+		}
+
+	    /* SEC2 */
+
+		{
+		    /* secp112r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xdb7c2abf62e35e668076bead208b"); //p
+		    dom_par.push_back("0xDB7C2ABF62E35E668076BEAD2088"); // a
+		    dom_par.push_back("0x659EF8BA043916EEDE8911702B22"); // b
+		    dom_par.push_back("0409487239995A5EE76B55F9C2F098A89CE5AF8724C0A23E0E0ff77500"); // G
+		    dom_par.push_back("0xDB7C2ABF62E35E7628DFAC6561C5"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.6", dom_par);
+		}
+
+		{
+		    /* secp112r2; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xdb7c2abf62e35e668076bead208b"); //p
+		    dom_par.push_back("0x6127C24C05F38A0AAAF65C0EF02C"); // a
+		    dom_par.push_back("0x51DEF1815DB5ED74FCC34C85D709"); // b
+		    dom_par.push_back("044BA30AB5E892B4E1649DD0928643ADCD46F5882E3747DEF36E956E97"); // G
+		    dom_par.push_back("0x36DF0AAFD8B8D7597CA10520D04B"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.7", dom_par);
+		}
+
+		{
+		    /* secp128r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffdffffffffffffffffffffffff"); //p
+		    dom_par.push_back("0xffffffFDffffffffffffffffffffffFC"); // a
+		    dom_par.push_back("0xE87579C11079F43DD824993C2CEE5ED3"); // b
+		    dom_par.push_back("04161ff7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83"); // G
+		    dom_par.push_back("0xffffffFE0000000075A30D1B9038A115"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.28", dom_par);
+		}
+
+		{
+		    /* secp128r2; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffdffffffffffffffffffffffff"); //p
+		    dom_par.push_back("0xD6031998D1B3BBFEBF59CC9BBff9AEE1"); // a
+		    dom_par.push_back("0x5EEEFCA380D02919DC2C6558BB6D8A5D"); // b
+		    dom_par.push_back("047B6AA5D85E572983E6FB32A7CDEBC14027B6916A894D3AEE7106FE805FC34B44"); // G
+		    dom_par.push_back("0x3ffffffF7ffffffFBE0024720613B5A3"); // order
+		    dom_par.push_back("4");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.29", dom_par);
+		}
+
+		{
+		    /* secp160k1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffeffffac73"); //p
+		    dom_par.push_back("0x0000000000000000000000000000000000000000"); // a
+		    dom_par.push_back("0x0000000000000000000000000000000000000007"); // b
+		    dom_par.push_back("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE"); // G
+		    dom_par.push_back("0x0100000000000000000001B8FA16DFAB9ACA16B6B3"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.9", dom_par);
+		}
+
+		{
+		    /* secp160r2; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffeffffac73"); //p
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffFEffffAC70"); // a
+		    dom_par.push_back("0xB4E134D3FB59EB8BAB57274904664D5AF50388BA"); // b
+		    dom_par.push_back("0452DCB034293A117E1F4ff11B30F7199D3144CE6DFEAffEF2E331F296E071FA0DF9982CFEA7D43F2E"); // G
+		    dom_par.push_back("0x0100000000000000000000351EE786A818F3A1A16B"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.30", dom_par);
+		}
+
+		{
+		    /* secp192k1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffffffffffeffffee37"); //p
+		    dom_par.push_back("0x000000000000000000000000000000000000000000000000"); // a
+		    dom_par.push_back("0x000000000000000000000000000000000000000000000003"); // b
+		    dom_par.push_back("04DB4ff10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D"); // G
+		    dom_par.push_back("0xffffffffffffffffffffffFE26F2FC170F69466A74DEFD8D"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.31", dom_par);
+		}
+
+		{
+		    /* secp224k1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffffffffffffffffffeffffe56d"); //p
+		    dom_par.push_back("0x00000000000000000000000000000000000000000000000000000000"); // a
+		    dom_par.push_back("0x00000000000000000000000000000000000000000000000000000005"); // b
+		    dom_par.push_back("04A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5"); // G
+		    dom_par.push_back("0x010000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.32", dom_par);
+		}
+
+		{
+		    /* secp224r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffff000000000000000000000001"); //p
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffFEffffffffffffffffffffffFE"); // a
+		    dom_par.push_back("0xB4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355ffB4"); // b
+		    dom_par.push_back("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34"); // G
+		    dom_par.push_back("0xffffffffffffffffffffffffffff16A2E0B8F03E13DD29455C5C2A3D"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.33", dom_par);
+		}
+
+		{
+		    /* secp256k1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"); //p
+		    dom_par.push_back("0x0000000000000000000000000000000000000000000000000000000000000000"); // a
+		    dom_par.push_back("0x0000000000000000000000000000000000000000000000000000000000000007"); // b
+		    dom_par.push_back("0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8"); // G
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffFEBAAEDCE6AF48A03BBFD25E8CD0364141"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.10", dom_par);
+		}
+
+		{
+		    /* secp384r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"); //p
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFEffffffff0000000000000000ffffffFC"); // a
+		    dom_par.push_back("0xB3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF"); // b
+		    dom_par.push_back("04AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB73617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F"); // G
+		    dom_par.push_back("0xffffffffffffffffffffffffffffffffffffffffffffffffC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.34", dom_par);
+		}
+
+		{
+		    /* secp521r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"); //p
+		    dom_par.push_back("0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFC"); // a
+		    dom_par.push_back("0x0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00"); // b
+		    dom_par.push_back("0400C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2ffA8DE3348B3C1856A429BF97E7E31C2E5BD66011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650"); // G
+		    dom_par.push_back("0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.132.0.35", dom_par);
+		}
+
+		/* NIS */
+
+		{
+		    /* NIST curve P-521; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"); //p
+		    dom_par.push_back("0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFC"); // a
+		    dom_par.push_back("0x051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00"); // b
+		    dom_par.push_back("0400C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2ffA8DE3348B3C1856A429BF97E7E31C2E5BD66011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650"); // G
+		    dom_par.push_back("0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.6.1.4.1.8301.3.1.2.9.0.38", dom_par);
+		}
+
+		/* BrainPool */
+
+		{
+		    /* brainpoolP160r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xE95E4A5F737059DC60DFC7AD95B3D8139515620F"); //p
+		    dom_par.push_back("0x340E7BE2A280EB74E2BE61BADA745D97E8F7C300"); // a
+		    dom_par.push_back("0x1E589A8595423412134FAA2DBDEC95C8D8675E58"); // b
+		    dom_par.push_back("04BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC31667CB477A1A8EC338F94741669C976316DA6321"); // G
+		    dom_par.push_back("0xE95E4A5F737059DC60DF5991D45029409E60FC09"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.1", dom_par);
+		}
+
+		{
+		    /* brainpoolP192r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xC302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297"); //p
+		    dom_par.push_back("0x6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF"); // a
+		    dom_par.push_back("0x469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9"); // b
+		    dom_par.push_back("04C0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD614B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F"); // G
+		    dom_par.push_back("0xC302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.3", dom_par);
+		}
+
+		{
+		    /* brainpoolP224r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xD7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF"); //p
+		    dom_par.push_back("0x68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43"); // a
+		    dom_par.push_back("0x2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B"); // b
+		    dom_par.push_back("040D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD"); // G
+		    dom_par.push_back("0xD7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.5", dom_par);
+		}
+
+		{
+		    /* brainpoolP256r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xA9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377"); //p
+		    dom_par.push_back("0x7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9"); // a
+		    dom_par.push_back("0x26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6"); // b
+		    dom_par.push_back("048BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997"); // G
+		    dom_par.push_back("0xA9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.7", dom_par);
+		}
+
+		{
+		    /* brainpoolP320r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xD35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27"); //p
+		    dom_par.push_back("0x3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4"); // a
+		    dom_par.push_back("0x520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6"); // b
+		    dom_par.push_back("0443BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E2061114FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1"); // G
+		    dom_par.push_back("0xD35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.9", dom_par);
+		}
+
+		{
+		    /* brainpoolP384r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0x8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53"); //p
+		    dom_par.push_back("0x7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826"); // a
+		    dom_par.push_back("0x4A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11"); // b
+		    dom_par.push_back("041D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315"); // G
+		    dom_par.push_back("0x8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.11", dom_par);
+		}
+
+		{
+		    /* brainpoolP512r1; source:
+		       Flexiprovider */
+			std::vector<std::string> dom_par;
+		    dom_par.push_back("0xAADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3"); //p
+		    dom_par.push_back("0x7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA"); // a
+		    dom_par.push_back("0x3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723"); // b
+		    dom_par.push_back("0481AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F8227DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892"); // G
+		    dom_par.push_back("0xAADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069"); // order
+		    dom_par.push_back("1");                                         // cofactor
+
+		    config.set_ec_dompar("1.3.36.3.3.2.8.1.1.13", dom_par);
+		}
+	}
+}
 /*************************************************
 * Set the default policy                         *
 *************************************************/
@@ -398,6 +864,8 @@ void Config::load_defaults()
    set_default_aliases(*this);
    set_default_oids(*this);
    set_default_dl_groups(*this);
+   set_default_ec_dompar(*this);
+
    }
 
 }
============================================================
--- src/pow_mod.cpp	eb6a2654eecdc0e847a132641d5e007ceb96824d
+++ src/pow_mod.cpp	74b2d97070499acc08ec50dc02f4bc6a01be6ccc
@@ -3,9 +3,11 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/pow_mod.h>
 #include <botan/engine.h>
+#include <botan/bigint/pow_mod.h>
+using namespace Botan::math;
 
+
 namespace Botan {
 
 /*************************************************
@@ -13,7 +15,7 @@ Power_Mod::Power_Mod(const BigInt& n, Us
 *************************************************/
 Power_Mod::Power_Mod(const BigInt& n, Usage_Hints hints)
    {
-   core = 0;
+   core.reset();
    set_modulus(n, hints);
    }
 
@@ -22,9 +24,9 @@ Power_Mod::Power_Mod(const Power_Mod& ot
 *************************************************/
 Power_Mod::Power_Mod(const Power_Mod& other)
    {
-   core = 0;
-   if(other.core)
-      core = other.core->copy();
+   core.reset();
+   if(other.core.get())
+      core = std::auto_ptr<Modular_Exponentiator>(other.core->copy());
    }
 
 /*************************************************
@@ -32,10 +34,9 @@ Power_Mod& Power_Mod::operator=(const Po
 *************************************************/
 Power_Mod& Power_Mod::operator=(const Power_Mod& other)
    {
-   delete core;
-   core = 0;
-   if(other.core)
-      core = other.core->copy();
+   core.reset();
+   if(other.core.get())
+      core = std::auto_ptr<Modular_Exponentiator>(other.core->copy());
    return (*this);
    }
 
@@ -44,7 +45,6 @@ Power_Mod::~Power_Mod()
 *************************************************/
 Power_Mod::~Power_Mod()
    {
-   delete core;
    }
 
 /*************************************************
@@ -52,8 +52,8 @@ void Power_Mod::set_modulus(const BigInt
 *************************************************/
 void Power_Mod::set_modulus(const BigInt& n, Usage_Hints hints) const
    {
-   delete core;
-   core = ((n == 0) ? 0 : Engine_Core::mod_exp(n, hints));
+   core.reset();
+   core = ((n == 0) ? std::auto_ptr<Modular_Exponentiator>() : Engine_Core::mod_exp(n, hints));
    }
 
 /*************************************************
@@ -64,7 +64,7 @@ void Power_Mod::set_base(const BigInt& b
    if(b.is_zero() || b.is_negative())
       throw Invalid_Argument("Power_Mod::set_base: arg must be > 0");
 
-   if(!core)
+   if(!core.get())
       throw Internal_Error("Power_Mod::set_base: core was NULL");
    core->set_base(b);
    }
@@ -77,7 +77,7 @@ void Power_Mod::set_exponent(const BigIn
    if(e.is_negative())
       throw Invalid_Argument("Power_Mod::set_exponent: arg must be > 0");
 
-   if(!core)
+   if(!core.get())
       throw Internal_Error("Power_Mod::set_exponent: core was NULL");
    core->set_exponent(e);
    }
@@ -87,7 +87,7 @@ BigInt Power_Mod::execute() const
 *************************************************/
 BigInt Power_Mod::execute() const
    {
-   if(!core)
+   if(!core.get())
       throw Internal_Error("Power_Mod::execute: core was NULL");
    return core->execute();
    }
============================================================
--- src/powm_fw.cpp	381e10f37c1800677e2845cbe31c466b38f88e10
+++ src/powm_fw.cpp	9e83834c96b1662d8cfef54c60e9c58c69cbe10c
@@ -3,10 +3,13 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/def_powm.h>
-#include <botan/numthry.h>
+#include <botan/bigint/def_powm.h>
+#include <botan/bigintfuncs.h>
 #include <vector>
 
+using namespace Botan::math;
+
+
 namespace Botan {
 
 namespace {
============================================================
--- src/powm_mnt.cpp	7887c90cb82ffe8f47213fc80d5c7594f00bb92f
+++ src/powm_mnt.cpp	4888a36fab34a209d3d1a60f7388e0f75d830a6c
@@ -3,10 +3,13 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/def_powm.h>
-#include <botan/numthry.h>
-#include <botan/mp_core.h>
+#include <botan/bigintfuncs.h>
+#include <botan/bigint/mp_core.h>
+#include <botan/bigint/def_powm.h>
 
+using namespace Botan::math;
+
+
 namespace Botan {
 
 namespace {
============================================================
--- src/prf_x942.cpp	94d6c065c580325db247150d2bce204a1b3e51ee
+++ src/prf_x942.cpp	6fac9a2eb6b63c758e8b4a3036e23d99467c4c25
@@ -9,7 +9,7 @@
 #include <botan/lookup.h>
 #include <botan/bit_ops.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -34,7 +34,7 @@ SecureVector<byte> X942_PRF::derive(u32b
                                     const byte secret[], u32bit secret_len,
                                     const byte salt[], u32bit salt_len) const
    {
-   std::auto_ptr<HashFunction> hash(get_hash("SHA-1"));
+   HashFunction::AutoHashFunctionPtr hash(get_hash("SHA-1"));
    const OID kek_algo(key_wrap_oid);
 
    SecureVector<byte> key;
============================================================
--- src/primes.cpp	bffba287204ae947085252210387c20a363c93ed
+++ src/primes.cpp	6eb50692ea9efe356fac5f0411acdb44690a3ffd
@@ -3,7 +3,7 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 
 namespace Botan {
 
@@ -605,69 +605,69 @@ const u64bit PRIME_PRODUCTS[PRIME_PRODUC
 65437, 65447, 65449, 65479, 65497, 65519, 65521, 0 };
 
 const u64bit PRIME_PRODUCTS[PRIME_PRODUCTS_TABLE_SIZE] = {
-0xE221F97C30E94E1D, 0xE5B65ED6608B952D, 0xF4521CE5D3CA44EF, 0xF3EF021E44A7EEC3,
-0xF330D66E4349E591, 0x6F6B8463BEE90825, 0xD41D1350609EC855, 0x28681D7AA3190143,
-0x2FA51D379842A4AF, 0x84AE694AFD8B0547, 0xC7AC609EF16A407B, 0xCA376556426DE0FD,
-0x466324A8372A45D5, 0xAD7D2FB14BF7DC0B, 0x7BCD9BF6C6C26323, 0x74709A2A2637FA55,
-0x1D640B8FE0CA4311, 0xC93804EEC683CB2D, 0xB10594307EA0B7AD, 0xDE0244E8F6D2DC17,
-0x61DE0343443ED4C5, 0xCF8D577CE72384BB, 0x217168EC6F4A928B, 0xF5446BCD87F96E6B,
-0xF7E12D023D06E73D, 0x457CBC7E43B62C3F, 0x5AE2F68DB28800BF, 0x7500EDA80A9C8EA7,
-0x8DBC07E86DC4A37F, 0x9E40BF0300CA232D, 0xC0A9D8342259FCD1, 0xDFE8B5D19367A1C5,
-0xFBC11439E02B209D, 0xDA0AC1EC9E251F43, 0xAB4E5F28D129622F, 0xEBF5FBCBF5587CBD,
-0xE26B31744B05DC9D, 0xE1580FBB4592700B, 0x6539F95C9D74F439, 0xB185EF6E9070A559,
-0x699ECA919029B14B, 0xEBBFC2CC1B0DEE0F, 0x8E19279CEAF709FB, 0xFA3F354C954330EF,
-0xAE9362C721216DEF, 0xF44253878D02F03D, 0xC2D98B01DFE4F3A9, 0xE4A3E0F9407ED71F,
-0xAE2E9D8F67A52865, 0xF7DEE3EE2D340885, 0xCC1D2DEA66C3C841, 0xA827E8CE4BF5EB07,
-0xDF26E6009081BE79, 0x1969811A2B7A6A93, 0x88D31B077DEEB8A3, 0xA15E37A8F401B5C1,
-0xB27BF45E6508617B, 0xE23D5CA287D9A531, 0xD33CEF8D08A70D3F, 0xF26E164CB7B477D5,
-0xF070DAE24D8CEDA9, 0x4F580C6048999F4D, 0xFBC528EEE00D6CFB, 0xE47E34CA3E3EAC63,
-0xE2421086C3D09FE5, 0xC35091E86806D213, 0x1F29F3BD0BE9FAB3, 0xFA21995FB84F5A83,
-0xBBF6D8395F7047C7, 0xBC28039A69726205, 0xF0324199A11B5D45, 0x969FA74E537EBE09,
-0xA474F6C127403A9D, 0xEBB6153629ECDEA7, 0xC96E2D7B65D2277B, 0xD2B89C851CD9291F,
-0xEABE76C706F0C3E5, 0xB997188EA5B710D3, 0xB5B20274A0DABB6F, 0x89D99F7F39AB2B9B,
-0x138C3AC887043CCD, 0xC6D3E2761D16233F, 0x507C4D00D6B6027F, 0xBF363571906180F3,
-0x89FEA18355BD571D, 0xF55905D2F8949905, 0x65F170475F041C6F, 0x94C6E638460936A1,
-0x809F449762D125EF, 0xAC4BC4C3547A71E1, 0xF9315948183BDBC5, 0xC383E883DEA0349B,
-0xBC33CFE86CA38435, 0xC413C74E3F6F847B, 0xE25488813C3CE121, 0xFD33CDA8A0333BEF,
-0xEDCCA470B26DA57F, 0x383533808BD74477, 0x3AC02A15FC89C54D, 0x3E12CC83606624F3,
-0xAB899B62C0938D01, 0x429DC254C5490571, 0xF5554C6D540DB6A9, 0xFE3F5CCCBAFFDC95,
-0xF20E8ABC0340C14F, 0xBD633919AA5AB02F, 0x532A1FA4D0775045, 0x9F3F943B5D1E6679,
-0xA14E33555E99605D, 0xC48A6E1EC3CF4793, 0xD00AC683F6B64DB9, 0xB7316C602F3F2DDB,
-0xABF8EF8B5CABB03D, 0xFFCAA72EE6539255, 0xC1CB903C8D764FB7, 0x80300B3B06A6F3F3,
-0xC7471C73A380A4AF, 0x892E6D86008F82E3, 0x8D040C52D7C6AB79, 0xD35DE032B89A6907,
-0xD1CD5A93959C1185, 0xB87C36644FB9B3B7, 0xA827E6B6DE68593F, 0xAC16DC9E966EA68F,
-0xB3E87100AC54DE6D, 0xB98014BDAE7021B1, 0xBE350E0F484524D1, 0xC6172BCEA3A11C9B,
-0xCC01BFD8F5EE2EC3, 0xD1B284C91EED248B, 0xFDFF2DE1B95F5687, 0xE21A13779E0CCDC7,
-0xE68E732A2ABED62F, 0xEC8F38C8B28E0493, 0xF52BDF080F7ABA6F, 0xFF40ECA3CCA22CE5,
-0x215D0693AD933EB1, 0xBE2B9B2F8ECD578D, 0x843F6BF5D2BBF979, 0xCACD47144DAADA59,
-0xF19D26474F170045, 0x7A6BA19CE2FBBCD9, 0x525620BB14320123, 0xEBABCCACEACE2A81,
-0xDAD688DAC863D2F3, 0x70CF888F6F02D4BB, 0xD3EBE9A16C01996F, 0xED449526CBEBE513,
-0x991DD50C7F17A1B7, 0xD1F37E54FC6589EF, 0xB1B72FDE0EA34AFF, 0xBF1D75BDDED44FD1,
-0xD101DC5EAA25201B, 0xDF60F18616AD8EFB, 0xED74888F36648FBB, 0xFD5051BD895D6539,
-0xCCEBE44FA3E6B1BD, 0xD52A16F9E33265CB, 0xEDD3384401AD1267, 0xF3CC98549791076F,
-0x6EF7899720A0A93B, 0x7DB9EF3F5256F38F, 0x9273910ABDE6E503, 0xA3B446CA98554091,
-0xB13C2BDE8958E05D, 0xBEFA82CB25F97AF1, 0xCDC1FE0211DF150F, 0xE32387464B225385,
-0xF154C4C2CA8EABF9, 0xCF4E11D8E56F6957, 0xF7BBB96118B42F15, 0x535138221347C85D,
-0x4FFC85B96C562A71, 0x6C6FD444704EE9A9, 0x81319E967E1AABB3, 0x948BE6486434303B,
-0xAADD17A4C60E2449, 0xD619D14A9A0B5FBD, 0xE2FB3F507D8C64B5, 0xFCFCE80D5BB997DF,
-0xB08106E9D93A99AD, 0x238E12AE75BF1861, 0xE0F83D2ED5DC8AC3, 0x681FF3CFE90D481B,
-0x805517DDD3E296E7, 0x9BDBC365E2E9E57F, 0xBAE52C39C9082107, 0xF09928EC4A4C1503,
-0xF26340D17F990C75, 0x97299F4F32B7DB6B, 0xC6E38417C7E30011, 0xF582B6E0E6B7830F,
-0xD0D046F74D1ED633, 0xBEE06A041F778E5D, 0xDBE53BF49C3CF227, 0xF9F4E4C91D1537F1,
-0xA838BFF645C41F0F, 0x458809A605C2264B, 0x62C07D00B5C7B939, 0x8F303208051AF4EF,
-0xCE366281B21E7AFD, 0xE750611EA0BE8B55, 0xAACF9921F54349DD, 0xB9499C919BEDEB2D,
-0x8B5E2D6A7C0FED8D, 0xB31C12531D85C86B, 0xE2F81DD567C198ED, 0xFCBF50872C7A85B7,
-0xA7C97479B562C749, 0xDBBB14BBF9B4AC85, 0xC69D26F25DEA581D, 0xFA3CC64F8D79398D,
-0x8703AEE0630C7FEF, 0xB272C207BD08D637, 0xC50A96A2C6C59C23, 0xFB6694D346303AB1,
-0x93F2BA15512C7BE9, 0x7ED5EB28F50A553F, 0xB9BB9C7AA9343BD3, 0xE711EA83362E3FEB,
-0xC417BB9B3F863C89, 0x96A88B47EE3AAB49, 0xDF3ED601F5DCCE23, 0xB211874BB8720877,
-0x6F3E9B69CB1BDCDB, 0x9B295CC8FEBC20D5, 0xE56F23F76A71387F, 0xEA78F5BB0CD1565F,
-0xA4A428E418FD2B17, 0xDEEF3C10065A26E1, 0x2D1E8F5735933B8D, 0xF362A62EB7E3B551,
-0xF62327AE7D4E70A5, 0x28B86F69D6FCA5B5, 0x87C63FAA3E25406B, 0xD659246185DA101D,
-0xC10B2CF6559274B7, 0x727BF31FFF9B208B, 0xEA55235C4B98064D, 0xFBCD0B3F56EABA75,
-0xFB0D12857E554175, 0xECC6FD2C8F45CC2F, 0xFAE200BB2687381B, 0x7C0001DFD91FDB5B,
-0xDEE61AC82000895B, 0x9536C4399D4F3FB7, 0xA8F1E698E4A3297F, 0xFA61F6759A6CEE8F,
-0xCBAE83BF32730B03, 0xDC7C6D1FB9E1633B, 0xF12CAF2A95AA8807, 0xDF9CC7A9C8FFEF4D,
-0xD0744F8438C2E907, 0xB0DA65AB5BB20619, 0x1C0C79A379CFBF8D, 0x93AC2BC1F9EC0E29 };
+0xE221F97C30E94E1DLL, 0xE5B65ED6608B952DLL, 0xF4521CE5D3CA44EFLL, 0xF3EF021E44A7EEC3LL,
+0xF330D66E4349E591LL, 0x6F6B8463BEE90825LL, 0xD41D1350609EC855LL, 0x28681D7AA3190143LL,
+0x2FA51D379842A4AFLL, 0x84AE694AFD8B0547LL, 0xC7AC609EF16A407BLL, 0xCA376556426DE0FDLL,
+0x466324A8372A45D5LL, 0xAD7D2FB14BF7DC0BLL, 0x7BCD9BF6C6C26323LL, 0x74709A2A2637FA55LL,
+0x1D640B8FE0CA4311LL, 0xC93804EEC683CB2DLL, 0xB10594307EA0B7ADLL, 0xDE0244E8F6D2DC17LL,
+0x61DE0343443ED4C5LL, 0xCF8D577CE72384BBLL, 0x217168EC6F4A928BLL, 0xF5446BCD87F96E6BLL,
+0xF7E12D023D06E73DLL, 0x457CBC7E43B62C3FLL, 0x5AE2F68DB28800BFLL, 0x7500EDA80A9C8EA7LL,
+0x8DBC07E86DC4A37FLL, 0x9E40BF0300CA232DLL, 0xC0A9D8342259FCD1LL, 0xDFE8B5D19367A1C5LL,
+0xFBC11439E02B209DLL, 0xDA0AC1EC9E251F43LL, 0xAB4E5F28D129622FLL, 0xEBF5FBCBF5587CBDLL,
+0xE26B31744B05DC9DLL, 0xE1580FBB4592700BLL, 0x6539F95C9D74F439LL, 0xB185EF6E9070A559LL,
+0x699ECA919029B14BLL, 0xEBBFC2CC1B0DEE0FLL, 0x8E19279CEAF709FBLL, 0xFA3F354C954330EFLL,
+0xAE9362C721216DEFLL, 0xF44253878D02F03DLL, 0xC2D98B01DFE4F3A9LL, 0xE4A3E0F9407ED71FLL,
+0xAE2E9D8F67A52865LL, 0xF7DEE3EE2D340885LL, 0xCC1D2DEA66C3C841LL, 0xA827E8CE4BF5EB07LL,
+0xDF26E6009081BE79LL, 0x1969811A2B7A6A93LL, 0x88D31B077DEEB8A3LL, 0xA15E37A8F401B5C1LL,
+0xB27BF45E6508617BLL, 0xE23D5CA287D9A531LL, 0xD33CEF8D08A70D3FLL, 0xF26E164CB7B477D5LL,
+0xF070DAE24D8CEDA9LL, 0x4F580C6048999F4DLL, 0xFBC528EEE00D6CFBLL, 0xE47E34CA3E3EAC63LL,
+0xE2421086C3D09FE5LL, 0xC35091E86806D213LL, 0x1F29F3BD0BE9FAB3LL, 0xFA21995FB84F5A83LL,
+0xBBF6D8395F7047C7LL, 0xBC28039A69726205LL, 0xF0324199A11B5D45LL, 0x969FA74E537EBE09LL,
+0xA474F6C127403A9DLL, 0xEBB6153629ECDEA7LL, 0xC96E2D7B65D2277BLL, 0xD2B89C851CD9291FLL,
+0xEABE76C706F0C3E5LL, 0xB997188EA5B710D3LL, 0xB5B20274A0DABB6FLL, 0x89D99F7F39AB2B9BLL,
+0x138C3AC887043CCDLL, 0xC6D3E2761D16233FLL, 0x507C4D00D6B6027FLL, 0xBF363571906180F3LL,
+0x89FEA18355BD571DLL, 0xF55905D2F8949905LL, 0x65F170475F041C6FLL, 0x94C6E638460936A1LL,
+0x809F449762D125EFLL, 0xAC4BC4C3547A71E1LL, 0xF9315948183BDBC5LL, 0xC383E883DEA0349BLL,
+0xBC33CFE86CA38435LL, 0xC413C74E3F6F847BLL, 0xE25488813C3CE121LL, 0xFD33CDA8A0333BEFLL,
+0xEDCCA470B26DA57FLL, 0x383533808BD74477LL, 0x3AC02A15FC89C54DLL, 0x3E12CC83606624F3LL,
+0xAB899B62C0938D01LL, 0x429DC254C5490571LL, 0xF5554C6D540DB6A9LL, 0xFE3F5CCCBAFFDC95LL,
+0xF20E8ABC0340C14FLL, 0xBD633919AA5AB02FLL, 0x532A1FA4D0775045LL, 0x9F3F943B5D1E6679LL,
+0xA14E33555E99605DLL, 0xC48A6E1EC3CF4793LL, 0xD00AC683F6B64DB9LL, 0xB7316C602F3F2DDBLL,
+0xABF8EF8B5CABB03DLL, 0xFFCAA72EE6539255LL, 0xC1CB903C8D764FB7LL, 0x80300B3B06A6F3F3LL,
+0xC7471C73A380A4AFLL, 0x892E6D86008F82E3LL, 0x8D040C52D7C6AB79LL, 0xD35DE032B89A6907LL,
+0xD1CD5A93959C1185LL, 0xB87C36644FB9B3B7LL, 0xA827E6B6DE68593FLL, 0xAC16DC9E966EA68FLL,
+0xB3E87100AC54DE6DLL, 0xB98014BDAE7021B1LL, 0xBE350E0F484524D1LL, 0xC6172BCEA3A11C9BLL,
+0xCC01BFD8F5EE2EC3LL, 0xD1B284C91EED248BLL, 0xFDFF2DE1B95F5687LL, 0xE21A13779E0CCDC7LL,
+0xE68E732A2ABED62FLL, 0xEC8F38C8B28E0493LL, 0xF52BDF080F7ABA6FLL, 0xFF40ECA3CCA22CE5LL,
+0x215D0693AD933EB1LL, 0xBE2B9B2F8ECD578DLL, 0x843F6BF5D2BBF979LL, 0xCACD47144DAADA59LL,
+0xF19D26474F170045LL, 0x7A6BA19CE2FBBCD9LL, 0x525620BB14320123LL, 0xEBABCCACEACE2A81LL,
+0xDAD688DAC863D2F3LL, 0x70CF888F6F02D4BBLL, 0xD3EBE9A16C01996FLL, 0xED449526CBEBE513LL,
+0x991DD50C7F17A1B7LL, 0xD1F37E54FC6589EFLL, 0xB1B72FDE0EA34AFFLL, 0xBF1D75BDDED44FD1LL,
+0xD101DC5EAA25201BLL, 0xDF60F18616AD8EFBLL, 0xED74888F36648FBBLL, 0xFD5051BD895D6539LL,
+0xCCEBE44FA3E6B1BDLL, 0xD52A16F9E33265CBLL, 0xEDD3384401AD1267LL, 0xF3CC98549791076FLL,
+0x6EF7899720A0A93BLL, 0x7DB9EF3F5256F38FLL, 0x9273910ABDE6E503LL, 0xA3B446CA98554091LL,
+0xB13C2BDE8958E05DLL, 0xBEFA82CB25F97AF1LL, 0xCDC1FE0211DF150FLL, 0xE32387464B225385LL,
+0xF154C4C2CA8EABF9LL, 0xCF4E11D8E56F6957LL, 0xF7BBB96118B42F15LL, 0x535138221347C85DLL,
+0x4FFC85B96C562A71LL, 0x6C6FD444704EE9A9LL, 0x81319E967E1AABB3LL, 0x948BE6486434303BLL,
+0xAADD17A4C60E2449LL, 0xD619D14A9A0B5FBDLL, 0xE2FB3F507D8C64B5LL, 0xFCFCE80D5BB997DFLL,
+0xB08106E9D93A99ADLL, 0x238E12AE75BF1861LL, 0xE0F83D2ED5DC8AC3LL, 0x681FF3CFE90D481BLL,
+0x805517DDD3E296E7LL, 0x9BDBC365E2E9E57FLL, 0xBAE52C39C9082107LL, 0xF09928EC4A4C1503LL,
+0xF26340D17F990C75LL, 0x97299F4F32B7DB6BLL, 0xC6E38417C7E30011LL, 0xF582B6E0E6B7830FLL,
+0xD0D046F74D1ED633LL, 0xBEE06A041F778E5DLL, 0xDBE53BF49C3CF227LL, 0xF9F4E4C91D1537F1LL,
+0xA838BFF645C41F0FLL, 0x458809A605C2264BLL, 0x62C07D00B5C7B939LL, 0x8F303208051AF4EFLL,
+0xCE366281B21E7AFDLL, 0xE750611EA0BE8B55LL, 0xAACF9921F54349DDLL, 0xB9499C919BEDEB2DLL,
+0x8B5E2D6A7C0FED8DLL, 0xB31C12531D85C86BLL, 0xE2F81DD567C198EDLL, 0xFCBF50872C7A85B7LL,
+0xA7C97479B562C749LL, 0xDBBB14BBF9B4AC85LL, 0xC69D26F25DEA581DLL, 0xFA3CC64F8D79398DLL,
+0x8703AEE0630C7FEFLL, 0xB272C207BD08D637LL, 0xC50A96A2C6C59C23LL, 0xFB6694D346303AB1LL,
+0x93F2BA15512C7BE9LL, 0x7ED5EB28F50A553FLL, 0xB9BB9C7AA9343BD3LL, 0xE711EA83362E3FEBLL,
+0xC417BB9B3F863C89LL, 0x96A88B47EE3AAB49LL, 0xDF3ED601F5DCCE23LL, 0xB211874BB8720877LL,
+0x6F3E9B69CB1BDCDBLL, 0x9B295CC8FEBC20D5LL, 0xE56F23F76A71387FLL, 0xEA78F5BB0CD1565FLL,
+0xA4A428E418FD2B17LL, 0xDEEF3C10065A26E1LL, 0x2D1E8F5735933B8DLL, 0xF362A62EB7E3B551LL,
+0xF62327AE7D4E70A5LL, 0x28B86F69D6FCA5B5LL, 0x87C63FAA3E25406BLL, 0xD659246185DA101DLL,
+0xC10B2CF6559274B7LL, 0x727BF31FFF9B208BLL, 0xEA55235C4B98064DLL, 0xFBCD0B3F56EABA75LL,
+0xFB0D12857E554175LL, 0xECC6FD2C8F45CC2FLL, 0xFAE200BB2687381BLL, 0x7C0001DFD91FDB5BLL,
+0xDEE61AC82000895BLL, 0x9536C4399D4F3FB7LL, 0xA8F1E698E4A3297FLL, 0xFA61F6759A6CEE8FLL,
+0xCBAE83BF32730B03LL, 0xDC7C6D1FB9E1633BLL, 0xF12CAF2A95AA8807LL, 0xDF9CC7A9C8FFEF4DLL,
+0xD0744F8438C2E907LL, 0xB0DA65AB5BB20619LL, 0x1C0C79A379CFBF8DLL, 0x93AC2BC1F9EC0E29LL };
 
 }
============================================================
--- src/pubkey.cpp	413323d6652270bf268b614a10443c86987fddb9
+++ src/pubkey.cpp	302b762007d223d44807221e2da4a9f1e106ec17
@@ -6,11 +6,12 @@
 #include <botan/pubkey.h>
 #include <botan/der_enc.h>
 #include <botan/ber_dec.h>
-#include <botan/bigint.h>
 #include <botan/parsing.h>
+#include <botan/lookup.h>
+#include <botan/tr1_mem_includer.h>
+#include <botan/bigint.h>
 #include <botan/bit_ops.h>
-#include <botan/lookup.h>
-#include <memory>
+using namespace Botan::math;
 
 namespace Botan {
 
@@ -51,7 +52,7 @@ PK_Encryptor_MR_with_EME::PK_Encryptor_M
 *************************************************/
 PK_Encryptor_MR_with_EME::PK_Encryptor_MR_with_EME(const PK_Encrypting_Key& k,
                                                    const std::string& eme) :
-   key(k), encoder((eme == "Raw") ? 0 : get_eme(eme))
+   key(k), encoder((eme == "Raw") ? std::tr1::shared_ptr<EME>() : std::tr1::shared_ptr<EME>(get_eme(eme).release()))
    {
    }
 
@@ -87,7 +88,7 @@ PK_Decryptor_MR_with_EME::PK_Decryptor_M
 *************************************************/
 PK_Decryptor_MR_with_EME::PK_Decryptor_MR_with_EME(const PK_Decrypting_Key& k,
                                                    const std::string& eme) :
-   key(k), encoder((eme == "Raw") ? 0 : get_eme(eme))
+   key(k), encoder((eme == "Raw") ? std::tr1::shared_ptr<EME>() : std::tr1::shared_ptr<EME>(get_eme(eme).release()))
    {
    }
 
@@ -118,7 +119,7 @@ PK_Signer::PK_Signer(const PK_Signing_Ke
 * PK_Signer Constructor                          *
 *************************************************/
 PK_Signer::PK_Signer(const PK_Signing_Key& k, const std::string& emsa_name) :
-   key(k), emsa(get_emsa(emsa_name))
+   key(k), emsa(get_emsa(emsa_name).release())
    {
    sig_format = IEEE_1363;
    }
@@ -211,9 +212,8 @@ SecureVector<byte> PK_Signer::signature(
 /*************************************************
 * PK_Verifier Constructor                        *
 *************************************************/
-PK_Verifier::PK_Verifier(const std::string& emsa_name)
+PK_Verifier::PK_Verifier(const std::string& emsa_name) : emsa(get_emsa(emsa_name).release())
    {
-   emsa = get_emsa(emsa_name);
    sig_format = IEEE_1363;
    }
 
@@ -222,7 +222,6 @@ PK_Verifier::~PK_Verifier()
 *************************************************/
 PK_Verifier::~PK_Verifier()
    {
-   delete emsa;
    }
 
 /*************************************************
@@ -373,27 +372,27 @@ PK_Key_Agreement::PK_Key_Agreement(const
 /*************************************************
 * Perform Key Agreement Operation                *
 *************************************************/
-SymmetricKey PK_Key_Agreement::derive_key(u32bit key_len,
-                                          const byte in[], u32bit in_len,
-                                          const std::string& params) const
+SymmetricKey PK_Key_Agreement::derive_key(u32bit key_len, const Public_Key& pubkey,
+                              const std::string& params) const
    {
-   return derive_key(key_len, in, in_len,
-                     reinterpret_cast<const byte*>(params.data()),
-                     params.length());
+   return derive_key(key_len, pubkey,
+		   			reinterpret_cast<const byte*>(params.data()),
+                    params.length());
    }
 
 /*************************************************
 * Perform Key Agreement Operation                *
 *************************************************/
-SymmetricKey PK_Key_Agreement::derive_key(u32bit key_len, const byte in[],
-                                          u32bit in_len, const byte params[],
-                                          u32bit params_len) const
+SymmetricKey PK_Key_Agreement::derive_key(u32bit key_len, const Public_Key& pubkey,
+                                      const byte params[], u32bit params_len) const
    {
-   std::auto_ptr<KDF> kdf((kdf_name == "Raw") ? 0 : get_kdf(kdf_name));
-   OctetString z = key.derive_key(in, in_len);
+   std::tr1::shared_ptr<KDF> kdf((kdf_name == "Raw") ?  std::tr1::shared_ptr<KDF>()
+                                 : std::tr1::shared_ptr<KDF>(get_kdf(kdf_name).release()));
+   OctetString z = key.derive_key(pubkey);
 
-   if(kdf.get())
+   if(kdf.get()) {
       z = kdf->derive_key(key_len, z.bits_of(), params, params_len);
+   }
 
    return z;
    }
============================================================
--- src/randpool.cpp	dcfe978754894d39838888a39221519c5ca9b260
+++ src/randpool.cpp	f02567c5b14dd4ce84eb13b9bceb3ebe1fba8049
@@ -7,10 +7,9 @@
 #include <botan/lookup.h>
 #include <botan/bit_ops.h>
 #include <botan/util.h>
+#include <assert.h>
 #include <algorithm>
 
-#include <assert.h>
-
 namespace Botan {
 
 namespace {
@@ -25,7 +24,7 @@ enum RANDPOOL_PRF_TAG {
    GEN_OUTPUT = 3
 };
 
-SecureVector<byte> randpool_prf(MessageAuthenticationCode* mac,
+SecureVector<byte> randpool_prf(std::tr1::shared_ptr<MessageAuthenticationCode> mac,
                                 RANDPOOL_PRF_TAG tag,
                                 const byte in[], u32bit length)
    {
@@ -43,6 +42,7 @@ void Randpool::randomize(byte out[], u32
    {
    if(!is_seeded())
       throw PRNG_Unseeded(name());
+#ifndef NORANDPOOL
 
    update_buffer();
    while(length)
@@ -53,6 +53,7 @@ void Randpool::randomize(byte out[], u32
       length -= copied;
       update_buffer();
       }
+#endif
    }
 
 /*************************************************
@@ -107,6 +108,7 @@ void Randpool::add_randomness(const byte
 *************************************************/
 void Randpool::add_randomness(const byte data[], u32bit length)
    {
+#ifndef NORANDPOOL
    u32bit this_entropy = entropy_estimate(data, length);
    entropy += std::min(this_entropy, 8*mac->OUTPUT_LENGTH);
    entropy = std::min(entropy, 8 * pool.size());
@@ -114,6 +116,7 @@ void Randpool::add_randomness(const byte
    SecureVector<byte> mac_val = randpool_prf(mac, USER_INPUT, data, length);
    xor_buf(pool, mac_val, mac_val.size());
    mix_pool();
+#endif
    }
 
 /*************************************************
@@ -121,7 +124,11 @@ bool Randpool::is_seeded() const
 *************************************************/
 bool Randpool::is_seeded() const
    {
+#ifndef NORANDPOOL
    return (entropy >= 256);
+#else
+   return true;
+#endif
    }
 
 /*************************************************
@@ -153,8 +160,8 @@ Randpool::Randpool() : ITERATIONS_BEFORE
    const std::string CIPHER_NAME = "AES-256";
    const std::string MAC_NAME = "HMAC(SHA-256)";
 
-   cipher = get_block_cipher(CIPHER_NAME);
-   mac = get_mac(MAC_NAME);
+   cipher = std::tr1::shared_ptr<BlockCipher>(get_block_cipher(CIPHER_NAME).release());
+   mac =  std::tr1::shared_ptr<MessageAuthenticationCode>(get_mac(MAC_NAME).release());
 
    const u32bit BLOCK_SIZE = cipher->BLOCK_SIZE;
    const u32bit OUTPUT_LENGTH = mac->OUTPUT_LENGTH;
@@ -163,8 +170,6 @@ Randpool::Randpool() : ITERATIONS_BEFORE
       !cipher->valid_keylength(OUTPUT_LENGTH) ||
       !mac->valid_keylength(OUTPUT_LENGTH))
       {
-      delete cipher;
-      delete mac;
       throw Internal_Error("Randpool: Invalid algorithm combination " +
                            CIPHER_NAME + "/" + MAC_NAME);
       }
@@ -182,8 +187,6 @@ Randpool::~Randpool()
 *************************************************/
 Randpool::~Randpool()
    {
-   delete cipher;
-   delete mac;
    entropy = 0;
    }
 
============================================================
--- src/reducer.cpp	cbb17f184cc998fba5ca47c08ae25423826c7bf3
+++ src/reducer.cpp	2191963da851e181fc83bf56feda6b6c004267c9
@@ -3,11 +3,14 @@
 * (C) 1999-2007 The Botan Project                *
 *************************************************/
 
-#include <botan/reducer.h>
 #include <botan/bit_ops.h>
-#include <botan/numthry.h>
-#include <botan/mp_core.h>
+#include <botan/bigintfuncs.h>
+#include <botan/bigint/mp_core.h>
+#include <botan/bigint/reducer.h>
 
+using namespace Botan::math;
+
+
 namespace Botan {
 
 /*************************************************
============================================================
--- src/rmd160.cpp	0cb48c93b63cf3ed0d359101f457b8a07b8726be
+++ src/rmd160.cpp	70377f0c3d36873d2a33567f2e2f6859917b59f3
@@ -72,9 +72,8 @@ void RIPEMD_160::hash(const byte input[]
 *************************************************/
 void RIPEMD_160::hash(const byte input[])
    {
-   for(u32bit j = 0; j != 16; ++j)
-      M[j] = load_le<u32bit>(input, j);
-
+	for(u32bit j = 0; j != 16; ++j)
+			M[j] = load_le<u32bit>(input, j);
    u32bit A1 = digest[0], A2 = A1, B1 = digest[1], B2 = B1,
           C1 = digest[2], C2 = C1, D1 = digest[3], D2 = D1,
           E1 = digest[4], E2 = E1;
@@ -179,8 +178,8 @@ void RIPEMD_160::copy_out(byte output[])
 *************************************************/
 void RIPEMD_160::copy_out(byte output[])
    {
-   for(u32bit j = 0; j != OUTPUT_LENGTH; j += 4)
-      store_le(digest[j/4], output + j);
+   	for(u32bit j = 0; j != OUTPUT_LENGTH; j += 4)
+   	store_le(digest[j/4], output + j);
    }
 
 /*************************************************
============================================================
--- src/rng.cpp	60471c38882ca41d868d3893765d6ea6553db036
+++ src/rng.cpp	83846d1392e9985382ea197c3d51d9fd98e696e7
@@ -47,9 +47,9 @@ void add_entropy(EntropySource& src, boo
 /*************************************************
 * Add an EntropySource to the RNG seed list      *
 *************************************************/
-void add_es(EntropySource* src, bool last)
+void add_es(SharedPtrConverter<EntropySource> src, bool last)
    {
-   global_state().add_entropy_source(src, last);
+   global_state().add_entropy_source(src.get_shared(), last);
    }
 
 /*************************************************
============================================================
--- src/rsa.cpp	3712299fa9bc70a4b7c1631abf5667efc631eda3
+++ src/rsa.cpp	04938f731520d4a435a61b22febbd0e496f29790
@@ -4,10 +4,13 @@
 *************************************************/
 
 #include <botan/rsa.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/keypair.h>
 #include <botan/parsing.h>
 
+
+using namespace Botan::math;
+
 namespace Botan {
 
 /*************************************************
============================================================
--- src/secqueue.cpp	57e872c273efcf1e5a0b9dc7990eb7d72af2e2d7
+++ src/secqueue.cpp	4364913c742056d05a3e03fa5a9979a66c46e16c
@@ -5,6 +5,7 @@
 
 #include <botan/secqueue.h>
 #include <algorithm>
+#include <iostream>
 
 namespace Botan {
 
@@ -37,11 +38,11 @@ class SecureQueueNode
          return copied;
          }
       u32bit size() const { return (end - start); }
-      SecureQueueNode()  { next = 0; start = end = 0; }
-      ~SecureQueueNode() { next = 0; start = end = 0; }
+      SecureQueueNode() : next(std::tr1::shared_ptr<SecureQueueNode>()), start(0), end(0)  { }
+      ~SecureQueueNode() { start = end = 0; }
    private:
       friend class SecureQueue;
-      SecureQueueNode* next;
+      std::tr1::shared_ptr<SecureQueueNode> next;
       SecureBuffer<byte, DEFAULT_BUFFERSIZE> buffer;
       u32bit start, end;
    };
@@ -51,8 +52,9 @@ SecureQueue::SecureQueue()
 *************************************************/
 SecureQueue::SecureQueue()
    {
-   set_next(0, 0);
-   head = tail = new SecureQueueNode;
+   std::vector<SharedFilterPtr> sharedFilterPtrVector(0);
+   set_next(sharedFilterPtrVector.begin(), sharedFilterPtrVector.end());
+   head = tail = std::tr1::shared_ptr<SecureQueueNode>(new SecureQueueNode);
    }
 
 /*************************************************
@@ -61,11 +63,12 @@ SecureQueue::SecureQueue(const SecureQue
 SecureQueue::SecureQueue(const SecureQueue& input) :
    Fanout_Filter(), DataSource()
    {
-   set_next(0, 0);
+   std::vector<SharedFilterPtr> sharedFilterPtrVector(0);
+   set_next(sharedFilterPtrVector.begin(), sharedFilterPtrVector.end());
 
-   head = tail = new SecureQueueNode;
-   SecureQueueNode* temp = input.head;
-   while(temp)
+   head = tail = std::tr1::shared_ptr<SecureQueueNode>(new SecureQueueNode);
+   std::tr1::shared_ptr<SecureQueueNode> temp = input.head;
+   while(temp.get())
       {
       write(temp->buffer + temp->start, temp->end - temp->start);
       temp = temp->next;
@@ -77,14 +80,12 @@ void SecureQueue::destroy()
 *************************************************/
 void SecureQueue::destroy()
    {
-   SecureQueueNode* temp = head;
-   while(temp)
+   std::tr1::shared_ptr<SecureQueueNode> temp = head;
+   while(temp.get())
       {
-      SecureQueueNode* holder = temp->next;
-      delete temp;
-      temp = holder;
+      temp = temp->next;
       }
-   head = tail = 0;
+   head = tail = std::tr1::shared_ptr<SecureQueueNode>();
    }
 
 /*************************************************
@@ -93,9 +94,9 @@ SecureQueue& SecureQueue::operator=(cons
 SecureQueue& SecureQueue::operator=(const SecureQueue& input)
    {
    destroy();
-   head = tail = new SecureQueueNode;
-   SecureQueueNode* temp = input.head;
-   while(temp)
+   head = tail = std::tr1::shared_ptr<SecureQueueNode>(new SecureQueueNode);
+   std::tr1::shared_ptr<SecureQueueNode> temp = input.head;
+   while(temp.get())
       {
       write(temp->buffer + temp->start, temp->end - temp->start);
       temp = temp->next;
@@ -108,8 +109,8 @@ void SecureQueue::write(const byte input
 *************************************************/
 void SecureQueue::write(const byte input[], u32bit length)
    {
-   if(!head)
-      head = tail = new SecureQueueNode;
+   if(!head.get())
+      head = tail = std::tr1::shared_ptr<SecureQueueNode>(new SecureQueueNode);
    while(length)
       {
       const u32bit n = tail->write(input, length);
@@ -117,7 +118,7 @@ void SecureQueue::write(const byte input
       length -= n;
       if(length)
          {
-         tail->next = new SecureQueueNode;
+         tail->next = std::tr1::shared_ptr<SecureQueueNode>(new SecureQueueNode);
          tail = tail->next;
          }
       }
@@ -129,7 +130,7 @@ u32bit SecureQueue::read(byte output[], 
 u32bit SecureQueue::read(byte output[], u32bit length)
    {
    u32bit got = 0;
-   while(length && head)
+   while(length && head.get())
       {
       const u32bit n = head->read(output, length);
       output += n;
@@ -137,8 +138,8 @@ u32bit SecureQueue::read(byte output[], 
       length -= n;
       if(head->size() == 0)
          {
-         SecureQueueNode* holder = head->next;
-         delete head;
+         std::tr1::shared_ptr<SecureQueueNode> holder = head->next;
+         head.reset();
          head = holder;
          }
       }
@@ -150,9 +151,9 @@ u32bit SecureQueue::peek(byte output[], 
 *************************************************/
 u32bit SecureQueue::peek(byte output[], u32bit length, u32bit offset) const
    {
-   SecureQueueNode* current = head;
+   std::tr1::shared_ptr<SecureQueueNode> current = head;
 
-   while(offset && current)
+   while(offset && current.get())
       {
       if(offset >= current->size())
          {
@@ -164,7 +165,7 @@ u32bit SecureQueue::peek(byte output[], 
       }
 
    u32bit got = 0;
-   while(length && current)
+   while(length && current.get())
       {
       const u32bit n = current->peek(output, length, offset);
       offset = 0;
@@ -181,10 +182,10 @@ u32bit SecureQueue::size() const
 *************************************************/
 u32bit SecureQueue::size() const
    {
-   SecureQueueNode* current = head;
+   std::tr1::shared_ptr<SecureQueueNode> current = head;
    u32bit count = 0;
 
-   while(current)
+   while(current.get())
       {
       count += current->size();
       current = current->next;
============================================================
--- src/sha160.cpp	7f151f0f0f0f3c5358f422625c85d9fbfbc2520f
+++ src/sha160.cpp	931e6a49db428fa67edd0d3dfc08fbb3f034eabf
@@ -102,10 +102,11 @@ void SHA_160::copy_out(byte output[])
 *************************************************/
 void SHA_160::copy_out(byte output[])
    {
-   for(u32bit j = 0; j != OUTPUT_LENGTH; j += 4)
-      store_be(digest[j/4], output + j);
+    for(u32bit j = 0; j != OUTPUT_LENGTH; j += 4)
+	   store_be(digest[j/4], output + j);
    }
 
+
 /*************************************************
 * Clear memory of sensitive data                 *
 *************************************************/
============================================================
--- src/sha256.cpp	c301182d8aaf2804b5c52543987d0bd713acd7e2
+++ src/sha256.cpp	5f54c3bcb9847ca76f67a312fd3e476752d7b93b
@@ -44,7 +44,7 @@ inline void F1(u32bit A, u32bit B, u32bi
 /*************************************************
 * SHA-256 Compression Function                   *
 *************************************************/
-void SHA_256::hash(const byte input[])
+void SHA_224256_BASE::hash(const byte input[])
    {
    for(u32bit j = 0; j != 16; ++j)
       W[j] = load_be<u32bit>(input, j);
@@ -97,19 +97,27 @@ void SHA_256::hash(const byte input[])
 /*************************************************
 * Copy out the digest                            *
 *************************************************/
-void SHA_256::copy_out(byte output[])
+void SHA_224256_BASE::copy_out(byte output[])
    {
-   for(u32bit j = 0; j != OUTPUT_LENGTH; j += 4)
-      store_be(digest[j/4], output + j);
+   	for(u32bit j = 0; j != OUTPUT_LENGTH; j += 4)
+   		store_be(digest[j/4], output + j);
+
    }
 
 /*************************************************
 * Clear memory of sensitive data                 *
 *************************************************/
-void SHA_256::clear() throw()
+void SHA_224256_BASE::clear() throw()
    {
    MDx_HashFunction::clear();
    W.clear();
+   }
+/*************************************************
+* Clear memory of sensitive data                 *
+*************************************************/
+void SHA_256::clear() throw()
+   {
+   SHA_224256_BASE::clear();
    digest[0] = 0x6A09E667;
    digest[1] = 0xBB67AE85;
    digest[2] = 0x3C6EF372;
@@ -120,4 +128,22 @@ void SHA_256::clear() throw()
    digest[7] = 0x5BE0CD19;
    }
 
+/*************************************************
+* Clear memory of sensitive data                 *
+*************************************************/
+void SHA_224::clear() throw()
+   {
+   SHA_224256_BASE::clear();
+   digest[0] = 0xc1059ed8;
+   digest[1] = 0x367cd507;
+   digest[2] = 0x3070dd17;
+   digest[3] = 0xf70e5939;
+   digest[4] = 0xffc00b31;
+   digest[5] = 0x68581511;
+   digest[6] = 0x64f98fa7;
+   digest[7] = 0xbefa4fa4;
+   }
+
+
+
 }
============================================================
--- src/sha_64.cpp	d8bcc62e9199aa8ff55f012ed4106a40b1fd2724
+++ src/sha_64.cpp	c45ced644b3934f10aef4131a266ede67728fe58
@@ -48,7 +48,6 @@ void SHA_64_BASE::hash(const byte input[
    {
    for(u32bit j = 0; j != 16; ++j)
       W[j] = load_be<u64bit>(input, j);
-
    for(u32bit j = 16; j != 80; ++j)
       W[j] = sigma(W[j- 2], 19, 61,  6) + W[j- 7] +
              sigma(W[j-15],  1,  8,  7) + W[j-16];
@@ -57,86 +56,86 @@ void SHA_64_BASE::hash(const byte input[
           D = digest[3], E = digest[4], F = digest[5],
           G = digest[6], H = digest[7];
 
-   F1(A,B,C,D,E,F,G,H,W[ 0],0x428A2F98D728AE22);
-   F1(H,A,B,C,D,E,F,G,W[ 1],0x7137449123EF65CD);
-   F1(G,H,A,B,C,D,E,F,W[ 2],0xB5C0FBCFEC4D3B2F);
-   F1(F,G,H,A,B,C,D,E,W[ 3],0xE9B5DBA58189DBBC);
-   F1(E,F,G,H,A,B,C,D,W[ 4],0x3956C25BF348B538);
-   F1(D,E,F,G,H,A,B,C,W[ 5],0x59F111F1B605D019);
-   F1(C,D,E,F,G,H,A,B,W[ 6],0x923F82A4AF194F9B);
-   F1(B,C,D,E,F,G,H,A,W[ 7],0xAB1C5ED5DA6D8118);
-   F1(A,B,C,D,E,F,G,H,W[ 8],0xD807AA98A3030242);
-   F1(H,A,B,C,D,E,F,G,W[ 9],0x12835B0145706FBE);
-   F1(G,H,A,B,C,D,E,F,W[10],0x243185BE4EE4B28C);
-   F1(F,G,H,A,B,C,D,E,W[11],0x550C7DC3D5FFB4E2);
-   F1(E,F,G,H,A,B,C,D,W[12],0x72BE5D74F27B896F);
-   F1(D,E,F,G,H,A,B,C,W[13],0x80DEB1FE3B1696B1);
-   F1(C,D,E,F,G,H,A,B,W[14],0x9BDC06A725C71235);
-   F1(B,C,D,E,F,G,H,A,W[15],0xC19BF174CF692694);
-   F1(A,B,C,D,E,F,G,H,W[16],0xE49B69C19EF14AD2);
-   F1(H,A,B,C,D,E,F,G,W[17],0xEFBE4786384F25E3);
-   F1(G,H,A,B,C,D,E,F,W[18],0x0FC19DC68B8CD5B5);
-   F1(F,G,H,A,B,C,D,E,W[19],0x240CA1CC77AC9C65);
-   F1(E,F,G,H,A,B,C,D,W[20],0x2DE92C6F592B0275);
-   F1(D,E,F,G,H,A,B,C,W[21],0x4A7484AA6EA6E483);
-   F1(C,D,E,F,G,H,A,B,W[22],0x5CB0A9DCBD41FBD4);
-   F1(B,C,D,E,F,G,H,A,W[23],0x76F988DA831153B5);
-   F1(A,B,C,D,E,F,G,H,W[24],0x983E5152EE66DFAB);
-   F1(H,A,B,C,D,E,F,G,W[25],0xA831C66D2DB43210);
-   F1(G,H,A,B,C,D,E,F,W[26],0xB00327C898FB213F);
-   F1(F,G,H,A,B,C,D,E,W[27],0xBF597FC7BEEF0EE4);
-   F1(E,F,G,H,A,B,C,D,W[28],0xC6E00BF33DA88FC2);
-   F1(D,E,F,G,H,A,B,C,W[29],0xD5A79147930AA725);
-   F1(C,D,E,F,G,H,A,B,W[30],0x06CA6351E003826F);
-   F1(B,C,D,E,F,G,H,A,W[31],0x142929670A0E6E70);
-   F1(A,B,C,D,E,F,G,H,W[32],0x27B70A8546D22FFC);
-   F1(H,A,B,C,D,E,F,G,W[33],0x2E1B21385C26C926);
-   F1(G,H,A,B,C,D,E,F,W[34],0x4D2C6DFC5AC42AED);
-   F1(F,G,H,A,B,C,D,E,W[35],0x53380D139D95B3DF);
-   F1(E,F,G,H,A,B,C,D,W[36],0x650A73548BAF63DE);
-   F1(D,E,F,G,H,A,B,C,W[37],0x766A0ABB3C77B2A8);
-   F1(C,D,E,F,G,H,A,B,W[38],0x81C2C92E47EDAEE6);
-   F1(B,C,D,E,F,G,H,A,W[39],0x92722C851482353B);
-   F1(A,B,C,D,E,F,G,H,W[40],0xA2BFE8A14CF10364);
-   F1(H,A,B,C,D,E,F,G,W[41],0xA81A664BBC423001);
-   F1(G,H,A,B,C,D,E,F,W[42],0xC24B8B70D0F89791);
-   F1(F,G,H,A,B,C,D,E,W[43],0xC76C51A30654BE30);
-   F1(E,F,G,H,A,B,C,D,W[44],0xD192E819D6EF5218);
-   F1(D,E,F,G,H,A,B,C,W[45],0xD69906245565A910);
-   F1(C,D,E,F,G,H,A,B,W[46],0xF40E35855771202A);
-   F1(B,C,D,E,F,G,H,A,W[47],0x106AA07032BBD1B8);
-   F1(A,B,C,D,E,F,G,H,W[48],0x19A4C116B8D2D0C8);
-   F1(H,A,B,C,D,E,F,G,W[49],0x1E376C085141AB53);
-   F1(G,H,A,B,C,D,E,F,W[50],0x2748774CDF8EEB99);
-   F1(F,G,H,A,B,C,D,E,W[51],0x34B0BCB5E19B48A8);
-   F1(E,F,G,H,A,B,C,D,W[52],0x391C0CB3C5C95A63);
-   F1(D,E,F,G,H,A,B,C,W[53],0x4ED8AA4AE3418ACB);
-   F1(C,D,E,F,G,H,A,B,W[54],0x5B9CCA4F7763E373);
-   F1(B,C,D,E,F,G,H,A,W[55],0x682E6FF3D6B2B8A3);
-   F1(A,B,C,D,E,F,G,H,W[56],0x748F82EE5DEFB2FC);
-   F1(H,A,B,C,D,E,F,G,W[57],0x78A5636F43172F60);
-   F1(G,H,A,B,C,D,E,F,W[58],0x84C87814A1F0AB72);
-   F1(F,G,H,A,B,C,D,E,W[59],0x8CC702081A6439EC);
-   F1(E,F,G,H,A,B,C,D,W[60],0x90BEFFFA23631E28);
-   F1(D,E,F,G,H,A,B,C,W[61],0xA4506CEBDE82BDE9);
-   F1(C,D,E,F,G,H,A,B,W[62],0xBEF9A3F7B2C67915);
-   F1(B,C,D,E,F,G,H,A,W[63],0xC67178F2E372532B);
-   F1(A,B,C,D,E,F,G,H,W[64],0xCA273ECEEA26619C);
-   F1(H,A,B,C,D,E,F,G,W[65],0xD186B8C721C0C207);
-   F1(G,H,A,B,C,D,E,F,W[66],0xEADA7DD6CDE0EB1E);
-   F1(F,G,H,A,B,C,D,E,W[67],0xF57D4F7FEE6ED178);
-   F1(E,F,G,H,A,B,C,D,W[68],0x06F067AA72176FBA);
-   F1(D,E,F,G,H,A,B,C,W[69],0x0A637DC5A2C898A6);
-   F1(C,D,E,F,G,H,A,B,W[70],0x113F9804BEF90DAE);
-   F1(B,C,D,E,F,G,H,A,W[71],0x1B710B35131C471B);
-   F1(A,B,C,D,E,F,G,H,W[72],0x28DB77F523047D84);
-   F1(H,A,B,C,D,E,F,G,W[73],0x32CAAB7B40C72493);
-   F1(G,H,A,B,C,D,E,F,W[74],0x3C9EBE0A15C9BEBC);
-   F1(F,G,H,A,B,C,D,E,W[75],0x431D67C49C100D4C);
-   F1(E,F,G,H,A,B,C,D,W[76],0x4CC5D4BECB3E42B6);
-   F1(D,E,F,G,H,A,B,C,W[77],0x597F299CFC657E2A);
-   F1(C,D,E,F,G,H,A,B,W[78],0x5FCB6FAB3AD6FAEC);
-   F1(B,C,D,E,F,G,H,A,W[79],0x6C44198C4A475817);
+   F1(A,B,C,D,E,F,G,H,W[ 0],0x428A2F98D728AE22LL);
+   F1(H,A,B,C,D,E,F,G,W[ 1],0x7137449123EF65CDLL);
+   F1(G,H,A,B,C,D,E,F,W[ 2],0xB5C0FBCFEC4D3B2FLL);
+   F1(F,G,H,A,B,C,D,E,W[ 3],0xE9B5DBA58189DBBCLL);
+   F1(E,F,G,H,A,B,C,D,W[ 4],0x3956C25BF348B538LL);
+   F1(D,E,F,G,H,A,B,C,W[ 5],0x59F111F1B605D019LL);
+   F1(C,D,E,F,G,H,A,B,W[ 6],0x923F82A4AF194F9BLL);
+   F1(B,C,D,E,F,G,H,A,W[ 7],0xAB1C5ED5DA6D8118LL);
+   F1(A,B,C,D,E,F,G,H,W[ 8],0xD807AA98A3030242LL);
+   F1(H,A,B,C,D,E,F,G,W[ 9],0x12835B0145706FBELL);
+   F1(G,H,A,B,C,D,E,F,W[10],0x243185BE4EE4B28CLL);
+   F1(F,G,H,A,B,C,D,E,W[11],0x550C7DC3D5FFB4E2LL);
+   F1(E,F,G,H,A,B,C,D,W[12],0x72BE5D74F27B896FLL);
+   F1(D,E,F,G,H,A,B,C,W[13],0x80DEB1FE3B1696B1LL);
+   F1(C,D,E,F,G,H,A,B,W[14],0x9BDC06A725C71235LL);
+   F1(B,C,D,E,F,G,H,A,W[15],0xC19BF174CF692694LL);
+   F1(A,B,C,D,E,F,G,H,W[16],0xE49B69C19EF14AD2LL);
+   F1(H,A,B,C,D,E,F,G,W[17],0xEFBE4786384F25E3LL);
+   F1(G,H,A,B,C,D,E,F,W[18],0x0FC19DC68B8CD5B5LL);
+   F1(F,G,H,A,B,C,D,E,W[19],0x240CA1CC77AC9C65LL);
+   F1(E,F,G,H,A,B,C,D,W[20],0x2DE92C6F592B0275LL);
+   F1(D,E,F,G,H,A,B,C,W[21],0x4A7484AA6EA6E483LL);
+   F1(C,D,E,F,G,H,A,B,W[22],0x5CB0A9DCBD41FBD4LL);
+   F1(B,C,D,E,F,G,H,A,W[23],0x76F988DA831153B5LL);
+   F1(A,B,C,D,E,F,G,H,W[24],0x983E5152EE66DFABLL);
+   F1(H,A,B,C,D,E,F,G,W[25],0xA831C66D2DB43210LL);
+   F1(G,H,A,B,C,D,E,F,W[26],0xB00327C898FB213FLL);
+   F1(F,G,H,A,B,C,D,E,W[27],0xBF597FC7BEEF0EE4LL);
+   F1(E,F,G,H,A,B,C,D,W[28],0xC6E00BF33DA88FC2LL);
+   F1(D,E,F,G,H,A,B,C,W[29],0xD5A79147930AA725LL);
+   F1(C,D,E,F,G,H,A,B,W[30],0x06CA6351E003826FLL);
+   F1(B,C,D,E,F,G,H,A,W[31],0x142929670A0E6E70LL);
+   F1(A,B,C,D,E,F,G,H,W[32],0x27B70A8546D22FFCLL);
+   F1(H,A,B,C,D,E,F,G,W[33],0x2E1B21385C26C926LL);
+   F1(G,H,A,B,C,D,E,F,W[34],0x4D2C6DFC5AC42AEDLL);
+   F1(F,G,H,A,B,C,D,E,W[35],0x53380D139D95B3DFLL);
+   F1(E,F,G,H,A,B,C,D,W[36],0x650A73548BAF63DELL);
+   F1(D,E,F,G,H,A,B,C,W[37],0x766A0ABB3C77B2A8LL);
+   F1(C,D,E,F,G,H,A,B,W[38],0x81C2C92E47EDAEE6LL);
+   F1(B,C,D,E,F,G,H,A,W[39],0x92722C851482353BLL);
+   F1(A,B,C,D,E,F,G,H,W[40],0xA2BFE8A14CF10364LL);
+   F1(H,A,B,C,D,E,F,G,W[41],0xA81A664BBC423001LL);
+   F1(G,H,A,B,C,D,E,F,W[42],0xC24B8B70D0F89791LL);
+   F1(F,G,H,A,B,C,D,E,W[43],0xC76C51A30654BE30LL);
+   F1(E,F,G,H,A,B,C,D,W[44],0xD192E819D6EF5218LL);
+   F1(D,E,F,G,H,A,B,C,W[45],0xD69906245565A910LL);
+   F1(C,D,E,F,G,H,A,B,W[46],0xF40E35855771202ALL);
+   F1(B,C,D,E,F,G,H,A,W[47],0x106AA07032BBD1B8LL);
+   F1(A,B,C,D,E,F,G,H,W[48],0x19A4C116B8D2D0C8LL);
+   F1(H,A,B,C,D,E,F,G,W[49],0x1E376C085141AB53LL);
+   F1(G,H,A,B,C,D,E,F,W[50],0x2748774CDF8EEB99LL);
+   F1(F,G,H,A,B,C,D,E,W[51],0x34B0BCB5E19B48A8LL);
+   F1(E,F,G,H,A,B,C,D,W[52],0x391C0CB3C5C95A63LL);
+   F1(D,E,F,G,H,A,B,C,W[53],0x4ED8AA4AE3418ACBLL);
+   F1(C,D,E,F,G,H,A,B,W[54],0x5B9CCA4F7763E373LL);
+   F1(B,C,D,E,F,G,H,A,W[55],0x682E6FF3D6B2B8A3LL);
+   F1(A,B,C,D,E,F,G,H,W[56],0x748F82EE5DEFB2FCLL);
+   F1(H,A,B,C,D,E,F,G,W[57],0x78A5636F43172F60LL);
+   F1(G,H,A,B,C,D,E,F,W[58],0x84C87814A1F0AB72LL);
+   F1(F,G,H,A,B,C,D,E,W[59],0x8CC702081A6439ECLL);
+   F1(E,F,G,H,A,B,C,D,W[60],0x90BEFFFA23631E28LL);
+   F1(D,E,F,G,H,A,B,C,W[61],0xA4506CEBDE82BDE9LL);
+   F1(C,D,E,F,G,H,A,B,W[62],0xBEF9A3F7B2C67915LL);
+   F1(B,C,D,E,F,G,H,A,W[63],0xC67178F2E372532BLL);
+   F1(A,B,C,D,E,F,G,H,W[64],0xCA273ECEEA26619CLL);
+   F1(H,A,B,C,D,E,F,G,W[65],0xD186B8C721C0C207LL);
+   F1(G,H,A,B,C,D,E,F,W[66],0xEADA7DD6CDE0EB1ELL);
+   F1(F,G,H,A,B,C,D,E,W[67],0xF57D4F7FEE6ED178LL);
+   F1(E,F,G,H,A,B,C,D,W[68],0x06F067AA72176FBALL);
+   F1(D,E,F,G,H,A,B,C,W[69],0x0A637DC5A2C898A6LL);
+   F1(C,D,E,F,G,H,A,B,W[70],0x113F9804BEF90DAELL);
+   F1(B,C,D,E,F,G,H,A,W[71],0x1B710B35131C471BLL);
+   F1(A,B,C,D,E,F,G,H,W[72],0x28DB77F523047D84LL);
+   F1(H,A,B,C,D,E,F,G,W[73],0x32CAAB7B40C72493LL);
+   F1(G,H,A,B,C,D,E,F,W[74],0x3C9EBE0A15C9BEBCLL);
+   F1(F,G,H,A,B,C,D,E,W[75],0x431D67C49C100D4CLL);
+   F1(E,F,G,H,A,B,C,D,W[76],0x4CC5D4BECB3E42B6LL);
+   F1(D,E,F,G,H,A,B,C,W[77],0x597F299CFC657E2ALL);
+   F1(C,D,E,F,G,H,A,B,W[78],0x5FCB6FAB3AD6FAECLL);
+   F1(B,C,D,E,F,G,H,A,W[79],0x6C44198C4A475817LL);
 
    digest[0] += A; digest[1] += B; digest[2] += C;
    digest[3] += D; digest[4] += E; digest[5] += F;
@@ -149,7 +148,7 @@ void SHA_64_BASE::copy_out(byte output[]
 void SHA_64_BASE::copy_out(byte output[])
    {
    for(u32bit j = 0; j != OUTPUT_LENGTH; j += 8)
-      store_be(digest[j/8], output + j);
+   		store_be(digest[j/8], output + j);
    }
 
 /*************************************************
@@ -167,14 +166,14 @@ void SHA_384::clear() throw()
 void SHA_384::clear() throw()
    {
    SHA_64_BASE::clear();
-   digest[0] = 0xCBBB9D5DC1059ED8;
-   digest[1] = 0x629A292A367CD507;
-   digest[2] = 0x9159015A3070DD17;
-   digest[3] = 0x152FECD8F70E5939;
-   digest[4] = 0x67332667FFC00B31;
-   digest[5] = 0x8EB44A8768581511;
-   digest[6] = 0xDB0C2E0D64F98FA7;
-   digest[7] = 0x47B5481DBEFA4FA4;
+   digest[0] = 0xCBBB9D5DC1059ED8LL;
+   digest[1] = 0x629A292A367CD507LL;
+   digest[2] = 0x9159015A3070DD17LL;
+   digest[3] = 0x152FECD8F70E5939LL;
+   digest[4] = 0x67332667FFC00B31LL;
+   digest[5] = 0x8EB44A8768581511LL;
+   digest[6] = 0xDB0C2E0D64F98FA7LL;
+   digest[7] = 0x47B5481DBEFA4FA4LL;
    }
 
 /*************************************************
@@ -183,14 +182,14 @@ void SHA_512::clear() throw()
 void SHA_512::clear() throw()
    {
    SHA_64_BASE::clear();
-   digest[0] = 0x6A09E667F3BCC908;
-   digest[1] = 0xBB67AE8584CAA73B;
-   digest[2] = 0x3C6EF372FE94F82B;
-   digest[3] = 0xA54FF53A5F1D36F1;
-   digest[4] = 0x510E527FADE682D1;
-   digest[5] = 0x9B05688C2B3E6C1F;
-   digest[6] = 0x1F83D9ABFB41BD6B;
-   digest[7] = 0x5BE0CD19137E2179;
+   digest[0] = 0x6A09E667F3BCC908LL;
+   digest[1] = 0xBB67AE8584CAA73BLL;
+   digest[2] = 0x3C6EF372FE94F82BLL;
+   digest[3] = 0xA54FF53A5F1D36F1LL;
+   digest[4] = 0x510E527FADE682D1LL;
+   digest[5] = 0x9B05688C2B3E6C1FLL;
+   digest[6] = 0x1F83D9ABFB41BD6BLL;
+   digest[7] = 0x5BE0CD19137E2179LL;
    }
 
 }
============================================================
--- src/symkey.cpp	c1151d35d6ca0800cadd554543ed1f194f51da0e
+++ src/symkey.cpp	ad9f2caeefa58b010fe3bed413e38a14c8a1fe14
@@ -85,7 +85,7 @@ std::string OctetString::as_string() con
 *************************************************/
 std::string OctetString::as_string() const
    {
-   Pipe pipe(new Hex_Encoder);
+   Pipe pipe(create_shared_ptr<Hex_Encoder>());
    pipe.process_msg(bits);
    return pipe.read_all_as_string();
    }
============================================================
--- src/x509_ca.cpp	c490baee785765f71c2de35c8e0596b8b284a07e
+++ src/x509_ca.cpp	f7c4292d8c083780af5a5a1c11324ff78a9a3eb1
@@ -10,13 +10,13 @@
 #include <botan/config.h>
 #include <botan/lookup.h>
 #include <botan/look_pk.h>
-#include <botan/numthry.h>
+#include <botan/bigintfuncs.h>
 #include <botan/oids.h>
 #include <botan/util.h>
 #include <algorithm>
 #include <typeinfo>
 #include <iterator>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 #include <set>
 
 namespace Botan {
@@ -57,18 +57,21 @@ X509_Certificate X509_CA::sign_request(c
 
    Extensions extensions;
 
-   extensions.add(new Cert_Extension::Authority_Key_ID(cert.subject_key_id()));
-   extensions.add(new Cert_Extension::Subject_Key_ID(req.raw_public_key()));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Authority_Key_ID>(
+       new Cert_Extension::Authority_Key_ID(cert.subject_key_id())));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Subject_Key_ID>(
+       new Cert_Extension::Subject_Key_ID(req.raw_public_key())));
 
-   extensions.add(
-      new Cert_Extension::Basic_Constraints(req.is_CA(), req.path_limit()));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Basic_Constraints>(
+      new Cert_Extension::Basic_Constraints(req.is_CA(), req.path_limit())));
 
-   extensions.add(new Cert_Extension::Key_Usage(constraints));
-   extensions.add(
-      new Cert_Extension::Extended_Key_Usage(req.ex_constraints()));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Key_Usage>(
+       new Cert_Extension::Key_Usage(constraints)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Extended_Key_Usage>(
+      new Cert_Extension::Extended_Key_Usage(req.ex_constraints())));
 
-   extensions.add(
-      new Cert_Extension::Subject_Alternative_Name(req.subject_alt_name()));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Subject_Alternative_Name>(
+      new Cert_Extension::Subject_Alternative_Name(req.subject_alt_name())));
 
    /*
    extensions.add(
@@ -90,7 +93,7 @@ X509_Certificate X509_CA::sign_request(c
 /*************************************************
 * Create a new certificate                       *
 *************************************************/
-X509_Certificate X509_CA::make_cert(PK_Signer* signer,
+X509_Certificate X509_CA::make_cert(SharedPtrConverter<PK_Signer> signer,
                                     const AlgorithmIdentifier& sig_algo,
                                     const MemoryRegion<byte>& pub_key,
                                     const X509_Time& not_before,
@@ -102,7 +105,7 @@ X509_Certificate X509_CA::make_cert(PK_S
    const u32bit X509_CERT_VERSION = 3;
    const u32bit SERIAL_BITS = 128;
 
-   DataSource_Memory source(X509_Object::make_signed(signer, sig_algo,
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(X509_Object::make_signed(signer.get_shared(), sig_algo,
          DER_Encoder().start_cons(SEQUENCE)
             .start_explicit(0)
                .encode(X509_CERT_VERSION-1)
@@ -127,7 +130,7 @@ X509_Certificate X509_CA::make_cert(PK_S
             .end_explicit()
          .end_cons()
       .get_contents()
-   ));
+   )));
 
    return X509_Certificate(source);
    }
@@ -196,11 +199,12 @@ X509_CRL X509_CA::make_crl(const std::ve
    const u64bit current_time = system_time();
 
    Extensions extensions;
-   extensions.add(
-      new Cert_Extension::Authority_Key_ID(cert.subject_key_id()));
-   extensions.add(new Cert_Extension::CRL_Number(crl_number));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Authority_Key_ID>(
+      new Cert_Extension::Authority_Key_ID(cert.subject_key_id())));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::CRL_Number>(
+       new Cert_Extension::CRL_Number(crl_number)));
 
-   DataSource_Memory source(X509_Object::make_signed(signer, ca_sig_algo,
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(X509_Object::make_signed(signer, ca_sig_algo,
          DER_Encoder().start_cons(SEQUENCE)
             .encode(X509_CRL_VERSION-1)
             .encode(ca_sig_algo)
@@ -220,7 +224,7 @@ X509_CRL X509_CA::make_crl(const std::ve
             .end_explicit()
          .end_cons()
       .get_contents()
-   ));
+   )));
 
    return X509_CRL(source);
    }
@@ -238,13 +242,12 @@ X509_CA::~X509_CA()
 *************************************************/
 X509_CA::~X509_CA()
    {
-   delete signer;
    }
 
 /*************************************************
 * Choose a signing format for the key            *
 *************************************************/
-PK_Signer* choose_sig_format(const Private_Key& key,
+std::tr1::shared_ptr<PK_Signer> choose_sig_format(const Private_Key& key,
                              AlgorithmIdentifier& sig_algo)
    {
    std::string padding;
@@ -258,11 +261,11 @@ PK_Signer* choose_sig_format(const Priva
       throw Encoding_Error("Key " + key.algo_name() + " does not support "
                            "X.509 encoding");
 
-   sig_algo.parameters = encoding->alg_id().parameters;
+   sig_algo = AlgorithmIdentifier(sig_algo.oid, AlgorithmIdentifier::USE_NULL_PARAM);
 
    const PK_Signing_Key& sig_key = dynamic_cast<const PK_Signing_Key&>(key);
 
-   return get_pk_signer(sig_key, padding, format);
+   return std::tr1::shared_ptr<PK_Signer>(get_pk_signer(sig_key, padding, format).release());
    }
 
 }
============================================================
--- src/x509_crl.cpp	8d56ad20f352039dcccff53846813e8cd2600538
+++ src/x509_crl.cpp	f7c3486e576ed4d90957c957ab2842f97d9326e9
@@ -7,16 +7,17 @@
 #include <botan/x509_ext.h>
 #include <botan/ber_dec.h>
 #include <botan/parsing.h>
-#include <botan/bigint.h>
 #include <botan/config.h>
 #include <botan/oids.h>
+#include <botan/bigint.h>
+using namespace Botan::math;
 
 namespace Botan {
 
 /*************************************************
 * Load a X.509 CRL                               *
 *************************************************/
-X509_CRL::X509_CRL(DataSource& in) : X509_Object(in, "X509 CRL/CRL")
+X509_CRL::X509_CRL(SharedPtrConverter<DataSource> in) : X509_Object(in.get_shared(), "X509 CRL/CRL")
    {
    do_decode();
    }
============================================================
--- src/x509_ext.cpp	11ffbaf80379a237ed47a9ba13091db6e84ce95b
+++ src/x509_ext.cpp	4d67f65e478e87fd65d329a0383bf1bd0725f664
@@ -13,7 +13,7 @@
 #include <botan/config.h>
 #include <botan/bit_ops.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -32,7 +32,7 @@ void Extensions::encode_into(DER_Encoder
    {
    for(u32bit j = 0; j != extensions.size(); ++j)
       {
-      const Certificate_Extension* ext = extensions[j];
+      std::tr1::shared_ptr<const Certificate_Extension> ext = extensions[j];
 
       std::string setting;
 
@@ -66,8 +66,6 @@ void Extensions::decode_from(BER_Decoder
 *************************************************/
 void Extensions::decode_from(BER_Decoder& from_source)
    {
-   for(u32bit j = 0; j != extensions.size(); ++j)
-      delete extensions[j];
    extensions.clear();
 
    BER_Decoder sequence = from_source.start_cons(SEQUENCE);
@@ -84,8 +82,8 @@ void Extensions::decode_from(BER_Decoder
             .verify_end()
          .end_cons();
 
-      Certificate_Extension* ext =
-         global_state().x509_state().get_extension(oid);
+      std::tr1::shared_ptr<Certificate_Extension> ext =
+         global_state().x509_state()->get_extension(oid);
 
       if(!ext)
          {
@@ -118,12 +116,10 @@ Extensions& Extensions::copy_this(const 
 *************************************************/
 Extensions& Extensions::copy_this(const Extensions& other)
    {
-   for(u32bit j = 0; j != extensions.size(); ++j)
-      delete extensions[j];
    extensions.clear();
 
    for(u32bit j = 0; j != other.extensions.size(); ++j)
-      extensions.push_back(other.extensions[j]->copy());
+      extensions.push_back(std::tr1::shared_ptr<Certificate_Extension>(other.extensions[j]->copy().release()));
 
    return (*this);
    }
@@ -133,8 +129,7 @@ Extensions::~Extensions()
 *************************************************/
 Extensions::~Extensions()
    {
-   for(u32bit j = 0; j != extensions.size(); ++j)
-      delete extensions[j];
+
    }
 
 namespace Cert_Extension {
@@ -276,7 +271,7 @@ Subject_Key_ID::Subject_Key_ID(const Mem
 *************************************************/
 Subject_Key_ID::Subject_Key_ID(const MemoryRegion<byte>& pub_key)
    {
-   std::auto_ptr<HashFunction> hash(get_hash("SHA-1"));
+   HashFunction::AutoHashFunctionPtr hash(get_hash("SHA-1"));
    key_id = hash->process(pub_key);
    }
 
@@ -488,11 +483,11 @@ u32bit CRL_Number::get_crl_number() cons
 /*************************************************
 * Copy a CRL_Number extension                    *
 *************************************************/
-CRL_Number* CRL_Number::copy() const
+std::auto_ptr<Certificate_Extension> CRL_Number::copy() const
    {
    if(!has_value)
       throw Invalid_State("CRL_Number::copy: Not set");
-   return new CRL_Number(crl_number);
+   return std::auto_ptr<Certificate_Extension>(new CRL_Number(crl_number));
    }
 
 /*************************************************
@@ -524,9 +519,9 @@ MemoryVector<byte> CRL_ReasonCode::encod
 *************************************************/
 MemoryVector<byte> CRL_ReasonCode::encode_inner() const
    {
-   return DER_Encoder()
-      .encode(static_cast<u32bit>(reason), ENUMERATED, UNIVERSAL)
-   .get_contents();
+	return DER_Encoder()
+		.encode(static_cast<u32bit>(reason), ENUMERATED, UNIVERSAL)
+		.get_contents();
    }
 
 /*************************************************
============================================================
--- src/x509_key.cpp	7fb550c81b8c4ecf9767626751ded96208305f98
+++ src/x509_key.cpp	edf1009887e6d8616898ada7bd2fa08616569b5c
@@ -11,7 +11,7 @@
 #include <botan/pk_algs.h>
 #include <botan/oids.h>
 #include <botan/pem.h>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -55,15 +55,15 @@ std::string PEM_encode(const Public_Key&
 /*************************************************
 * Extract a public key and return it             *
 *************************************************/
-Public_Key* load_key(DataSource& source)
+std::auto_ptr<Public_Key> load_key(SharedPtrConverter<DataSource> source)
    {
    try {
       AlgorithmIdentifier alg_id;
       MemoryVector<byte> key_bits;
 
-      if(ASN1::maybe_BER(source) && !PEM_Code::matches(source))
+      if(ASN1::maybe_BER(source.get_shared()) && !PEM_Code::matches(source.get_shared()))
          {
-         BER_Decoder(source)
+         BER_Decoder(source.get_shared())
             .start_cons(SEQUENCE)
             .decode(alg_id)
             .decode(key_bits, BIT_STRING)
@@ -72,9 +72,9 @@ Public_Key* load_key(DataSource& source)
          }
       else
          {
-         DataSource_Memory ber(
-            PEM_Code::decode_check_label(source, "PUBLIC KEY")
-            );
+           std::tr1::shared_ptr<DataSource> ber(new DataSource_Memory (
+            PEM_Code::decode_check_label(source.get_shared(), "PUBLIC KEY")
+            ));
 
          BER_Decoder(ber)
             .start_cons(SEQUENCE)
@@ -104,7 +104,7 @@ Public_Key* load_key(DataSource& source)
       decoder->alg_id(alg_id);
       decoder->key_bits(key_bits);
 
-      return key_obj.release();
+      return key_obj;
       }
    catch(Decoding_Error)
       {
@@ -115,31 +115,31 @@ Public_Key* load_key(DataSource& source)
 /*************************************************
 * Extract a public key and return it             *
 *************************************************/
-Public_Key* load_key(const std::string& fsname)
+std::auto_ptr<Public_Key> load_key(const std::string& fsname)
    {
-   DataSource_Stream source(fsname, true);
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Stream (fsname, true));
    return X509::load_key(source);
    }
 
 /*************************************************
 * Extract a public key and return it             *
 *************************************************/
-Public_Key* load_key(const MemoryRegion<byte>& mem)
+std::auto_ptr<Public_Key> load_key(const MemoryRegion<byte>& mem)
    {
-   DataSource_Memory source(mem);
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(mem));
    return X509::load_key(source);
    }
 
 /*************************************************
 * Make a copy of this public key                 *
 *************************************************/
-Public_Key* copy_key(const Public_Key& key)
+std::auto_ptr<Public_Key> copy_key(const Public_Key& key)
    {
    Pipe bits;
    bits.start_msg();
    X509::encode(key, bits, RAW_BER);
    bits.end_msg();
-   DataSource_Memory source(bits.read_all());
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(bits.read_all()));
    return X509::load_key(source);
    }
 
============================================================
--- src/x509_obj.cpp	f23e2574a233912956eeee348f088438350df3ca
+++ src/x509_obj.cpp	32ecae243f8be2d2128d726e8c29e6b4a2be4176
@@ -12,31 +12,31 @@
 #include <botan/parsing.h>
 #include <botan/pem.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
 /*************************************************
 * Create a generic X.509 object                  *
 *************************************************/
-X509_Object::X509_Object(DataSource& stream, const std::string& labels)
-   {
-   init(stream, labels);
-   }
+ X509_Object::X509_Object(SharedPtrConverter<DataSource> stream, const std::string& labels)
+    {
+    init(stream.get_shared(), labels);
+    }
 
 /*************************************************
 * Createa a generic X.509 object                 *
 *************************************************/
-X509_Object::X509_Object(const std::string& file, const std::string& labels)
-   {
-   DataSource_Stream stream(file, true);
-   init(stream, labels);
-   }
+ X509_Object::X509_Object(const std::string& file, const std::string& labels)
+    {
+    std::tr1::shared_ptr<DataSource> stream(new DataSource_Stream(file, true));
+    init(stream, labels);
+    }
 
 /*************************************************
 * Read a PEM or BER X.509 object                 *
 *************************************************/
-void X509_Object::init(DataSource& in, const std::string& labels)
+void X509_Object::init(SharedPtrConverter<DataSource> in, const std::string& labels)
    {
    PEM_labels_allowed = split_on(labels, '/');
    if(PEM_labels_allowed.size() < 1)
@@ -46,12 +46,12 @@ void X509_Object::init(DataSource& in, c
    std::sort(PEM_labels_allowed.begin(), PEM_labels_allowed.end());
 
    try {
-      if(ASN1::maybe_BER(in) && !PEM_Code::matches(in))
-         decode_info(in);
+      if(ASN1::maybe_BER(in.get_shared()) && !PEM_Code::matches(in.get_shared()))
+         decode_info(in.get_shared());
       else
          {
          std::string got_label;
-         DataSource_Memory ber(PEM_Code::decode(in, got_label));
+         std::tr1::shared_ptr<DataSource> ber(new DataSource_Memory (PEM_Code::decode(in.get_shared(), got_label)));
 
          if(!std::binary_search(PEM_labels_allowed.begin(),
                                 PEM_labels_allowed.end(), got_label))
@@ -68,9 +68,9 @@ void X509_Object::init(DataSource& in, c
 /*************************************************
 * Read a BER encoded X.509 object                *
 *************************************************/
-void X509_Object::decode_info(DataSource& source)
+void X509_Object::decode_info(SharedPtrConverter<DataSource> source)
    {
-   BER_Decoder(source)
+   BER_Decoder(source.get_shared())
       .start_cons(SEQUENCE)
          .start_cons(SEQUENCE)
             .raw_bytes(tbs_bits)
@@ -102,31 +102,8 @@ void X509_Object::encode(Pipe& out, X509
       out.write(der);
    }
 
-/*************************************************
-* Return a BER encoded X.509 object              *
-*************************************************/
-SecureVector<byte> X509_Object::BER_encode() const
-   {
-   Pipe ber;
-   ber.start_msg();
-   encode(ber, RAW_BER);
-   ber.end_msg();
-   return ber.read_all();
-   }
 
 /*************************************************
-* Return a PEM encoded X.509 object              *
-*************************************************/
-std::string X509_Object::PEM_encode() const
-   {
-   Pipe pem;
-   pem.start_msg();
-   encode(pem, PEM);
-   pem.end_msg();
-   return pem.read_all_as_string();
-   }
-
-/*************************************************
 * Return the TBS data                            *
 *************************************************/
 SecureVector<byte> X509_Object::tbs_data() const
@@ -143,13 +120,14 @@ SecureVector<byte> X509_Object::signatur
    }
 
 /*************************************************
-* Return the algorithm used to sign this object  *
+   * Return the signature of this object            *
 *************************************************/
-AlgorithmIdentifier X509_Object::signature_algorithm() const
+   SecureVector<byte> X509_Object::get_concat_sig() const
    {
-   return sig_algo;
+   return sig;
    }
 
+
 /*************************************************
 * Check the signature on an object               *
 *************************************************/
@@ -172,13 +150,13 @@ bool X509_Object::check_signature(Public
          {
          PK_Verifying_with_MR_Key& sig_key =
             dynamic_cast<PK_Verifying_with_MR_Key&>(pub_key);
-         verifier.reset(get_pk_verifier(sig_key, padding, format));
+         verifier.reset(get_pk_verifier(sig_key, padding, format).release());
          }
       else if(dynamic_cast<PK_Verifying_wo_MR_Key*>(&pub_key))
          {
          PK_Verifying_wo_MR_Key& sig_key =
             dynamic_cast<PK_Verifying_wo_MR_Key&>(pub_key);
-         verifier.reset(get_pk_verifier(sig_key, padding, format));
+         verifier.reset(get_pk_verifier(sig_key, padding, format).release());
          }
       else
          return false;
@@ -194,7 +172,7 @@ bool X509_Object::check_signature(Public
 /*************************************************
 * Apply the X.509 SIGNED macro                   *
 *************************************************/
-MemoryVector<byte> X509_Object::make_signed(PK_Signer* signer,
+MemoryVector<byte> X509_Object::make_signed(SharedPtrConverter<PK_Signer> signer,
                                             const AlgorithmIdentifier& algo,
                                             const MemoryRegion<byte>& tbs_bits)
    {
@@ -202,31 +180,10 @@ MemoryVector<byte> X509_Object::make_sig
       .start_cons(SEQUENCE)
          .raw_bytes(tbs_bits)
          .encode(algo)
-         .encode(signer->sign_message(tbs_bits), BIT_STRING)
+         .encode(signer.get_shared()->sign_message(tbs_bits), BIT_STRING)
       .end_cons()
    .get_contents();
    }
 
-/*************************************************
-* Try to decode the actual information           *
-*************************************************/
-void X509_Object::do_decode()
-   {
-   try {
-      force_decode();
-      }
-   catch(Decoding_Error& e)
-      {
-      const std::string what = e.what();
-      throw Decoding_Error(PEM_label_pref + " decoding failed (" +
-                           what.substr(23, std::string::npos) + ")");
-      }
-   catch(Invalid_Argument& e)
-      {
-      const std::string what = e.what();
-      throw Decoding_Error(PEM_label_pref + " decoding failed (" +
-                           what.substr(7, std::string::npos) + ")");
-      }
-   }
 
-}
+ }
============================================================
--- src/x509cert.cpp	d5de5f096e8a47ab498b0b0d90042775c3a1c0fa
+++ src/x509cert.cpp	cbf4e1b889419e85f1c68a0ceb5d1d4a30d0936c
@@ -9,10 +9,11 @@
 #include <botan/ber_dec.h>
 #include <botan/stl_util.h>
 #include <botan/parsing.h>
-#include <botan/bigint.h>
 #include <botan/oids.h>
 #include <botan/pem.h>
 #include <algorithm>
+#include <botan/bigint.h>
+using namespace Botan::math;
 
 namespace Botan {
 
@@ -39,7 +40,7 @@ std::vector<std::string> lookup_oids(con
 /*************************************************
 * X509_Certificate Constructor                   *
 *************************************************/
-X509_Certificate::X509_Certificate(DataSource& in) :
+X509_Certificate::X509_Certificate(std::tr1::shared_ptr<DataSource> in) :
    X509_Object(in, "CERTIFICATE/X509 CERTIFICATE")
    {
    self_signed = false;
@@ -116,7 +117,7 @@ void X509_Certificate::force_decode()
                         v3_exts_data.type_tag, v3_exts_data.class_tag);
 
    if(tbs_cert.more_items())
-      throw Decoding_Error("TBSCertificate has more items that expected");
+      throw Decoding_Error("TBSCertificate has more items than expected");
 
    subject.add("X509.Certificate.version", version);
    subject.add("X509.Certificate.serial", BigInt::encode(serial_bn));
@@ -186,9 +187,9 @@ X509_Certificate::issuer_info(const std:
 /*************************************************
 * Return the public key in this certificate      *
 *************************************************/
-Public_Key* X509_Certificate::subject_public_key() const
+std::auto_ptr<Public_Key> X509_Certificate::subject_public_key() const
    {
-   DataSource_Memory source(subject.get1("X509.Certificate.public_key"));
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(subject.get1("X509.Certificate.public_key")));
    return X509::load_key(source);
    }
 
@@ -312,9 +313,8 @@ X509_DN create_dn(const Data_Store& info
             return false;
             }
       };
-
    std::multimap<std::string, std::string> names =
-      info.search_with(DN_Matcher());
+        info.search_with(DN_Matcher());
 
    X509_DN dn;
 
@@ -350,7 +350,7 @@ AlternativeName create_alt_name(const Da
       };
 
    std::multimap<std::string, std::string> names =
-      info.search_with(AltName_Matcher("RFC822/DNS/URI"));
+   	    info.search_with(AltName_Matcher("RFC822/DNS/URI"));
 
    AlternativeName alt_name;
 
============================================================
--- src/x509self.cpp	5f92488b35e43625413b0215aac9d1f46a1d7a99
+++ src/x509self.cpp	e645cced01e648d6f704e0279b5151b9d6b60f83
@@ -11,7 +11,7 @@
 #include <botan/look_pk.h>
 #include <botan/oids.h>
 #include <botan/pipe.h>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -70,7 +70,7 @@ X509_Certificate create_self_signed_cert
    AlternativeName subject_alt;
 
    MemoryVector<byte> pub_key = shared_setup(opts, key);
-   std::auto_ptr<PK_Signer> signer(choose_sig_format(key, sig_algo));
+   std::tr1::shared_ptr<PK_Signer> signer(choose_sig_format(key, sig_algo));
    load_info(opts, subject_dn, subject_alt);
 
    Key_Constraints constraints;
@@ -81,16 +81,16 @@ X509_Certificate create_self_signed_cert
 
    Extensions extensions;
 
-   extensions.add(new Cert_Extension::Subject_Key_ID(pub_key));
-   extensions.add(new Cert_Extension::Key_Usage(constraints));
-   extensions.add(
-      new Cert_Extension::Extended_Key_Usage(opts.ex_constraints));
-   extensions.add(
-      new Cert_Extension::Subject_Alternative_Name(subject_alt));
-   extensions.add(
-      new Cert_Extension::Basic_Constraints(opts.is_CA, opts.path_limit));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Subject_Key_ID>(new Cert_Extension::Subject_Key_ID(pub_key)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Key_Usage>(new Cert_Extension::Key_Usage(constraints)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Extended_Key_Usage>(
+      new Cert_Extension::Extended_Key_Usage(opts.ex_constraints)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Subject_Alternative_Name>(
+      new Cert_Extension::Subject_Alternative_Name(subject_alt)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Basic_Constraints>(
+      new Cert_Extension::Basic_Constraints(opts.is_CA, opts.path_limit)));
 
-   return X509_CA::make_cert(signer.get(), sig_algo, pub_key,
+   return X509_CA::make_cert(signer, sig_algo, pub_key,
                              opts.start, opts.end,
                              subject_dn, subject_dn,
                              extensions);
@@ -107,25 +107,25 @@ PKCS10_Request create_cert_req(const X50
    AlternativeName subject_alt;
 
    MemoryVector<byte> pub_key = shared_setup(opts, key);
-   std::auto_ptr<PK_Signer> signer(choose_sig_format(key, sig_algo));
+   std::tr1::shared_ptr<PK_Signer> signer(choose_sig_format(key, sig_algo));
    load_info(opts, subject_dn, subject_alt);
 
    const u32bit PKCS10_VERSION = 0;
 
    Extensions extensions;
 
-   extensions.add(
-      new Cert_Extension::Basic_Constraints(opts.is_CA, opts.path_limit));
-   extensions.add(
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Basic_Constraints>(
+      new Cert_Extension::Basic_Constraints(opts.is_CA, opts.path_limit)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Key_Usage>(
       new Cert_Extension::Key_Usage(
          opts.is_CA ? Key_Constraints(KEY_CERT_SIGN | CRL_SIGN) :
                       find_constraints(key, opts.constraints)
          )
-      );
-   extensions.add(
-      new Cert_Extension::Extended_Key_Usage(opts.ex_constraints));
-   extensions.add(
-      new Cert_Extension::Subject_Alternative_Name(subject_alt));
+      ));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Extended_Key_Usage>(
+      new Cert_Extension::Extended_Key_Usage(opts.ex_constraints)));
+   extensions.add(std::tr1::shared_ptr<Cert_Extension::Subject_Alternative_Name>(
+      new Cert_Extension::Subject_Alternative_Name(subject_alt)));
 
    DER_Encoder tbs_req;
 
@@ -158,10 +158,10 @@ PKCS10_Request create_cert_req(const X50
       .end_explicit()
       .end_cons();
 
-   DataSource_Memory source(
-      X509_Object::make_signed(signer.get(), sig_algo,
+   std::tr1::shared_ptr<DataSource> source(new DataSource_Memory(
+      X509_Object::make_signed(signer, sig_algo,
                                tbs_req.get_contents())
-      );
+      ));
 
    return PKCS10_Request(source);
    }
============================================================
--- src/x509stat.cpp	ad0ea0d4cc9ef4a1aa9ae278b80ffce29d47f237
+++ src/x509stat.cpp	66ccb6732ccf5f9c51f0aa5f1a9306103ab0c63d
@@ -12,18 +12,18 @@ namespace Botan {
 /*************************************************
 * Add a new prototype                            *
 *************************************************/
-void X509_GlobalState::add(Extension_Prototype* proto)
+void X509_GlobalState::add(SharedPtrConverter<Extension_Prototype> proto)
    {
-   if(proto)
-      prototypes.push_back(proto);
+   if(proto.get_shared().get())
+      prototypes.push_back(proto.get_shared());
    }
 
 /*************************************************
 * Get an extension object                        *
 *************************************************/
-Certificate_Extension* X509_GlobalState::get_extension(const OID& oid) const
+std::tr1::shared_ptr<Certificate_Extension> X509_GlobalState::get_extension(const OID& oid) const
    {
-   Certificate_Extension* extension = 0;
+   std::tr1::shared_ptr<Certificate_Extension> extension;
    for(u32bit j = 0; j != prototypes.size() && !extension; ++j)
       extension = prototypes[j]->make(oid);
    return extension;
@@ -35,19 +35,19 @@ X509_GlobalState::X509_GlobalState()
 X509_GlobalState::X509_GlobalState()
    {
 
-#define CREATE_PROTOTYPE(NAME, TYPE)                         \
-   do {                                                      \
-      struct TYPE ## _Prototype : public Extension_Prototype \
-         {                                                   \
-         Certificate_Extension* make(const OID& oid)         \
-            {                                                \
-            if(Botan::OIDS::name_of(oid, NAME))              \
-               return new Botan::Cert_Extension::TYPE();     \
-            return 0;                                        \
-            }                                                \
-         };                                                  \
-                                                             \
-      add(new TYPE ## _Prototype);                           \
+#define CREATE_PROTOTYPE(NAME, TYPE)                                                           \
+   do {                                                                                        \
+      struct TYPE ## _Prototype : public Extension_Prototype                                   \
+         {                                                                                     \
+         std::tr1::shared_ptr<Certificate_Extension> make(const OID& oid)                      \
+            {                                                                                  \
+            if(Botan::OIDS::name_of(oid, NAME))                                                       \
+               return std::tr1::shared_ptr<Certificate_Extension>(new Botan::Cert_Extension::TYPE()); \
+            return std::tr1::shared_ptr<Certificate_Extension>();                                \
+            }                                                                                  \
+         };                                                                                    \
+                                                                                               \
+      add(std::tr1::shared_ptr<Extension_Prototype>(dynamic_cast<Extension_Prototype*>(new TYPE ## _Prototype)));  \
    } while(0);
 
    CREATE_PROTOTYPE("X509v3.KeyUsage", Key_Usage);
@@ -68,8 +68,6 @@ X509_GlobalState::~X509_GlobalState()
 *************************************************/
 X509_GlobalState::~X509_GlobalState()
    {
-   for(u32bit j = 0; j != prototypes.size(); ++j)
-      delete prototypes[j];
    prototypes.clear();
    }
 
============================================================
--- src/x509stor.cpp	6e4f9030fde21f4d670d1f669ac31868b789365b
+++ src/x509stor.cpp	5737d6fdfcc815d7dc3190c825266bd6a870d61a
@@ -11,7 +11,7 @@
 #include <botan/config.h>
 #include <botan/util.h>
 #include <algorithm>
-#include <memory>
+#include <botan/tr1_mem_includer.h>
 
 namespace Botan {
 
@@ -167,7 +167,7 @@ X509_Store::X509_Store(const X509_Store&
    revoked = store.revoked;
    revoked_info_valid = store.revoked_info_valid;
    for(u32bit j = 0; j != store.stores.size(); ++j)
-      stores[j] = store.stores[j]->clone();
+      stores[j] = std::tr1::shared_ptr<Certificate_Store>(store.stores[j]->clone().release());
    }
 
 /*************************************************
@@ -175,8 +175,7 @@ X509_Store::~X509_Store()
 *************************************************/
 X509_Store::~X509_Store()
    {
-   for(u32bit j = 0; j != stores.size(); ++j)
-      delete stores[j];
+   stores.clear();
    }
 
 /*************************************************
@@ -354,16 +353,15 @@ X509_Code X509_Store::check_sig(const Ce
 /*************************************************
 * Check a CA's signature                         *
 *************************************************/
-X509_Code X509_Store::check_sig(const X509_Object& object, Public_Key* key)
+X509_Code X509_Store::check_sig(const X509_Object& object, std::auto_ptr<Public_Key> key)
    {
-   std::auto_ptr<Public_Key> pub_key(key);
    std::auto_ptr<PK_Verifier> verifier;
 
    try {
       std::vector<std::string> sig_info =
          split_on(OIDS::lookup(object.signature_algorithm().oid), '/');
 
-      if(sig_info.size() != 2 || sig_info[0] != pub_key->algo_name())
+      if(sig_info.size() != 2 || sig_info[0] != key->algo_name())
          return SIGNATURE_ERROR;
 
       std::string padding = sig_info[1];
@@ -371,17 +369,17 @@ X509_Code X509_Store::check_sig(const X5
       if(key->message_parts() >= 2) format = DER_SEQUENCE;
       else                          format = IEEE_1363;
 
-      if(dynamic_cast<PK_Verifying_with_MR_Key*>(pub_key.get()))
+      if(dynamic_cast<PK_Verifying_with_MR_Key*>(key.get()))
          {
          PK_Verifying_with_MR_Key* sig_key =
-            dynamic_cast<PK_Verifying_with_MR_Key*>(pub_key.get());
-         verifier.reset(get_pk_verifier(*sig_key, padding, format));
+            dynamic_cast<PK_Verifying_with_MR_Key*>(key.get());
+         verifier.reset(get_pk_verifier(*sig_key, padding, format).release());
          }
-      else if(dynamic_cast<PK_Verifying_wo_MR_Key*>(pub_key.get()))
+      else if(dynamic_cast<PK_Verifying_wo_MR_Key*>(key.get()))
          {
          PK_Verifying_wo_MR_Key* sig_key =
-            dynamic_cast<PK_Verifying_wo_MR_Key*>(pub_key.get());
-         verifier.reset(get_pk_verifier(*sig_key, padding, format));
+            dynamic_cast<PK_Verifying_wo_MR_Key*>(key.get());
+         verifier.reset(get_pk_verifier(*sig_key, padding, format).release());
          }
       else
          return CA_CERT_CANNOT_SIGN;
@@ -471,9 +469,9 @@ X509_Store::get_cert_chain(const X509_Ce
 /*************************************************
 * Add a certificate store to the list of stores  *
 *************************************************/
-void X509_Store::add_new_certstore(Certificate_Store* certstore)
+void X509_Store::add_new_certstore(SharedPtrConverter<Certificate_Store> certstore)
    {
-   stores.push_back(certstore);
+   stores.push_back(certstore.get_shared());
    }
 
 /*************************************************
@@ -504,12 +502,12 @@ void X509_Store::add_cert(const X509_Cer
 /*************************************************
 * Add one or more certificates to the store      *
 *************************************************/
-void X509_Store::do_add_certs(DataSource& source, bool trusted)
+void X509_Store::do_add_certs(SharedPtrConverter<DataSource> source, bool trusted)
    {
-   while(!source.end_of_data())
+   while(!source.get_shared()->end_of_data())
       {
       try {
-         X509_Certificate cert(source);
+         X509_Certificate cert(source.get_shared());
          add_cert(cert, trusted);
          }
       catch(Decoding_Error) {}
@@ -520,17 +518,17 @@ void X509_Store::do_add_certs(DataSource
 /*************************************************
 * Add one or more certificates to the store      *
 *************************************************/
-void X509_Store::add_certs(DataSource& source)
+void X509_Store::add_certs(SharedPtrConverter<DataSource> source)
    {
-   do_add_certs(source, false);
+   do_add_certs(source.get_shared(), false);
    }
 
 /*************************************************
 * Add one or more certificates to the store      *
 *************************************************/
-void X509_Store::add_trusted_certs(DataSource& source)
+void X509_Store::add_trusted_certs(SharedPtrConverter<DataSource> source)
    {
-   do_add_certs(source, true);
+   do_add_certs(source.get_shared(), true);
    }
 
 /*************************************************
============================================================
--- src/x919_mac.cpp	6949a6083678969fa14525a7269d65e1c8f33396
+++ src/x919_mac.cpp	d9fe70519f7913290c749d03c0e862dcc055683d
@@ -73,10 +73,9 @@ void ANSI_X919_MAC::clear() throw()
 /*************************************************
 * ANSI X9.19 MAC Constructor                     *
 *************************************************/
-ANSI_X919_MAC::ANSI_X919_MAC() : MessageAuthenticationCode(8, 8, 16, 8)
+ANSI_X919_MAC::ANSI_X919_MAC() : MessageAuthenticationCode(8, 8, 16, 8),
+   e(get_block_cipher("DES").release()), d(get_block_cipher("DES").release())
    {
-   e = get_block_cipher("DES");
-   d = get_block_cipher("DES");
    position = 0;
    }
 
@@ -85,8 +84,6 @@ ANSI_X919_MAC::~ANSI_X919_MAC()
 *************************************************/
 ANSI_X919_MAC::~ANSI_X919_MAC()
    {
-   delete e;
-   delete d;
    }
 
 }
============================================================
--- src/x931_rng.cpp	e75b008bdb53486d98d7aea0dacaa607e55ea0f0
+++ src/x931_rng.cpp	761bdc72356775a75efe9bd2eb3192bfd1bacb61
@@ -107,19 +107,20 @@ ANSI_X931_RNG::ANSI_X931_RNG(const std::
 * ANSI X931 RNG Constructor                      *
 *************************************************/
 ANSI_X931_RNG::ANSI_X931_RNG(const std::string& cipher_name,
-                             RandomNumberGenerator* prng_ptr)
+		SharedPtrConverter<RandomNumberGenerator> prng_ptr)
    {
    if(cipher_name == "")
-      cipher = get_block_cipher("AES-256");
+      cipher = std::tr1::shared_ptr<BlockCipher>(get_block_cipher("AES-256").release());
    else
-      cipher = get_block_cipher(cipher_name);
+      cipher = std::tr1::shared_ptr<BlockCipher>(get_block_cipher(cipher_name).release());
 
    const u32bit BLOCK_SIZE = cipher->BLOCK_SIZE;
 
    V.create(BLOCK_SIZE);
    R.create(BLOCK_SIZE);
 
-   prng = (prng_ptr ? prng_ptr : new Randpool);
+   std::tr1::shared_ptr<RandomNumberGenerator> prng_sptr = prng_ptr.get_shared();
+   prng = (prng_sptr.get() ? prng_sptr : std::tr1::shared_ptr<RandomNumberGenerator>(new Randpool));
 
    position = 0;
    }
@@ -129,8 +130,7 @@ ANSI_X931_RNG::~ANSI_X931_RNG()
 *************************************************/
 ANSI_X931_RNG::~ANSI_X931_RNG()
    {
-   delete cipher;
-   delete prng;
+
    }
 
 }
