/*
* ChaCha_RNG
* (C) 2017 Jack Lloyd
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#include <botan/chacha_rng.h>

#include <botan/assert.h>
#include <botan/internal/buffer_slicer.h>
#include <botan/internal/stl_util.h>

namespace Botan {

ChaCha_RNG::ChaCha_RNG(bool fast_key_erasure) :
      m_hmac(MessageAuthenticationCode::create_or_throw(hmac_algo)),
      m_chacha(StreamCipher::create_or_throw(stream_cipher_algo)),
      m_fast_key_erasure(fast_key_erasure) {
   clear();
}

ChaCha_RNG::ChaCha_RNG(std::span<const uint8_t> seed, bool fast_key_erasure) : ChaCha_RNG(fast_key_erasure) {
   add_entropy(seed);
}

ChaCha_RNG::ChaCha_RNG(RandomNumberGenerator& underlying_rng, size_t reseed_interval, bool fast_key_erasure) :
      Stateful_RNG(underlying_rng, reseed_interval),
      m_hmac(MessageAuthenticationCode::create_or_throw(hmac_algo)),
      m_chacha(StreamCipher::create_or_throw(stream_cipher_algo)),
      m_fast_key_erasure(fast_key_erasure) {
   clear();
}

ChaCha_RNG::ChaCha_RNG(RandomNumberGenerator& underlying_rng,
                       Entropy_Sources& entropy_sources,
                       size_t reseed_interval,
                       bool fast_key_erasure) :
      Stateful_RNG(underlying_rng, entropy_sources, reseed_interval),
      m_hmac(MessageAuthenticationCode::create_or_throw(hmac_algo)),
      m_chacha(StreamCipher::create_or_throw(stream_cipher_algo)),
      m_fast_key_erasure(fast_key_erasure) {
   clear();
}

ChaCha_RNG::ChaCha_RNG(Entropy_Sources& entropy_sources, size_t reseed_interval, bool fast_key_erasure) :
      Stateful_RNG(entropy_sources, reseed_interval),
      m_hmac(MessageAuthenticationCode::create_or_throw(hmac_algo)),
      m_chacha(StreamCipher::create_or_throw(stream_cipher_algo)),
      m_fast_key_erasure(fast_key_erasure) {
   clear();
}

void ChaCha_RNG::clear_state() {
   m_hmac->set_key(std::vector<uint8_t>(m_hmac->output_length(), 0x00));
   update_chacha_state(m_hmac->final());
}

void ChaCha_RNG::update_chacha_state(std::span<const uint8_t> key_material) {
   BufferSlicer bs(key_material);
   m_chacha->set_key(bs.take<chacha_key_len>());
   m_chacha->set_iv(bs.take<chacha_iv_len>());
}

void ChaCha_RNG::generate_output(std::span<uint8_t> output, std::span<const uint8_t> input) {
   BOTAN_ASSERT_NOMSG(!output.empty());

   if(!input.empty()) {
      update(input);
   }

   //  Always generate next key material from the first blocks generated by a key
   //  as it removes a positional argument from a possible analysis.
   const auto key_material = m_chacha->keystream_bytes(m_fast_key_erasure ? chacha_key_len + chacha_iv_len : 0);

   m_chacha->write_keystream(output);

   // optionally overwrite key after each output operation for backtracking resistance
   if(m_fast_key_erasure) {
      update_chacha_state(key_material);
   }
}

void ChaCha_RNG::update(std::span<const uint8_t> input) {
   update_chacha_state(m_hmac->process(input));
   m_hmac->set_key(m_chacha->keystream_bytes(m_hmac->output_length()));
}

size_t ChaCha_RNG::security_level() const {
   /*
    * as we use a 64 bit nonce as extended key and a wide enough hash
    * function with SHA-512, could also be set to 256 + 64 = 320
    */
   return 256;
}

}  // namespace Botan
