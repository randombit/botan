/*
* (C) 2021 Jack Lloyd
* (C) 2021 Ren√© Meusel
*
* Botan is released under the Simplified BSD License (see license.txt)
*/

#include "tests.h"
#include <memory>
// Since RFC 8448 uses a specific set of cipher suites we can only run this
// test if all of them are enabled.
#if defined(BOTAN_HAS_TLS_13) && \
    defined(BOTAN_HAS_AEAD_CHACHA20_POLY1305) && \
    defined(BOTAN_HAS_AEAD_GCM) && \
    defined(BOTAN_HAS_AES) && \
    defined(BOTAN_HAS_CURVE_25519) && \
    defined(BOTAN_HAS_SHA2_32) && \
    defined(BOTAN_HAS_SHA2_64)
#define BOTAN_CAN_RUN_TEST_TLS_RFC8448
#endif

#if defined(BOTAN_CAN_RUN_TEST_TLS_RFC8448)
  #include "test_rng.h"
  #include "test_tls_utils.h"

  #include <botan/auto_rng.h>  // TODO: replace me, otherwise we depend on auto_rng module
  #include <botan/credentials_manager.h>
  #include <botan/rsa.h>
  #include <botan/tls_alert.h>
  #include <botan/tls_callbacks.h>
  #include <botan/tls_client.h>
  #include <botan/tls_policy.h>
  #include <botan/tls_messages.h>
  #include <botan/internal/tls_reader.h>
  #include <botan/tls_server.h>
  #include <botan/tls_server_info.h>
  #include <botan/tls_session.h>
  #include <botan/tls_session_manager.h>
  #include <botan/tls_version.h>

  #include <botan/assert.h>
  #include <botan/internal/stl_util.h>

  #include <botan/internal/loadstor.h>
#endif

namespace Botan_Tests {

#if defined(BOTAN_CAN_RUN_TEST_TLS_RFC8448)

namespace
{
constexpr size_t RECORD_HEADER_SIZE = 5;

template <typename Itr>
decltype(auto) slice(Itr begin, Itr end)
   {
   return std::vector<uint8_t>(begin, end);
   }

template <typename DataT, typename MaskT>
decltype(auto) apply_mask(const DataT &data, const MaskT &mask)
   {
   BOTAN_ASSERT(data.size() >= mask.size(), "data should be at least as long as mask");
   DataT result = slice(data.begin(), data.begin() + mask.size());
   std::transform(result.begin(), result.end(), mask.begin(), result.begin(),
                  [](const auto &d, const auto &m)
                     {
                     return d | m;
                     });
   return result;
   }

void check_record_header(Test::Result &result, const std::vector<uint8_t> &record)
   {
   const bool header_present = record.size() >= RECORD_HEADER_SIZE;
   result.confirm("record header is present", header_present);
   if (!header_present) return;

   // RFC8446 5.1
   // legacy_record_version:  MUST be set to 0x0303 for all records
   //       generated by a TLS 1.3 implementation other than an initial
   //       ClientHello (i.e., one not generated after a HelloRetryRequest),
   //       where it MAY also be 0x0301 for compatibility purposes.
   // Botan sets the version to 0x0303 also for the client hello
   result.test_eq("record version set correctly", slice(record.begin(), record.begin() + 3), Botan::hex_decode("160303"));
   const auto msg_len = Botan::load_be<uint16_t>(record.data() + 3, 0);
   const auto msg = slice(record.begin() + RECORD_HEADER_SIZE, record.end());
   result.test_eq("record has indicated length", msg.size(), msg_len);
   }

decltype(auto) parse_extensions(const std::vector<uint8_t> &exts_buffer, Test::Result &result)
   {
   std::map<uint16_t, std::vector<uint8_t>> exts;

   Botan::TLS::TLS_Data_Reader tdr("Extensions", exts_buffer);

   const auto exts_len = tdr.get_uint16_t();
   if (!result.test_eq("extension buffer has expected length", tdr.remaining_bytes(), exts_len))
      return exts;

   while (tdr.has_remaining())
      {
      const auto ext_type = tdr.get_uint16_t();
      const auto ext_len  = tdr.get_uint16_t();

      if (!result.test_gte("enough bytes to read extension", tdr.remaining_bytes(), ext_len)) {
         break;
      }

      exts[ext_type] = tdr.get_fixed<uint8_t>(ext_len);
      }

   return exts;
   }

void compare_signature_scheme_extensions(const std::vector<uint8_t> &produced_schemes, const std::vector<uint8_t> &expected_schemes, Test::Result &result)
  {
  auto preader = Botan::TLS::TLS_Data_Reader("Produced Signature_Algorithms", produced_schemes);
  auto ps = Botan::TLS::Signature_Algorithms(preader, produced_schemes.size()).supported_schemes();

  auto ereader = Botan::TLS::TLS_Data_Reader("Expected Signature_Algorithms", expected_schemes);
  auto es = Botan::TLS::Signature_Algorithms(ereader, expected_schemes.size()).supported_schemes();

  for (const auto& scheme : es)
     {
     if (!Botan::TLS::signature_scheme_is_known(scheme))
       // do not check for schemes Botan doesn't support
       continue;

     if (!result.confirm("expected scheme is present", Botan::value_exists(ps, scheme)))
        result.test_note(std::string("did not produce expected signature scheme: ") + Botan::TLS::sig_scheme_to_string(scheme));
     }

  for (const auto& scheme : ps)
     {
     if (!result.confirm("produced scheme was expected", Botan::value_exists(es, scheme)))
        result.test_note(std::string("produced unexpected signature scheme: ") + Botan::TLS::sig_scheme_to_string(scheme));
     }

  // TODO: the order of schemes is not checked
  }

void compare_extensions(const std::vector<uint8_t> &exts_buffer, const std::vector<uint8_t> &exp_exts_buffer, Test::Result &result)
{
   const auto prod = parse_extensions(exts_buffer, result);
   const auto exp  = parse_extensions(exp_exts_buffer, result);

   for (const auto &eext : exp)
   {
      switch (eext.first) {
        case Botan::TLS::Handshake_Extension_Type::TLSEXT_RECORD_SIZE_LIMIT:
           result.test_note(std::string("ignoring not yet implemented extension record_size_limit"));
           continue;
        case Botan::TLS::Handshake_Extension_Type::TLSEXT_PSK_KEY_EXCHANGE_MODES:
           result.test_note(std::string("ignoring not yet implemented extension psk_key_exchange_modes"));
           continue;
      }

      const auto &pext = prod.find(eext.first);
      if (!result.confirm("expected extension is present", pext != prod.end())) {
         result.test_note(std::string("expected to produce TLS extension: ") + std::to_string(eext.first));
      }
   }

   for (const auto &pext : prod)
   {
      const auto &eext = exp.find(pext.first);
      if (!result.confirm("produced extension was expected", eext != exp.end())) {
         result.test_note(std::string("did not expect to produce TLS extension: ") + std::to_string(pext.first));
         continue;
      }

      if (pext.first == Botan::TLS::Handshake_Extension_Type::TLSEXT_SIGNATURE_ALGORITHMS)
         compare_signature_scheme_extensions(pext.second, eext->second, result);
      else
         result.test_eq(std::string("content of extension type ") + std::to_string(pext.first), pext.second, eext->second);
   }
}

void add_entropy(Botan_Tests::Fixed_Output_RNG &rng, const std::string& hex)
   {
       std::vector<uint8_t> in = Botan::hex_decode(hex);
       rng.add_entropy(in.data(), in.size());
   }

Botan::RSA_PrivateKey server_private_key()
   {
   return
      {
      Botan::BigInt("0xE435FB7CC83737756DACEA96AB7F59A2CC1069DB7DEB190E17E33A532B273F30A327AA0AAABC58CD67466AF9845FADC675FE094AF92C4BD1F2C1BC33DD2E0515"),
      Botan::BigInt("0xCABD3BC0E0438664C8D4CC9F99977A94D9BBFEAD8E43870ABAE3F7EB8B4E0EEE8AF1D9B4719BA6196CF2CBBAEEEBF8B3490AFE9E9FFA74A88AA51FC645629303"),
      Botan::BigInt("0x010001")
      };
   }

Botan::X509_Certificate server_certificate()
   {
   // self-signed certificate with an RSA1024 public key
   //
   //   [...]
   //   Issuer: CN=rsa
   //   Validity
   //       Not Before: Jul 30 01:23:59 2016 GMT
   //       Not After : Jul 30 01:23:59 2026 GMT
   //   Subject: CN=rsa
   //   [...]
   //   X509v3 extensions:
   //        X509v3 Basic Constraints:
   //            CA:FALSE
   //        X509v3 Key Usage:
   //            Digital Signature, Key Encipherment
   //   [...]
   return Botan::X509_Certificate(
      Botan::hex_decode(
         "308201ac30820115a003020102020102300d06092a864886f70d01010b050030"
         "0e310c300a06035504031303727361301e170d3136303733303031323335395a"
         "170d3236303733303031323335395a300e310c300a0603550403130372736130"
         "819f300d06092a864886f70d010101050003818d0030818902818100b4bb498f"
         "8279303d980836399b36c6988c0c68de55e1bdb826d3901a2461eafd2de49a91"
         "d015abbc9a95137ace6c1af19eaa6af98c7ced43120998e187a80ee0ccb0524b"
         "1b018c3e0b63264d449a6d38e22a5fda430846748030530ef0461c8ca9d9efbf"
         "ae8ea6d1d03e2bd193eff0ab9a8002c47428a6d35a8d88d79f7f1e3f02030100"
         "01a31a301830090603551d1304023000300b0603551d0f0404030205a0300d06"
         "092a864886f70d01010b05000381810085aad2a0e5b9276b908c65f73a726717"
         "0618a54c5f8a7b337d2df7a594365417f2eae8f8a58c8f8172f9319cf36b7fd6"
         "c55b80f21a03015156726096fd335e5e67f2dbf102702e608ccae6bec1fc63a4"
         "2a99be5c3eb7107c3c54e9b9eb2bd5203b1c3b84e0a8b2f759409ba3eac9d91d"
         "402dcc0cc8f8961229ac9187b42b4de10000")
      );
   }

class Test_TLS_13_Callbacks : public Botan::TLS::Callbacks
   {
   public:
      void tls_emit_data(const uint8_t data[], size_t size) override
         {
         send_buffer.insert(send_buffer.end(), data, data + size);
         }

      void tls_record_received(uint64_t seq_no, const uint8_t data[], size_t size) override
         {
         BOTAN_UNUSED(seq_no, data, size);
         // process full TLS record received by tls client, e.g.,
         // by passing it to the application
         }

      void tls_alert(Botan::TLS::Alert alert) override
         {
         BOTAN_UNUSED(alert);
         // handle a tls alert received from the tls server
         }

      bool tls_session_established(const Botan::TLS::Session& session) override
         {
         BOTAN_UNUSED(session);
         // the session with the tls client was established
         // return false to prevent the session from being cached, true to
         // cache the session in the configured session manager
         return false;
         }

      std::vector<uint8_t> pull_send_buffer() {
         return std::exchange(send_buffer, std::vector<uint8_t>());
      }

   private:
      std::vector<uint8_t> send_buffer;
   };

class Test_Server_Credentials : public Botan::Credentials_Manager
{
   public:
      Test_Server_Credentials() : m_key(server_private_key()) {}

      std::vector<Botan::Certificate_Store*>
      trusted_certificate_authorities(const std::string &type, const std::string &context) override
         {
         BOTAN_UNUSED(type, context);
         return {};
         }

      std::vector<Botan::X509_Certificate> cert_chain(
         const std::vector<std::string>& cert_key_types,
         const std::string& type,
         const std::string& context) override
         {
         BOTAN_UNUSED(cert_key_types, type, context);
         return { server_certificate() };
         }

      Botan::Private_Key* private_key_for(const Botan::X509_Certificate& cert,
         const std::string& type,
         const std::string& context) override
         {
         BOTAN_UNUSED(cert, type, context);
         // return the private key associated with the leaf certificate,
         // in this case the one associated with "botan.randombit.net.crt"
         return &m_key;
         }

   private:
      Botan::RSA_PrivateKey m_key;
};

class TLS_Context
   {
   protected:
      TLS_Context(std::unique_ptr<Botan::RandomNumberGenerator> rng_in)
         : rng(std::move(rng_in))
         , session_mgr(*rng)
         , policy(read_tls_policy("rfc8448"))
         {}

   public:
      std::vector<uint8_t> pull_send_buffer() {
         return callbacks.pull_send_buffer();
      }

   public:
      Test_TLS_13_Callbacks   callbacks;
      Test_Server_Credentials creds;

      std::unique_ptr<Botan::RandomNumberGenerator> rng;
      Botan::TLS::Session_Manager_In_Memory         session_mgr;
      Botan::TLS::Text_Policy                       policy;
   };

class Server_Context : public TLS_Context
   {
   public:
      Server_Context(std::unique_ptr<Botan::RandomNumberGenerator> rng_in)
         : TLS_Context(std::move(rng_in))
         , server(callbacks, session_mgr, creds, policy, *rng)
         {}

      Botan::TLS::Server server;
   };

class Client_Context : public TLS_Context
   {
   public:
      Client_Context(std::unique_ptr<Botan::RandomNumberGenerator> rng_in)
         : TLS_Context(std::move(rng_in))
         , client(callbacks, session_mgr, creds, policy, *rng,
                  Botan::TLS::Server_Information("server"),
                  Botan::TLS::Protocol_Version::TLS_V13)
         {}

      Botan::TLS::Client client;
   };
}

class Test_TLS_RFC8448 final : public Test
   {
   private:
      Test::Result simple_1_rtt_client_hello()
         {
         Test::Result result("Simple 1-RTT (Client side)");

         // TODO: fixed output RNG is probably not needed as we cannot get the "right"
         //       client hello anyway -- revert
         auto rng = std::make_unique<Botan_Tests::Fixed_Output_RNG>("");
         rng->add_entropy(std::vector<uint8_t>(32).data(), 32);  // used by session mgr for session key
         add_entropy(*rng, "cb34ecb1e78163ba1c38c6dacb196a6dffa21a8d9912ec18a2ef6283024dece7"); // for client hello random

         // for KeyShare extension (RFC 8448: "{client} create an ephemeral x25519 key pair")
         add_entropy(*rng, "49af42ba7f7994852d713ef2784bcbcaa7911de26adc5642cb634540e7ea5005");

         Client_Context ctx(std::move(rng));
         result.confirm("client not closed", !ctx.client.is_closed());

         const auto client_hello_record = ctx.pull_send_buffer();
         result.test_gte("client hello received", client_hello_record.size(), RECORD_HEADER_SIZE);

         check_record_header(result, client_hello_record);
         const auto client_hello_msg = slice(client_hello_record.begin() + RECORD_HEADER_SIZE, client_hello_record.end());


         const auto expected_hello = Botan::hex_decode(
           "16 03 01 00 c4 01 00 00 c0 03 03 cb"
           "34 ec b1 e7 81 63 ba 1c 38 c6 da cb 19 6a 6d ff a2 1a 8d 99 12"
           "ec 18 a2 ef 62 83 02 4d ec e7 00 00 06 13 01 13 03 13 02 01 00"
           "00 91 00 00 00 0b 00 09 00 00 06 73 65 72 76 65 72 ff 01 00 01"
           "00 00 0a 00 14 00 12 00 1d 00 17 00 18 00 19 01 00 01 01 01 02"
           "01 03 01 04 00 23 00 00 00 33 00 26 00 24 00 1d 00 20 99 38 1d"
           "e5 60 e4 bd 43 d2 3d 8e 43 5a 7d ba fe b3 c0 6e 51 c1 3c ae 4d"
           "54 13 69 1e 52 9a af 2c 00 2b 00 03 02 03 04 00 0d 00 20 00 1e"
           "04 03 05 03 06 03 02 03 08 04 08 05 08 06 04 01 05 01 06 01 02"
           "01 04 02 05 02 06 02 02 02 00 2d 00 02 01 01 00 1c 00 02 40 01");

         const auto mask = Botan::hex_decode(
           "00 00 03" /* pin TLS record version to 03 03, as it MAY be 03 01
               RFC 8446 P. 78:
               legacy_record_version:  MUST be set to 0x0303 for all records
                  generated by a TLS 1.3 implementation other than an initial
                  ClientHello (i.e., one not generated after a HelloRetryRequest),
                  where it MAY also be 0x0301 for compatibility purposes.  This
                  field is deprecated and MUST be ignored for all purposes.
                  Previous versions of TLS would use other values in this field
                  under some circumstances. */
           "FF FF"       /* handshake message length should not be checked */
           "00 FF FF FF" /* client hello data length should not be checked */
           "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
           "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
           "00 00 00"
           /* various extensions follow */);

         result.test_eq("TLS client hello without extensions", apply_mask(client_hello_record, mask),
                                                               apply_mask(expected_hello, mask));

         // expected extensions
         // 0000 000b 0009000006736572766572 -- SNI
         // ff01 0001 00 -- Renegotiation
         // 000a 0014 0012 001d 0017 0018 0019 0100 0101 0102 0103 0104 -- Supported Groups
         // 0023 0000 -- Session Ticket
         // 0033 0026 0024 001d 0020 99381de560e4bd43d23d8e435a7dbafeb3c06e51c13cae4d5413691e529aaf2c -- KeyShare (X25519)
         //      private key from RFC:
         //      49 af 42 ba 7f 79 94 85 2d 71 3e f2 78 4b cb ca a7 91 1d e2 6a dc 56 42 cb 63 45 40 e7 ea 50 05
         // 002b 0003 02 0304 -- Supported Versions
         // 000d 0020 001e 0403 0503 0603 0203 08040805080604010501060102010402050206020202 -- Signature Algorithms
         // 002d 0002 01 01 -- Psk Exchange Modes
         // 001c 0002 4001 -- Record Size Limit
         const auto ch_record_exts = slice(client_hello_record.begin() + mask.size(),
                                           client_hello_record.end());
         const auto exp_ch_record_exts = slice(expected_hello.begin() + mask.size(),
                                               expected_hello.end());
         compare_extensions(ch_record_exts, exp_ch_record_exts, result);

         // RFC8446 5.1
         // legacy_record_version:  MUST be set to 0x0303 for all records
         //       generated by a TLS 1.3 implementation other than an initial
         //       ClientHello (i.e., one not generated after a HelloRetryRequest),
         //       where it MAY also be 0x0301 for compatibility purposes.
         result.test_eq("TLS client hello header",
                        slice(client_hello_msg.begin(), client_hello_msg.begin() + 1),
                        Botan::hex_decode("01"));

         auto client_hello_length_bytes = slice(client_hello_msg.begin() + 1, client_hello_msg.begin() + 4);
         client_hello_length_bytes.insert(client_hello_length_bytes.begin(), '\x00');
         const auto indicated_hello_length = Botan::load_be<uint32_t>(client_hello_length_bytes.data(), 0);

         const auto client_hello = slice(client_hello_msg.begin() + 4, client_hello_msg.end());
         result.test_eq("TLS client hello has indicated length",
                        client_hello.size(),
                        indicated_hello_length);

         Botan::TLS::Client_Hello hello(client_hello);
         result.test_eq("only one supported version", hello.supported_versions().size(), 1);
         result.test_int_eq("Supported Version is 1.3",
                            hello.supported_versions().front().version_code(),
                            Botan::TLS::Protocol_Version::TLS_V13);

         // ----

         // header
         //   type: handshake, version: Tls12, len: 90
         // message
         //   version: Tls12, rand_time: 2796488356, rand_data: [...],
         //   session_id: None, cipher: 0x1301(AES_128_GCM_SHA256),
         //   compression: Null, ext: [...]
         const auto server_hello = Botan::hex_decode(
           "16 03 03 00 5a 02 00 00 56 03 03 a6"
           "af 06 a4 12 18 60 dc 5e 6e 60 24 9c d3 4c 95 93 0c 8a c5 cb 14"
           "34 da c1 55 77 2e d3 e2 69 28 00 13 01 00 00 2e 00 33 00 24 00"
           "1d 00 20 c9 82 88 76 11 20 95 fe 66 76 2b db f7 c6 72 e1 56 d6"
           "cc 25 3b 83 3d f1 dd 69 b1 b0 4e 75 1f 0f 00 2b 00 02 03 04");

         ctx.client.received_data(server_hello);

         // to test:
         //   * server responds with cipher suite not offered by client

         return result;
         }

      Test::Result simple_1_rtt_server()
         {
         Test::Result result("Simple 1-RTT (Server side)");

         Server_Context ctx(std::make_unique<Botan::AutoSeeded_RNG>());

         // Cipher Suites in this client hello:
         //   AES_128_GCM_SHA256
         //   CHACHA20_POLY1305_SHA256
         //   AES_256_GCM_SHA384
         const auto client_hello = Botan::hex_decode(
         "16 03 01 00 c4 01 00 00 c0 03 03 cb"
         "34 ec b1 e7 81 63 ba 1c 38 c6 da cb 19 6a 6d ff a2 1a 8d 99 12"
         "ec 18 a2 ef 62 83 02 4d ec e7 00 00 06 13 01 13 03 13 02 01 00"
         "00 91 00 00 00 0b 00 09 00 00 06 73 65 72 76 65 72 ff 01 00 01"
         "00 00 0a 00 14 00 12 00 1d 00 17 00 18 00 19 01 00 01 01 01 02"
         "01 03 01 04 00 23 00 00 00 33 00 26 00 24 00 1d 00 20 99 38 1d"
         "e5 60 e4 bd 43 d2 3d 8e 43 5a 7d ba fe b3 c0 6e 51 c1 3c ae 4d"
         "54 13 69 1e 52 9a af 2c 00 2b 00 03 02 03 04 00 0d 00 20 00 1e"
         "04 03 05 03 06 03 02 03 08 04 08 05 08 06 04 01 05 01 06 01 02"
         "01 04 02 05 02 06 02 02 02 00 2d 00 02 01 01 00 1c 00 02 40 01");

         const size_t remaining = ctx.server.received_data(client_hello);

         result.test_int_eq(remaining, 0, "client hello was fully consumed");
         result.confirm("server not closed", !ctx.server.is_closed());

         const auto server_hello_record = ctx.pull_send_buffer();
         check_record_header(result, server_hello_record);

         return result;
         }

   public:
      std::vector<Test::Result> run() override
         {
         return
            {
            simple_1_rtt_client_hello()
            // simple_1_rtt_server()
            };
         }
   };

BOTAN_REGISTER_TEST("tls", "tls_rfc8448", Test_TLS_RFC8448);

#endif

}
